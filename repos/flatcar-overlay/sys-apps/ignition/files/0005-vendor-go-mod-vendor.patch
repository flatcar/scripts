From 61fedb620afb81ec657419e0835439c03cc14c04 Mon Sep 17 00:00:00 2001
From: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
Date: Fri, 7 Jun 2024 09:10:35 +0200
Subject: [PATCH 05/21] vendor: go mod vendor

Signed-off-by: Mathieu Tortuyaux <mtortuyaux@microsoft.com>
---
 vendor/github.com/ajeddeloh/go-json/README    |   10 +
 vendor/github.com/ajeddeloh/go-json/decode.go | 1226 +++++++++++++++++
 vendor/github.com/ajeddeloh/go-json/encode.go | 1194 ++++++++++++++++
 vendor/github.com/ajeddeloh/go-json/fold.go   |  143 ++
 vendor/github.com/ajeddeloh/go-json/indent.go |  137 ++
 .../github.com/ajeddeloh/go-json/scanner.go   |  630 +++++++++
 vendor/github.com/ajeddeloh/go-json/stream.go |  480 +++++++
 vendor/github.com/ajeddeloh/go-json/tags.go   |   44 +
 vendor/github.com/coreos/go-systemd/LICENSE   |  191 +++
 vendor/github.com/coreos/go-systemd/NOTICE    |    5 +
 .../coreos/go-systemd/unit/deserialize.go     |  278 ++++
 .../coreos/go-systemd/unit/escape.go          |  116 ++
 .../coreos/go-systemd/unit/option.go          |   59 +
 .../coreos/go-systemd/unit/serialize.go       |   75 +
 vendor/github.com/flatcar/ignition/LICENSE    |  202 +++
 vendor/github.com/flatcar/ignition/NOTICE     |    5 +
 .../ignition/config/shared/errors/errors.go   |  109 ++
 .../config/shared/validations/unit.go         |   54 +
 .../flatcar/ignition/config/util/helpers.go   |   34 +
 .../ignition/config/util/parsingErrors.go     |   74 +
 .../flatcar/ignition/config/v1/cloudinit.go   |   53 +
 .../flatcar/ignition/config/v1/config.go      |   59 +
 .../ignition/config/v1/types/config.go        |   35 +
 .../flatcar/ignition/config/v1/types/disk.go  |  123 ++
 .../flatcar/ignition/config/v1/types/file.go  |   39 +
 .../ignition/config/v1/types/filesystem.go    |   45 +
 .../flatcar/ignition/config/v1/types/group.go |   22 +
 .../ignition/config/v1/types/networkd.go      |   19 +
 .../ignition/config/v1/types/partition.go     |   60 +
 .../ignition/config/v1/types/passwd.go        |   20 +
 .../flatcar/ignition/config/v1/types/path.go  |   31 +
 .../flatcar/ignition/config/v1/types/raid.go  |   44 +
 .../ignition/config/v1/types/storage.go       |   21 +
 .../ignition/config/v1/types/systemd.go       |   19 +
 .../flatcar/ignition/config/v1/types/unit.go  |   73 +
 .../flatcar/ignition/config/v1/types/user.go  |   35 +
 .../flatcar/ignition/config/v2_0/append.go    |   76 +
 .../flatcar/ignition/config/v2_0/cloudinit.go |   53 +
 .../flatcar/ignition/config/v2_0/config.go    |   70 +
 .../flatcar/ignition/config/v2_0/translate.go |  173 +++
 .../ignition/config/v2_0/types/compression.go |   31 +
 .../ignition/config/v2_0/types/config.go      |   87 ++
 .../ignition/config/v2_0/types/disk.go        |  126 ++
 .../ignition/config/v2_0/types/file.go        |   61 +
 .../ignition/config/v2_0/types/filesystem.go  |   60 +
 .../ignition/config/v2_0/types/group.go       |   22 +
 .../ignition/config/v2_0/types/hash.go        |   72 +
 .../ignition/config/v2_0/types/ignition.go    |   64 +
 .../ignition/config/v2_0/types/networkd.go    |   19 +
 .../ignition/config/v2_0/types/partition.go   |   64 +
 .../ignition/config/v2_0/types/passwd.go      |   20 +
 .../ignition/config/v2_0/types/path.go        |   35 +
 .../ignition/config/v2_0/types/raid.go        |   44 +
 .../ignition/config/v2_0/types/storage.go     |   22 +
 .../ignition/config/v2_0/types/systemd.go     |   19 +
 .../ignition/config/v2_0/types/unit.go        |  115 ++
 .../flatcar/ignition/config/v2_0/types/url.go |   69 +
 .../ignition/config/v2_0/types/user.go        |   35 +
 .../config/v2_0/types/verification.go         |   19 +
 .../flatcar/ignition/config/v2_1/append.go    |   76 +
 .../flatcar/ignition/config/v2_1/cloudinit.go |   53 +
 .../flatcar/ignition/config/v2_1/config.go    |   68 +
 .../flatcar/ignition/config/v2_1/translate.go |  236 ++++
 .../ignition/config/v2_1/types/config.go      |   91 ++
 .../ignition/config/v2_1/types/directory.go   |   30 +
 .../ignition/config/v2_1/types/disk.go        |  128 ++
 .../ignition/config/v2_1/types/file.go        |   56 +
 .../ignition/config/v2_1/types/filesystem.go  |  144 ++
 .../ignition/config/v2_1/types/ignition.go    |   52 +
 .../ignition/config/v2_1/types/mode.go        |   26 +
 .../ignition/config/v2_1/types/node.go        |   73 +
 .../ignition/config/v2_1/types/partition.go   |   77 ++
 .../ignition/config/v2_1/types/passwd.go      |   67 +
 .../ignition/config/v2_1/types/path.go        |   28 +
 .../ignition/config/v2_1/types/raid.go        |   57 +
 .../ignition/config/v2_1/types/schema.go      |  221 +++
 .../ignition/config/v2_1/types/unit.go        |  109 ++
 .../flatcar/ignition/config/v2_1/types/url.go |   52 +
 .../config/v2_1/types/verification.go         |   77 ++
 .../flatcar/ignition/config/v2_2/append.go    |   76 +
 .../flatcar/ignition/config/v2_2/cloudinit.go |   53 +
 .../flatcar/ignition/config/v2_2/config.go    |   71 +
 .../flatcar/ignition/config/v2_2/translate.go |  354 +++++
 .../flatcar/ignition/config/v2_2/types/ca.go  |   27 +
 .../ignition/config/v2_2/types/config.go      |   91 ++
 .../ignition/config/v2_2/types/directory.go   |   37 +
 .../ignition/config/v2_2/types/disk.go        |  128 ++
 .../ignition/config/v2_2/types/file.go        |   69 +
 .../ignition/config/v2_2/types/filesystem.go  |  144 ++
 .../ignition/config/v2_2/types/ignition.go    |   52 +
 .../ignition/config/v2_2/types/mode.go        |   26 +
 .../ignition/config/v2_2/types/node.go        |   73 +
 .../ignition/config/v2_2/types/partition.go   |   77 ++
 .../ignition/config/v2_2/types/passwd.go      |   67 +
 .../ignition/config/v2_2/types/path.go        |   28 +
 .../ignition/config/v2_2/types/raid.go        |   57 +
 .../ignition/config/v2_2/types/schema.go      |  246 ++++
 .../ignition/config/v2_2/types/unit.go        |  131 ++
 .../flatcar/ignition/config/v2_2/types/url.go |   53 +
 .../config/v2_2/types/verification.go         |   77 ++
 .../flatcar/ignition/config/v2_3/append.go    |   76 +
 .../flatcar/ignition/config/v2_3/cloudinit.go |   53 +
 .../flatcar/ignition/config/v2_3/config.go    |   70 +
 .../flatcar/ignition/config/v2_3/translate.go |  380 +++++
 .../flatcar/ignition/config/v2_3/types/ca.go  |   27 +
 .../ignition/config/v2_3/types/config.go      |   91 ++
 .../ignition/config/v2_3/types/directory.go   |   37 +
 .../ignition/config/v2_3/types/disk.go        |  164 +++
 .../ignition/config/v2_3/types/file.go        |   71 +
 .../ignition/config/v2_3/types/filesystem.go  |  146 ++
 .../ignition/config/v2_3/types/ignition.go    |   52 +
 .../ignition/config/v2_3/types/mode.go        |   26 +
 .../ignition/config/v2_3/types/node.go        |   73 +
 .../ignition/config/v2_3/types/partition.go   |  112 ++
 .../ignition/config/v2_3/types/passwd.go      |   67 +
 .../ignition/config/v2_3/types/path.go        |   28 +
 .../ignition/config/v2_3/types/raid.go        |   57 +
 .../ignition/config/v2_3/types/schema.go      |  250 ++++
 .../ignition/config/v2_3/types/unit.go        |  131 ++
 .../flatcar/ignition/config/v2_3/types/url.go |   53 +
 .../config/v2_3/types/verification.go         |   77 ++
 .../flatcar/ignition/config/v2_4/append.go    |   76 +
 .../flatcar/ignition/config/v2_4/cloudinit.go |   53 +
 .../flatcar/ignition/config/v2_4/config.go    |   70 +
 .../flatcar/ignition/config/v2_4/translate.go |  398 ++++++
 .../flatcar/ignition/config/v2_4/types/ca.go  |   58 +
 .../ignition/config/v2_4/types/config.go      |   91 ++
 .../ignition/config/v2_4/types/directory.go   |   37 +
 .../ignition/config/v2_4/types/disk.go        |  164 +++
 .../ignition/config/v2_4/types/file.go        |  100 ++
 .../ignition/config/v2_4/types/filesystem.go  |  146 ++
 .../ignition/config/v2_4/types/headers.go     |   47 +
 .../ignition/config/v2_4/types/ignition.go    |   82 ++
 .../ignition/config/v2_4/types/mode.go        |   26 +
 .../ignition/config/v2_4/types/node.go        |   73 +
 .../ignition/config/v2_4/types/partition.go   |  112 ++
 .../ignition/config/v2_4/types/passwd.go      |   67 +
 .../ignition/config/v2_4/types/path.go        |   28 +
 .../ignition/config/v2_4/types/raid.go        |   57 +
 .../ignition/config/v2_4/types/schema.go      |  269 ++++
 .../ignition/config/v2_4/types/unit.go        |  131 ++
 .../flatcar/ignition/config/v2_4/types/url.go |   53 +
 .../config/v2_4/types/verification.go         |   77 ++
 .../ignition/config/validate/astjson/node.go  |   73 +
 .../config/validate/astnode/astnode.go        |   45 +
 .../ignition/config/validate/report/report.go |  158 +++
 .../ignition/config/validate/validate.go      |  242 ++++
 vendor/go4.org/AUTHORS                        |    8 +
 vendor/go4.org/LICENSE                        |  202 +++
 vendor/go4.org/errorutil/highlight.go         |   58 +
 vendor/modules.txt                            |   30 +
 151 files changed, 15850 insertions(+)
 create mode 100644 vendor/github.com/ajeddeloh/go-json/README
 create mode 100644 vendor/github.com/ajeddeloh/go-json/decode.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/encode.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/fold.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/indent.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/scanner.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/stream.go
 create mode 100644 vendor/github.com/ajeddeloh/go-json/tags.go
 create mode 100644 vendor/github.com/coreos/go-systemd/LICENSE
 create mode 100644 vendor/github.com/coreos/go-systemd/NOTICE
 create mode 100644 vendor/github.com/coreos/go-systemd/unit/deserialize.go
 create mode 100644 vendor/github.com/coreos/go-systemd/unit/escape.go
 create mode 100644 vendor/github.com/coreos/go-systemd/unit/option.go
 create mode 100644 vendor/github.com/coreos/go-systemd/unit/serialize.go
 create mode 100644 vendor/github.com/flatcar/ignition/LICENSE
 create mode 100644 vendor/github.com/flatcar/ignition/NOTICE
 create mode 100644 vendor/github.com/flatcar/ignition/config/shared/errors/errors.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/shared/validations/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/util/helpers.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/util/parsingErrors.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/group.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/networkd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/storage.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/systemd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v1/types/user.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/append.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/translate.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/compression.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/group.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/hash.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/ignition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/networkd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/storage.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/systemd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/url.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/user.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_0/types/verification.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/append.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/translate.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/directory.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/ignition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/mode.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/node.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/schema.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/url.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_1/types/verification.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/append.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/translate.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/ca.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/directory.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/ignition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/mode.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/node.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/schema.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/url.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_2/types/verification.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/append.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/translate.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/ca.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/directory.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/ignition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/mode.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/node.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/schema.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/url.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_3/types/verification.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/append.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/cloudinit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/translate.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/ca.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/config.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/directory.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/disk.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/file.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/filesystem.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/headers.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/ignition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/mode.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/node.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/partition.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/passwd.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/path.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/raid.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/schema.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/unit.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/url.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/v2_4/types/verification.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/validate/astjson/node.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/validate/astnode/astnode.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/validate/report/report.go
 create mode 100644 vendor/github.com/flatcar/ignition/config/validate/validate.go
 create mode 100644 vendor/go4.org/AUTHORS
 create mode 100644 vendor/go4.org/LICENSE
 create mode 100644 vendor/go4.org/errorutil/highlight.go

diff --git a/vendor/github.com/ajeddeloh/go-json/README b/vendor/github.com/ajeddeloh/go-json/README
new file mode 100644
index 00000000..0f53d345
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/README
@@ -0,0 +1,10 @@
+This is a fork of go's encoding/json library. It adds the a third target for unmarshalling, json.Node.
+Unmarshalling to a Node behaves similarilarly to unmarshalling to an interface{}, except it also records
+the offsets for the start and end of the value that was unmarshalled and, if the value was part of a json
+object, it also records the offsets of the start and end of the object's key. The Value field of the Node
+will be unmarshalled to the same types as if it were an interface{}, except in the case of arrays and
+objects. In those case it will be unmarshalled to a []Node or map[string]Node instead []interface{} or
+map[string]interface{} for arrays and objects, respectively.
+
+There are two branchs, go15 and go16. go15 contains the modified go1.5 library and go16 contains the
+modified go1.6 library.
diff --git a/vendor/github.com/ajeddeloh/go-json/decode.go b/vendor/github.com/ajeddeloh/go-json/decode.go
new file mode 100644
index 00000000..ed5398dd
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/decode.go
@@ -0,0 +1,1226 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Represents JSON data structure using native Go types: booleans, floats,
+// strings, arrays, and maps.
+
+package json
+
+import (
+	"bytes"
+	"encoding"
+	"encoding/base64"
+	"errors"
+	"fmt"
+	"reflect"
+	"runtime"
+	"strconv"
+	"unicode"
+	"unicode/utf16"
+	"unicode/utf8"
+)
+
+// Unmarshal parses the JSON-encoded data and stores the result
+// in the value pointed to by v.
+//
+// Unmarshal uses the inverse of the encodings that
+// Marshal uses, allocating maps, slices, and pointers as necessary,
+// with the following additional rules:
+//
+// To unmarshal JSON into a pointer, Unmarshal first handles the case of
+// the JSON being the JSON literal null.  In that case, Unmarshal sets
+// the pointer to nil.  Otherwise, Unmarshal unmarshals the JSON into
+// the value pointed at by the pointer.  If the pointer is nil, Unmarshal
+// allocates a new value for it to point to.
+//
+// To unmarshal JSON into a struct, Unmarshal matches incoming object
+// keys to the keys used by Marshal (either the struct field name or its tag),
+// preferring an exact match but also accepting a case-insensitive match.
+//
+// To unmarshal JSON into an interface value,
+// Unmarshal stores one of these in the interface value:
+//
+//	bool, for JSON booleans
+//	float64, for JSON numbers
+//	string, for JSON strings
+//	[]interface{}, for JSON arrays
+//	map[string]interface{}, for JSON objects
+//	nil for JSON null
+//
+// To unmarshal a JSON array into a slice, Unmarshal resets the slice to nil
+// and then appends each element to the slice.
+//
+// To unmarshal a JSON object into a map, Unmarshal replaces the map
+// with an empty map and then adds key-value pairs from the object to
+// the map.
+//
+// If a JSON value is not appropriate for a given target type,
+// or if a JSON number overflows the target type, Unmarshal
+// skips that field and completes the unmarshalling as best it can.
+// If no more serious errors are encountered, Unmarshal returns
+// an UnmarshalTypeError describing the earliest such error.
+//
+// The JSON null value unmarshals into an interface, map, pointer, or slice
+// by setting that Go value to nil. Because null is often used in JSON to mean
+// ``not present,'' unmarshaling a JSON null into any other Go type has no effect
+// on the value and produces no error.
+//
+// When unmarshaling quoted strings, invalid UTF-8 or
+// invalid UTF-16 surrogate pairs are not treated as an error.
+// Instead, they are replaced by the Unicode replacement
+// character U+FFFD.
+//
+func Unmarshal(data []byte, v interface{}) error {
+	// Check for well-formedness.
+	// Avoids filling out half a data structure
+	// before discovering a JSON syntax error.
+	var d decodeState
+	err := checkValid(data, &d.scan)
+	if err != nil {
+		return err
+	}
+
+	d.init(data)
+	return d.unmarshal(v)
+}
+
+// Unmarshaler is the interface implemented by objects
+// that can unmarshal a JSON description of themselves.
+// The input can be assumed to be a valid encoding of
+// a JSON value. UnmarshalJSON must copy the JSON data
+// if it wishes to retain the data after returning.
+type Unmarshaler interface {
+	UnmarshalJSON([]byte) error
+}
+
+// An UnmarshalTypeError describes a JSON value that was
+// not appropriate for a value of a specific Go type.
+type UnmarshalTypeError struct {
+	Value  string       // description of JSON value - "bool", "array", "number -5"
+	Type   reflect.Type // type of Go value it could not be assigned to
+	Offset int64        // error occurred after reading Offset bytes
+}
+
+func (e *UnmarshalTypeError) Error() string {
+	return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String()
+}
+
+// An UnmarshalFieldError describes a JSON object key that
+// led to an unexported (and therefore unwritable) struct field.
+// (No longer used; kept for compatibility.)
+type UnmarshalFieldError struct {
+	Key   string
+	Type  reflect.Type
+	Field reflect.StructField
+}
+
+func (e *UnmarshalFieldError) Error() string {
+	return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String()
+}
+
+// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
+// (The argument to Unmarshal must be a non-nil pointer.)
+type InvalidUnmarshalError struct {
+	Type reflect.Type
+}
+
+type Node struct {
+	Start    int
+	End      int
+	KeyStart int // Only value if a member of a struct
+	KeyEnd   int
+	Value    interface{}
+}
+
+func (e *InvalidUnmarshalError) Error() string {
+	if e.Type == nil {
+		return "json: Unmarshal(nil)"
+	}
+
+	if e.Type.Kind() != reflect.Ptr {
+		return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
+	}
+	return "json: Unmarshal(nil " + e.Type.String() + ")"
+}
+
+func (d *decodeState) unmarshal(v interface{}) (err error) {
+	defer func() {
+		if r := recover(); r != nil {
+			if _, ok := r.(runtime.Error); ok {
+				panic(r)
+			}
+			err = r.(error)
+		}
+	}()
+
+	rv := reflect.ValueOf(v)
+	if rv.Kind() != reflect.Ptr || rv.IsNil() {
+		return &InvalidUnmarshalError{reflect.TypeOf(v)}
+	}
+
+	d.scan.reset()
+	// We decode rv not rv.Elem because the Unmarshaler interface
+	// test must be applied at the top level of the value.
+	d.value(rv)
+	return d.savedError
+}
+
+// A Number represents a JSON number literal.
+type Number string
+
+// String returns the literal text of the number.
+func (n Number) String() string { return string(n) }
+
+// Float64 returns the number as a float64.
+func (n Number) Float64() (float64, error) {
+	return strconv.ParseFloat(string(n), 64)
+}
+
+// Int64 returns the number as an int64.
+func (n Number) Int64() (int64, error) {
+	return strconv.ParseInt(string(n), 10, 64)
+}
+
+// decodeState represents the state while decoding a JSON value.
+type decodeState struct {
+	data       []byte
+	off        int // read offset in data
+	scan       scanner
+	nextscan   scanner // for calls to nextValue
+	savedError error
+	useNumber  bool
+}
+
+// errPhase is used for errors that should not happen unless
+// there is a bug in the JSON decoder or something is editing
+// the data slice while the decoder executes.
+var errPhase = errors.New("JSON decoder out of sync - data changing underfoot?")
+
+func (d *decodeState) init(data []byte) *decodeState {
+	d.data = data
+	d.off = 0
+	d.savedError = nil
+	return d
+}
+
+// error aborts the decoding by panicking with err.
+func (d *decodeState) error(err error) {
+	panic(err)
+}
+
+// saveError saves the first err it is called with,
+// for reporting at the end of the unmarshal.
+func (d *decodeState) saveError(err error) {
+	if d.savedError == nil {
+		d.savedError = err
+	}
+}
+
+// next cuts off and returns the next full JSON value in d.data[d.off:].
+// The next value is known to be an object or array, not a literal.
+func (d *decodeState) next() []byte {
+	c := d.data[d.off]
+	item, rest, err := nextValue(d.data[d.off:], &d.nextscan)
+	if err != nil {
+		d.error(err)
+	}
+	d.off = len(d.data) - len(rest)
+
+	// Our scanner has seen the opening brace/bracket
+	// and thinks we're still in the middle of the object.
+	// invent a closing brace/bracket to get it out.
+	if c == '{' {
+		d.scan.step(&d.scan, '}')
+	} else {
+		d.scan.step(&d.scan, ']')
+	}
+
+	return item
+}
+
+// scanWhile processes bytes in d.data[d.off:] until it
+// receives a scan code not equal to op.
+// It updates d.off and returns the new scan code.
+func (d *decodeState) scanWhile(op int) int {
+	var newOp int
+	for {
+		if d.off >= len(d.data) {
+			newOp = d.scan.eof()
+			d.off = len(d.data) + 1 // mark processed EOF with len+1
+		} else {
+			c := int(d.data[d.off])
+			d.off++
+			newOp = d.scan.step(&d.scan, c)
+		}
+		if newOp != op {
+			break
+		}
+	}
+	return newOp
+}
+
+// value decodes a JSON value from d.data[d.off:] into the value.
+// it updates d.off to point past the decoded value.
+func (d *decodeState) value(v reflect.Value) {
+	if !v.IsValid() {
+		_, rest, err := nextValue(d.data[d.off:], &d.nextscan)
+		if err != nil {
+			d.error(err)
+		}
+		d.off = len(d.data) - len(rest)
+
+		// d.scan thinks we're still at the beginning of the item.
+		// Feed in an empty string - the shortest, simplest value -
+		// so that it knows we got to the end of the value.
+		if d.scan.redo {
+			// rewind.
+			d.scan.redo = false
+			d.scan.step = stateBeginValue
+		}
+		d.scan.step(&d.scan, '"')
+		d.scan.step(&d.scan, '"')
+
+		n := len(d.scan.parseState)
+		if n > 0 && d.scan.parseState[n-1] == parseObjectKey {
+			// d.scan thinks we just read an object key; finish the object
+			d.scan.step(&d.scan, ':')
+			d.scan.step(&d.scan, '"')
+			d.scan.step(&d.scan, '"')
+			d.scan.step(&d.scan, '}')
+		}
+
+		return
+	}
+
+	switch op := d.scanWhile(scanSkipSpace); op {
+	default:
+		d.error(errPhase)
+
+	case scanBeginArray:
+		d.array(v)
+
+	case scanBeginObject:
+		d.object(v)
+
+	case scanBeginLiteral:
+		d.literal(v)
+	}
+}
+
+type unquotedValue struct{}
+
+// valueQuoted is like value but decodes a
+// quoted string literal or literal null into an interface value.
+// If it finds anything other than a quoted string literal or null,
+// valueQuoted returns unquotedValue{}.
+func (d *decodeState) valueQuoted() interface{} {
+	switch op := d.scanWhile(scanSkipSpace); op {
+	default:
+		d.error(errPhase)
+
+	case scanBeginArray:
+		d.array(reflect.Value{})
+
+	case scanBeginObject:
+		d.object(reflect.Value{})
+
+	case scanBeginLiteral:
+		switch v := d.literalInterface().(type) {
+		case nil, string:
+			return v
+		}
+	}
+	return unquotedValue{}
+}
+
+// indirect walks down v allocating pointers as needed,
+// until it gets to a non-pointer.
+// if it encounters an Unmarshaler, indirect stops and returns that.
+// if decodingNull is true, indirect stops at the last pointer so it can be set to nil.
+func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
+	// If v is a named type and is addressable,
+	// start with its address, so that if the type has pointer methods,
+	// we find them.
+	if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
+		v = v.Addr()
+	}
+	for {
+		// Load value from interface, but only if the result will be
+		// usefully addressable.
+		if v.Kind() == reflect.Interface && !v.IsNil() {
+			e := v.Elem()
+			if e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {
+				v = e
+				continue
+			}
+		}
+
+		if v.Kind() != reflect.Ptr {
+			break
+		}
+
+		if v.Elem().Kind() != reflect.Ptr && decodingNull && v.CanSet() {
+			break
+		}
+		if v.IsNil() {
+			v.Set(reflect.New(v.Type().Elem()))
+		}
+		if v.Type().NumMethod() > 0 {
+			if u, ok := v.Interface().(Unmarshaler); ok {
+				return u, nil, reflect.Value{}
+			}
+			if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
+				return nil, u, reflect.Value{}
+			}
+		}
+		v = v.Elem()
+	}
+	return nil, nil, v
+}
+
+// array consumes an array from d.data[d.off-1:], decoding into the value v.
+// the first byte of the array ('[') has been read already.
+func (d *decodeState) array(v reflect.Value) {
+	// Check for unmarshaler.
+	u, ut, pv := d.indirect(v, false)
+	if u != nil {
+		d.off--
+		err := u.UnmarshalJSON(d.next())
+		if err != nil {
+			d.error(err)
+		}
+		return
+	}
+	if ut != nil {
+		d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
+		d.off--
+		d.next()
+		return
+	}
+
+	v = pv
+
+	// Check type of target.
+	switch v.Kind() {
+	case reflect.Interface:
+		if v.NumMethod() == 0 {
+			// Decoding into nil interface?  Switch to non-reflect code.
+			v.Set(reflect.ValueOf(d.arrayInterface()))
+			return
+		}
+		// Otherwise it's invalid.
+		fallthrough
+	default:
+		if v.Type() == reflect.TypeOf(Node{}) {
+			// Decoding to Node? Switch to that code
+			v.Set(reflect.ValueOf(d.arrayNode()))
+			return
+		}
+		d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
+		d.off--
+		d.next()
+		return
+	case reflect.Array:
+	case reflect.Slice:
+		break
+	}
+
+	i := 0
+	for {
+		// Look ahead for ] - can only happen on first iteration.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+
+		// Back up so d.value can have the byte we just read.
+		d.off--
+		d.scan.undo(op)
+
+		// Get element of array, growing if necessary.
+		if v.Kind() == reflect.Slice {
+			// Grow slice if necessary
+			if i >= v.Cap() {
+				newcap := v.Cap() + v.Cap()/2
+				if newcap < 4 {
+					newcap = 4
+				}
+				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
+				reflect.Copy(newv, v)
+				v.Set(newv)
+			}
+			if i >= v.Len() {
+				v.SetLen(i + 1)
+			}
+		}
+
+		if i < v.Len() {
+			// Decode into element.
+			d.value(v.Index(i))
+		} else {
+			// Ran out of fixed array: skip.
+			d.value(reflect.Value{})
+		}
+		i++
+
+		// Next token must be , or ].
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+		if op != scanArrayValue {
+			d.error(errPhase)
+		}
+	}
+
+	if i < v.Len() {
+		if v.Kind() == reflect.Array {
+			// Array.  Zero the rest.
+			z := reflect.Zero(v.Type().Elem())
+			for ; i < v.Len(); i++ {
+				v.Index(i).Set(z)
+			}
+		} else {
+			v.SetLen(i)
+		}
+	}
+	if i == 0 && v.Kind() == reflect.Slice {
+		v.Set(reflect.MakeSlice(v.Type(), 0, 0))
+	}
+}
+
+var nullLiteral = []byte("null")
+
+// object consumes an object from d.data[d.off-1:], decoding into the value v.
+// the first byte ('{') of the object has been read already.
+func (d *decodeState) object(v reflect.Value) {
+	// Check for unmarshaler.
+	u, ut, pv := d.indirect(v, false)
+	if u != nil {
+		d.off--
+		err := u.UnmarshalJSON(d.next())
+		if err != nil {
+			d.error(err)
+		}
+		return
+	}
+	if ut != nil {
+		d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
+		d.off--
+		d.next() // skip over { } in input
+		return
+	}
+	v = pv
+
+	// Decoding into nil interface?  Switch to non-reflect code.
+	if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
+		v.Set(reflect.ValueOf(d.objectInterface()))
+		return
+	} else if v.Type() == reflect.TypeOf(Node{}) {
+		// Decoding to Node? Switch to that code
+		v.Set(reflect.ValueOf(d.objectNode()))
+		return
+	}
+
+	// Check type of target: struct or map[string]T
+	switch v.Kind() {
+	case reflect.Map:
+		// map must have string kind
+		t := v.Type()
+		if t.Key().Kind() != reflect.String {
+			d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
+			d.off--
+			d.next() // skip over { } in input
+			return
+		}
+		if v.IsNil() {
+			v.Set(reflect.MakeMap(t))
+		}
+	case reflect.Struct:
+
+	default:
+		d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
+		d.off--
+		d.next() // skip over { } in input
+		return
+	}
+
+	var mapElem reflect.Value
+
+	for {
+		// Read opening " of string key or closing }.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			// closing } - can only happen on first iteration.
+			break
+		}
+		if op != scanBeginLiteral {
+			d.error(errPhase)
+		}
+
+		// Read key.
+		start := d.off - 1
+		op = d.scanWhile(scanContinue)
+		item := d.data[start : d.off-1]
+		key, ok := unquoteBytes(item)
+		if !ok {
+			d.error(errPhase)
+		}
+
+		// Figure out field corresponding to key.
+		var subv reflect.Value
+		destring := false // whether the value is wrapped in a string to be decoded first
+
+		if v.Kind() == reflect.Map {
+			elemType := v.Type().Elem()
+			if !mapElem.IsValid() {
+				mapElem = reflect.New(elemType).Elem()
+			} else {
+				mapElem.Set(reflect.Zero(elemType))
+			}
+			subv = mapElem
+		} else {
+			var f *field
+			fields := cachedTypeFields(v.Type())
+			for i := range fields {
+				ff := &fields[i]
+				if bytes.Equal(ff.nameBytes, key) {
+					f = ff
+					break
+				}
+				if f == nil && ff.equalFold(ff.nameBytes, key) {
+					f = ff
+				}
+			}
+			if f != nil {
+				subv = v
+				destring = f.quoted
+				for _, i := range f.index {
+					if subv.Kind() == reflect.Ptr {
+						if subv.IsNil() {
+							subv.Set(reflect.New(subv.Type().Elem()))
+						}
+						subv = subv.Elem()
+					}
+					subv = subv.Field(i)
+				}
+			}
+		}
+
+		// Read : before value.
+		if op == scanSkipSpace {
+			op = d.scanWhile(scanSkipSpace)
+		}
+		if op != scanObjectKey {
+			d.error(errPhase)
+		}
+
+		// Read value.
+		if destring {
+			switch qv := d.valueQuoted().(type) {
+			case nil:
+				d.literalStore(nullLiteral, subv, false)
+			case string:
+				d.literalStore([]byte(qv), subv, true)
+			default:
+				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v", subv.Type()))
+			}
+		} else {
+			d.value(subv)
+		}
+
+		// Write value back to map;
+		// if using struct, subv points into struct already.
+		if v.Kind() == reflect.Map {
+			kv := reflect.ValueOf(key).Convert(v.Type().Key())
+			v.SetMapIndex(kv, subv)
+		}
+
+		// Next token must be , or }.
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			break
+		}
+		if op != scanObjectValue {
+			d.error(errPhase)
+		}
+	}
+}
+
+// literal consumes a literal from d.data[d.off-1:], decoding into the value v.
+// The first byte of the literal has been read already
+// (that's how the caller knows it's a literal).
+func (d *decodeState) literal(v reflect.Value) {
+	// All bytes inside literal return scanContinue op code.
+	start := d.off - 1
+	op := d.scanWhile(scanContinue)
+
+	// Scan read one byte too far; back up.
+	d.off--
+	d.scan.undo(op)
+
+	d.literalStore(d.data[start:d.off], v, false)
+}
+
+// convertNumber converts the number literal s to a float64 or a Number
+// depending on the setting of d.useNumber.
+func (d *decodeState) convertNumber(s string) (interface{}, error) {
+	if d.useNumber {
+		return Number(s), nil
+	}
+	f, err := strconv.ParseFloat(s, 64)
+	if err != nil {
+		return nil, &UnmarshalTypeError{"number " + s, reflect.TypeOf(0.0), int64(d.off)}
+	}
+	return f, nil
+}
+
+var numberType = reflect.TypeOf(Number(""))
+
+// literalStore decodes a literal stored in item into v.
+//
+// fromQuoted indicates whether this literal came from unwrapping a
+// string from the ",string" struct tag option. this is used only to
+// produce more helpful error messages.
+func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {
+	// Check for unmarshaler.
+	if len(item) == 0 {
+		//Empty string given
+		d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+		return
+	}
+	wantptr := item[0] == 'n' // null
+	u, ut, pv := d.indirect(v, wantptr)
+	if u != nil {
+		err := u.UnmarshalJSON(item)
+		if err != nil {
+			d.error(err)
+		}
+		return
+	}
+	if ut != nil {
+		if item[0] != '"' {
+			if fromQuoted {
+				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
+			}
+			return
+		}
+		s, ok := unquoteBytes(item)
+		if !ok {
+			if fromQuoted {
+				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.error(errPhase)
+			}
+		}
+		err := ut.UnmarshalText(s)
+		if err != nil {
+			d.error(err)
+		}
+		return
+	}
+
+	v = pv
+
+	switch c := item[0]; c {
+	case 'n': // null
+		switch v.Kind() {
+		case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
+			v.Set(reflect.Zero(v.Type()))
+			// otherwise, ignore null for primitives/string
+		}
+	case 't', 'f': // true, false
+		value := c == 't'
+		switch v.Kind() {
+		default:
+			if fromQuoted {
+				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
+			}
+		case reflect.Bool:
+			v.SetBool(value)
+		case reflect.Interface:
+			if v.NumMethod() == 0 {
+				v.Set(reflect.ValueOf(value))
+			} else {
+				d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
+			}
+		}
+
+	case '"': // string
+		s, ok := unquoteBytes(item)
+		if !ok {
+			if fromQuoted {
+				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.error(errPhase)
+			}
+		}
+		switch v.Kind() {
+		default:
+			d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
+		case reflect.Slice:
+			if v.Type().Elem().Kind() != reflect.Uint8 {
+				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
+				break
+			}
+			b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
+			n, err := base64.StdEncoding.Decode(b, s)
+			if err != nil {
+				d.saveError(err)
+				break
+			}
+			v.Set(reflect.ValueOf(b[0:n]))
+		case reflect.String:
+			v.SetString(string(s))
+		case reflect.Interface:
+			if v.NumMethod() == 0 {
+				v.Set(reflect.ValueOf(string(s)))
+			} else {
+				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
+			}
+		}
+
+	default: // number
+		if c != '-' && (c < '0' || c > '9') {
+			if fromQuoted {
+				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.error(errPhase)
+			}
+		}
+		s := string(item)
+		switch v.Kind() {
+		default:
+			if v.Kind() == reflect.String && v.Type() == numberType {
+				v.SetString(s)
+				break
+			}
+			if fromQuoted {
+				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
+			} else {
+				d.error(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
+			}
+		case reflect.Interface:
+			n, err := d.convertNumber(s)
+			if err != nil {
+				d.saveError(err)
+				break
+			}
+			if v.NumMethod() != 0 {
+				d.saveError(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
+				break
+			}
+			v.Set(reflect.ValueOf(n))
+
+		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+			n, err := strconv.ParseInt(s, 10, 64)
+			if err != nil || v.OverflowInt(n) {
+				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
+				break
+			}
+			v.SetInt(n)
+
+		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
+			n, err := strconv.ParseUint(s, 10, 64)
+			if err != nil || v.OverflowUint(n) {
+				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
+				break
+			}
+			v.SetUint(n)
+
+		case reflect.Float32, reflect.Float64:
+			n, err := strconv.ParseFloat(s, v.Type().Bits())
+			if err != nil || v.OverflowFloat(n) {
+				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
+				break
+			}
+			v.SetFloat(n)
+		}
+	}
+}
+
+// The xxxInterface routines build up a value to be stored
+// in an empty interface.  They are not strictly necessary,
+// but they avoid the weight of reflection in this common case.
+
+// valueInterface is like value but returns interface{}
+func (d *decodeState) valueInterface() interface{} {
+	switch d.scanWhile(scanSkipSpace) {
+	default:
+		d.error(errPhase)
+		panic("unreachable")
+	case scanBeginArray:
+		return d.arrayInterface()
+	case scanBeginObject:
+		return d.objectInterface()
+	case scanBeginLiteral:
+		return d.literalInterface()
+	}
+}
+
+// valueNode is like valueInterface but returns a wrapped version that
+// contains metadata about where it decoded from
+func (d *decodeState) valueNode() Node {
+	switch d.scanWhile(scanSkipSpace) {
+	default:
+		d.error(errPhase)
+		panic("unreachable")
+	case scanBeginArray:
+		return d.arrayNode()
+	case scanBeginObject:
+		return d.objectNode()
+	case scanBeginLiteral:
+		return d.literalNode()
+	}
+}
+
+// arrayInterface is like array but returns []interface{}.
+func (d *decodeState) arrayInterface() []interface{} {
+	var v = make([]interface{}, 0)
+	for {
+		// Look ahead for ] - can only happen on first iteration.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+
+		// Back up so d.value can have the byte we just read.
+		d.off--
+		d.scan.undo(op)
+
+		v = append(v, d.valueInterface())
+
+		// Next token must be , or ].
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+		if op != scanArrayValue {
+			d.error(errPhase)
+		}
+	}
+	return v
+}
+
+// arrayNode is like arrayInterface but returns Node.
+func (d *decodeState) arrayNode() Node {
+	var v = make([]Node, 0)
+	node := Node{
+		Start: d.off,
+		Value: v,
+	}
+	for {
+		// Look ahead for ] - can only happen on first iteration.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+
+		// Back up so d.value can have the byte we just read.
+		d.off--
+		d.scan.undo(op)
+
+		v = append(v, d.valueNode())
+
+		// Next token must be , or ].
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndArray {
+			break
+		}
+		if op != scanArrayValue {
+			d.error(errPhase)
+		}
+	}
+	node.Value = v
+	node.End = d.off
+	return node
+}
+
+// objectInterface is like object but returns map[string]interface{}.
+func (d *decodeState) objectInterface() map[string]interface{} {
+	m := make(map[string]interface{})
+	for {
+		// Read opening " of string key or closing }.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			// closing } - can only happen on first iteration.
+			break
+		}
+		if op != scanBeginLiteral {
+			d.error(errPhase)
+		}
+
+		// Read string key.
+		start := d.off - 1
+		op = d.scanWhile(scanContinue)
+		item := d.data[start : d.off-1]
+		key, ok := unquote(item)
+		if !ok {
+			d.error(errPhase)
+		}
+
+		// Read : before value.
+		if op == scanSkipSpace {
+			op = d.scanWhile(scanSkipSpace)
+		}
+		if op != scanObjectKey {
+			d.error(errPhase)
+		}
+
+		// Read value.
+		m[key] = d.valueInterface()
+
+		// Next token must be , or }.
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			break
+		}
+		if op != scanObjectValue {
+			d.error(errPhase)
+		}
+	}
+	return m
+}
+
+// objectNode is like object but returns Node.
+func (d *decodeState) objectNode() Node {
+	m := make(map[string]Node)
+	node := Node{
+		Start: d.off,
+	}
+	for {
+		// Read opening " of string key or closing }.
+		op := d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			// closing } - can only happen on first iteration.
+			break
+		}
+		if op != scanBeginLiteral {
+			d.error(errPhase)
+		}
+
+		// Read string key.
+		start := d.off - 1
+		op = d.scanWhile(scanContinue)
+		item := d.data[start : d.off-1]
+		keyEnd := d.off - 1
+		key, ok := unquote(item)
+		if !ok {
+			d.error(errPhase)
+		}
+
+		// Read : before value.
+		if op == scanSkipSpace {
+			op = d.scanWhile(scanSkipSpace)
+		}
+		if op != scanObjectKey {
+			d.error(errPhase)
+		}
+
+		// Read value.
+		val := d.valueNode()
+		val.KeyStart = start
+		val.KeyEnd = keyEnd
+		m[key] = val
+
+		// Next token must be , or }.
+		op = d.scanWhile(scanSkipSpace)
+		if op == scanEndObject {
+			break
+		}
+		if op != scanObjectValue {
+			d.error(errPhase)
+		}
+	}
+	node.Value = m
+	node.End = d.off
+	return node
+}
+
+// literalInterface is like literal but returns an interface value.
+func (d *decodeState) literalInterface() interface{} {
+	// All bytes inside literal return scanContinue op code.
+	start := d.off - 1
+	op := d.scanWhile(scanContinue)
+
+	// Scan read one byte too far; back up.
+	d.off--
+	d.scan.undo(op)
+	item := d.data[start:d.off]
+
+	switch c := item[0]; c {
+	case 'n': // null
+		return nil
+
+	case 't', 'f': // true, false
+		return c == 't'
+
+	case '"': // string
+		s, ok := unquote(item)
+		if !ok {
+			d.error(errPhase)
+		}
+		return s
+
+	default: // number
+		if c != '-' && (c < '0' || c > '9') {
+			d.error(errPhase)
+		}
+		n, err := d.convertNumber(string(item))
+		if err != nil {
+			d.saveError(err)
+		}
+		return n
+	}
+}
+
+func (d *decodeState) literalNode() Node {
+	start := d.off - 1
+	// Can just use the interface version since this has no children
+	node := Node{
+		Start: start,
+		Value: d.literalInterface(),
+	}
+	node.End = d.off
+	return node
+}
+
+// getu4 decodes \uXXXX from the beginning of s, returning the hex value,
+// or it returns -1.
+func getu4(s []byte) rune {
+	if len(s) < 6 || s[0] != '\\' || s[1] != 'u' {
+		return -1
+	}
+	r, err := strconv.ParseUint(string(s[2:6]), 16, 64)
+	if err != nil {
+		return -1
+	}
+	return rune(r)
+}
+
+// unquote converts a quoted JSON string literal s into an actual string t.
+// The rules are different than for Go, so cannot use strconv.Unquote.
+func unquote(s []byte) (t string, ok bool) {
+	s, ok = unquoteBytes(s)
+	t = string(s)
+	return
+}
+
+func unquoteBytes(s []byte) (t []byte, ok bool) {
+	if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
+		return
+	}
+	s = s[1 : len(s)-1]
+
+	// Check for unusual characters. If there are none,
+	// then no unquoting is needed, so return a slice of the
+	// original bytes.
+	r := 0
+	for r < len(s) {
+		c := s[r]
+		if c == '\\' || c == '"' || c < ' ' {
+			break
+		}
+		if c < utf8.RuneSelf {
+			r++
+			continue
+		}
+		rr, size := utf8.DecodeRune(s[r:])
+		if rr == utf8.RuneError && size == 1 {
+			break
+		}
+		r += size
+	}
+	if r == len(s) {
+		return s, true
+	}
+
+	b := make([]byte, len(s)+2*utf8.UTFMax)
+	w := copy(b, s[0:r])
+	for r < len(s) {
+		// Out of room?  Can only happen if s is full of
+		// malformed UTF-8 and we're replacing each
+		// byte with RuneError.
+		if w >= len(b)-2*utf8.UTFMax {
+			nb := make([]byte, (len(b)+utf8.UTFMax)*2)
+			copy(nb, b[0:w])
+			b = nb
+		}
+		switch c := s[r]; {
+		case c == '\\':
+			r++
+			if r >= len(s) {
+				return
+			}
+			switch s[r] {
+			default:
+				return
+			case '"', '\\', '/', '\'':
+				b[w] = s[r]
+				r++
+				w++
+			case 'b':
+				b[w] = '\b'
+				r++
+				w++
+			case 'f':
+				b[w] = '\f'
+				r++
+				w++
+			case 'n':
+				b[w] = '\n'
+				r++
+				w++
+			case 'r':
+				b[w] = '\r'
+				r++
+				w++
+			case 't':
+				b[w] = '\t'
+				r++
+				w++
+			case 'u':
+				r--
+				rr := getu4(s[r:])
+				if rr < 0 {
+					return
+				}
+				r += 6
+				if utf16.IsSurrogate(rr) {
+					rr1 := getu4(s[r:])
+					if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
+						// A valid pair; consume.
+						r += 6
+						w += utf8.EncodeRune(b[w:], dec)
+						break
+					}
+					// Invalid surrogate; fall back to replacement rune.
+					rr = unicode.ReplacementChar
+				}
+				w += utf8.EncodeRune(b[w:], rr)
+			}
+
+		// Quote, control characters are invalid.
+		case c == '"', c < ' ':
+			return
+
+		// ASCII
+		case c < utf8.RuneSelf:
+			b[w] = c
+			r++
+			w++
+
+		// Coerce to well-formed UTF-8.
+		default:
+			rr, size := utf8.DecodeRune(s[r:])
+			r += size
+			w += utf8.EncodeRune(b[w:], rr)
+		}
+	}
+	return b[0:w], true
+}
diff --git a/vendor/github.com/ajeddeloh/go-json/encode.go b/vendor/github.com/ajeddeloh/go-json/encode.go
new file mode 100644
index 00000000..90782deb
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/encode.go
@@ -0,0 +1,1194 @@
+// Copyright 2010 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package json implements encoding and decoding of JSON objects as defined in
+// RFC 4627. The mapping between JSON objects and Go values is described
+// in the documentation for the Marshal and Unmarshal functions.
+//
+// See "JSON and Go" for an introduction to this package:
+// https://golang.org/doc/articles/json_and_go.html
+package json
+
+import (
+	"bytes"
+	"encoding"
+	"encoding/base64"
+	"math"
+	"reflect"
+	"runtime"
+	"sort"
+	"strconv"
+	"strings"
+	"sync"
+	"unicode"
+	"unicode/utf8"
+)
+
+// Marshal returns the JSON encoding of v.
+//
+// Marshal traverses the value v recursively.
+// If an encountered value implements the Marshaler interface
+// and is not a nil pointer, Marshal calls its MarshalJSON method
+// to produce JSON.  The nil pointer exception is not strictly necessary
+// but mimics a similar, necessary exception in the behavior of
+// UnmarshalJSON.
+//
+// Otherwise, Marshal uses the following type-dependent default encodings:
+//
+// Boolean values encode as JSON booleans.
+//
+// Floating point, integer, and Number values encode as JSON numbers.
+//
+// String values encode as JSON strings coerced to valid UTF-8,
+// replacing invalid bytes with the Unicode replacement rune.
+// The angle brackets "<" and ">" are escaped to "\u003c" and "\u003e"
+// to keep some browsers from misinterpreting JSON output as HTML.
+// Ampersand "&" is also escaped to "\u0026" for the same reason.
+//
+// Array and slice values encode as JSON arrays, except that
+// []byte encodes as a base64-encoded string, and a nil slice
+// encodes as the null JSON object.
+//
+// Struct values encode as JSON objects. Each exported struct field
+// becomes a member of the object unless
+//   - the field's tag is "-", or
+//   - the field is empty and its tag specifies the "omitempty" option.
+// The empty values are false, 0, any
+// nil pointer or interface value, and any array, slice, map, or string of
+// length zero. The object's default key string is the struct field name
+// but can be specified in the struct field's tag value. The "json" key in
+// the struct field's tag value is the key name, followed by an optional comma
+// and options. Examples:
+//
+//   // Field is ignored by this package.
+//   Field int `json:"-"`
+//
+//   // Field appears in JSON as key "myName".
+//   Field int `json:"myName"`
+//
+//   // Field appears in JSON as key "myName" and
+//   // the field is omitted from the object if its value is empty,
+//   // as defined above.
+//   Field int `json:"myName,omitempty"`
+//
+//   // Field appears in JSON as key "Field" (the default), but
+//   // the field is skipped if empty.
+//   // Note the leading comma.
+//   Field int `json:",omitempty"`
+//
+// The "string" option signals that a field is stored as JSON inside a
+// JSON-encoded string. It applies only to fields of string, floating point,
+// integer, or boolean types. This extra level of encoding is sometimes used
+// when communicating with JavaScript programs:
+//
+//    Int64String int64 `json:",string"`
+//
+// The key name will be used if it's a non-empty string consisting of
+// only Unicode letters, digits, dollar signs, percent signs, hyphens,
+// underscores and slashes.
+//
+// Anonymous struct fields are usually marshaled as if their inner exported fields
+// were fields in the outer struct, subject to the usual Go visibility rules amended
+// as described in the next paragraph.
+// An anonymous struct field with a name given in its JSON tag is treated as
+// having that name, rather than being anonymous.
+// An anonymous struct field of interface type is treated the same as having
+// that type as its name, rather than being anonymous.
+//
+// The Go visibility rules for struct fields are amended for JSON when
+// deciding which field to marshal or unmarshal. If there are
+// multiple fields at the same level, and that level is the least
+// nested (and would therefore be the nesting level selected by the
+// usual Go rules), the following extra rules apply:
+//
+// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
+// even if there are multiple untagged fields that would otherwise conflict.
+// 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
+// 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
+//
+// Handling of anonymous struct fields is new in Go 1.1.
+// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
+// an anonymous struct field in both current and earlier versions, give the field
+// a JSON tag of "-".
+//
+// Map values encode as JSON objects.
+// The map's key type must be string; the map keys are used as JSON object
+// keys, subject to the UTF-8 coercion described for string values above.
+//
+// Pointer values encode as the value pointed to.
+// A nil pointer encodes as the null JSON object.
+//
+// Interface values encode as the value contained in the interface.
+// A nil interface value encodes as the null JSON object.
+//
+// Channel, complex, and function values cannot be encoded in JSON.
+// Attempting to encode such a value causes Marshal to return
+// an UnsupportedTypeError.
+//
+// JSON cannot represent cyclic data structures and Marshal does not
+// handle them.  Passing cyclic structures to Marshal will result in
+// an infinite recursion.
+//
+func Marshal(v interface{}) ([]byte, error) {
+	e := &encodeState{}
+	err := e.marshal(v)
+	if err != nil {
+		return nil, err
+	}
+	return e.Bytes(), nil
+}
+
+// MarshalIndent is like Marshal but applies Indent to format the output.
+func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {
+	b, err := Marshal(v)
+	if err != nil {
+		return nil, err
+	}
+	var buf bytes.Buffer
+	err = Indent(&buf, b, prefix, indent)
+	if err != nil {
+		return nil, err
+	}
+	return buf.Bytes(), nil
+}
+
+// HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
+// characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
+// so that the JSON will be safe to embed inside HTML <script> tags.
+// For historical reasons, web browsers don't honor standard HTML
+// escaping within <script> tags, so an alternative JSON encoding must
+// be used.
+func HTMLEscape(dst *bytes.Buffer, src []byte) {
+	// The characters can only appear in string literals,
+	// so just scan the string one byte at a time.
+	start := 0
+	for i, c := range src {
+		if c == '<' || c == '>' || c == '&' {
+			if start < i {
+				dst.Write(src[start:i])
+			}
+			dst.WriteString(`\u00`)
+			dst.WriteByte(hex[c>>4])
+			dst.WriteByte(hex[c&0xF])
+			start = i + 1
+		}
+		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
+		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
+			if start < i {
+				dst.Write(src[start:i])
+			}
+			dst.WriteString(`\u202`)
+			dst.WriteByte(hex[src[i+2]&0xF])
+			start = i + 3
+		}
+	}
+	if start < len(src) {
+		dst.Write(src[start:])
+	}
+}
+
+// Marshaler is the interface implemented by objects that
+// can marshal themselves into valid JSON.
+type Marshaler interface {
+	MarshalJSON() ([]byte, error)
+}
+
+// An UnsupportedTypeError is returned by Marshal when attempting
+// to encode an unsupported value type.
+type UnsupportedTypeError struct {
+	Type reflect.Type
+}
+
+func (e *UnsupportedTypeError) Error() string {
+	return "json: unsupported type: " + e.Type.String()
+}
+
+type UnsupportedValueError struct {
+	Value reflect.Value
+	Str   string
+}
+
+func (e *UnsupportedValueError) Error() string {
+	return "json: unsupported value: " + e.Str
+}
+
+// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when
+// attempting to encode a string value with invalid UTF-8 sequences.
+// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by
+// replacing invalid bytes with the Unicode replacement rune U+FFFD.
+// This error is no longer generated but is kept for backwards compatibility
+// with programs that might mention it.
+type InvalidUTF8Error struct {
+	S string // the whole string value that caused the error
+}
+
+func (e *InvalidUTF8Error) Error() string {
+	return "json: invalid UTF-8 in string: " + strconv.Quote(e.S)
+}
+
+type MarshalerError struct {
+	Type reflect.Type
+	Err  error
+}
+
+func (e *MarshalerError) Error() string {
+	return "json: error calling MarshalJSON for type " + e.Type.String() + ": " + e.Err.Error()
+}
+
+var hex = "0123456789abcdef"
+
+// An encodeState encodes JSON into a bytes.Buffer.
+type encodeState struct {
+	bytes.Buffer // accumulated output
+	scratch      [64]byte
+}
+
+var encodeStatePool sync.Pool
+
+func newEncodeState() *encodeState {
+	if v := encodeStatePool.Get(); v != nil {
+		e := v.(*encodeState)
+		e.Reset()
+		return e
+	}
+	return new(encodeState)
+}
+
+func (e *encodeState) marshal(v interface{}) (err error) {
+	defer func() {
+		if r := recover(); r != nil {
+			if _, ok := r.(runtime.Error); ok {
+				panic(r)
+			}
+			if s, ok := r.(string); ok {
+				panic(s)
+			}
+			err = r.(error)
+		}
+	}()
+	e.reflectValue(reflect.ValueOf(v))
+	return nil
+}
+
+func (e *encodeState) error(err error) {
+	panic(err)
+}
+
+func isEmptyValue(v reflect.Value) bool {
+	switch v.Kind() {
+	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
+		return v.Len() == 0
+	case reflect.Bool:
+		return !v.Bool()
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		return v.Int() == 0
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
+		return v.Uint() == 0
+	case reflect.Float32, reflect.Float64:
+		return v.Float() == 0
+	case reflect.Interface, reflect.Ptr:
+		return v.IsNil()
+	}
+	return false
+}
+
+func (e *encodeState) reflectValue(v reflect.Value) {
+	valueEncoder(v)(e, v, false)
+}
+
+type encoderFunc func(e *encodeState, v reflect.Value, quoted bool)
+
+var encoderCache struct {
+	sync.RWMutex
+	m map[reflect.Type]encoderFunc
+}
+
+func valueEncoder(v reflect.Value) encoderFunc {
+	if !v.IsValid() {
+		return invalidValueEncoder
+	}
+	return typeEncoder(v.Type())
+}
+
+func typeEncoder(t reflect.Type) encoderFunc {
+	encoderCache.RLock()
+	f := encoderCache.m[t]
+	encoderCache.RUnlock()
+	if f != nil {
+		return f
+	}
+
+	// To deal with recursive types, populate the map with an
+	// indirect func before we build it. This type waits on the
+	// real func (f) to be ready and then calls it.  This indirect
+	// func is only used for recursive types.
+	encoderCache.Lock()
+	if encoderCache.m == nil {
+		encoderCache.m = make(map[reflect.Type]encoderFunc)
+	}
+	var wg sync.WaitGroup
+	wg.Add(1)
+	encoderCache.m[t] = func(e *encodeState, v reflect.Value, quoted bool) {
+		wg.Wait()
+		f(e, v, quoted)
+	}
+	encoderCache.Unlock()
+
+	// Compute fields without lock.
+	// Might duplicate effort but won't hold other computations back.
+	f = newTypeEncoder(t, true)
+	wg.Done()
+	encoderCache.Lock()
+	encoderCache.m[t] = f
+	encoderCache.Unlock()
+	return f
+}
+
+var (
+	marshalerType     = reflect.TypeOf(new(Marshaler)).Elem()
+	textMarshalerType = reflect.TypeOf(new(encoding.TextMarshaler)).Elem()
+)
+
+// newTypeEncoder constructs an encoderFunc for a type.
+// The returned encoder only checks CanAddr when allowAddr is true.
+func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
+	if t.Implements(marshalerType) {
+		return marshalerEncoder
+	}
+	if t.Kind() != reflect.Ptr && allowAddr {
+		if reflect.PtrTo(t).Implements(marshalerType) {
+			return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
+		}
+	}
+
+	if t.Implements(textMarshalerType) {
+		return textMarshalerEncoder
+	}
+	if t.Kind() != reflect.Ptr && allowAddr {
+		if reflect.PtrTo(t).Implements(textMarshalerType) {
+			return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))
+		}
+	}
+
+	switch t.Kind() {
+	case reflect.Bool:
+		return boolEncoder
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		return intEncoder
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
+		return uintEncoder
+	case reflect.Float32:
+		return float32Encoder
+	case reflect.Float64:
+		return float64Encoder
+	case reflect.String:
+		return stringEncoder
+	case reflect.Interface:
+		return interfaceEncoder
+	case reflect.Struct:
+		return newStructEncoder(t)
+	case reflect.Map:
+		return newMapEncoder(t)
+	case reflect.Slice:
+		return newSliceEncoder(t)
+	case reflect.Array:
+		return newArrayEncoder(t)
+	case reflect.Ptr:
+		return newPtrEncoder(t)
+	default:
+		return unsupportedTypeEncoder
+	}
+}
+
+func invalidValueEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	e.WriteString("null")
+}
+
+func marshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	if v.Kind() == reflect.Ptr && v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	m := v.Interface().(Marshaler)
+	b, err := m.MarshalJSON()
+	if err == nil {
+		// copy JSON into buffer, checking validity.
+		err = compact(&e.Buffer, b, true)
+	}
+	if err != nil {
+		e.error(&MarshalerError{v.Type(), err})
+	}
+}
+
+func addrMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	va := v.Addr()
+	if va.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	m := va.Interface().(Marshaler)
+	b, err := m.MarshalJSON()
+	if err == nil {
+		// copy JSON into buffer, checking validity.
+		err = compact(&e.Buffer, b, true)
+	}
+	if err != nil {
+		e.error(&MarshalerError{v.Type(), err})
+	}
+}
+
+func textMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	if v.Kind() == reflect.Ptr && v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	m := v.Interface().(encoding.TextMarshaler)
+	b, err := m.MarshalText()
+	if err == nil {
+		_, err = e.stringBytes(b)
+	}
+	if err != nil {
+		e.error(&MarshalerError{v.Type(), err})
+	}
+}
+
+func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	va := v.Addr()
+	if va.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	m := va.Interface().(encoding.TextMarshaler)
+	b, err := m.MarshalText()
+	if err == nil {
+		_, err = e.stringBytes(b)
+	}
+	if err != nil {
+		e.error(&MarshalerError{v.Type(), err})
+	}
+}
+
+func boolEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	if quoted {
+		e.WriteByte('"')
+	}
+	if v.Bool() {
+		e.WriteString("true")
+	} else {
+		e.WriteString("false")
+	}
+	if quoted {
+		e.WriteByte('"')
+	}
+}
+
+func intEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
+	if quoted {
+		e.WriteByte('"')
+	}
+	e.Write(b)
+	if quoted {
+		e.WriteByte('"')
+	}
+}
+
+func uintEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
+	if quoted {
+		e.WriteByte('"')
+	}
+	e.Write(b)
+	if quoted {
+		e.WriteByte('"')
+	}
+}
+
+type floatEncoder int // number of bits
+
+func (bits floatEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
+	f := v.Float()
+	if math.IsInf(f, 0) || math.IsNaN(f) {
+		e.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})
+	}
+	b := strconv.AppendFloat(e.scratch[:0], f, 'g', -1, int(bits))
+	if quoted {
+		e.WriteByte('"')
+	}
+	e.Write(b)
+	if quoted {
+		e.WriteByte('"')
+	}
+}
+
+var (
+	float32Encoder = (floatEncoder(32)).encode
+	float64Encoder = (floatEncoder(64)).encode
+)
+
+func stringEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	if v.Type() == numberType {
+		numStr := v.String()
+		if numStr == "" {
+			numStr = "0" // Number's zero-val
+		}
+		e.WriteString(numStr)
+		return
+	}
+	if quoted {
+		sb, err := Marshal(v.String())
+		if err != nil {
+			e.error(err)
+		}
+		e.string(string(sb))
+	} else {
+		e.string(v.String())
+	}
+}
+
+func interfaceEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	if v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	e.reflectValue(v.Elem())
+}
+
+func unsupportedTypeEncoder(e *encodeState, v reflect.Value, quoted bool) {
+	e.error(&UnsupportedTypeError{v.Type()})
+}
+
+type structEncoder struct {
+	fields    []field
+	fieldEncs []encoderFunc
+}
+
+func (se *structEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
+	e.WriteByte('{')
+	first := true
+	for i, f := range se.fields {
+		fv := fieldByIndex(v, f.index)
+		if !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {
+			continue
+		}
+		if first {
+			first = false
+		} else {
+			e.WriteByte(',')
+		}
+		e.string(f.name)
+		e.WriteByte(':')
+		se.fieldEncs[i](e, fv, f.quoted)
+	}
+	e.WriteByte('}')
+}
+
+func newStructEncoder(t reflect.Type) encoderFunc {
+	fields := cachedTypeFields(t)
+	se := &structEncoder{
+		fields:    fields,
+		fieldEncs: make([]encoderFunc, len(fields)),
+	}
+	for i, f := range fields {
+		se.fieldEncs[i] = typeEncoder(typeByIndex(t, f.index))
+	}
+	return se.encode
+}
+
+type mapEncoder struct {
+	elemEnc encoderFunc
+}
+
+func (me *mapEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
+	if v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	e.WriteByte('{')
+	var sv stringValues = v.MapKeys()
+	sort.Sort(sv)
+	for i, k := range sv {
+		if i > 0 {
+			e.WriteByte(',')
+		}
+		e.string(k.String())
+		e.WriteByte(':')
+		me.elemEnc(e, v.MapIndex(k), false)
+	}
+	e.WriteByte('}')
+}
+
+func newMapEncoder(t reflect.Type) encoderFunc {
+	if t.Key().Kind() != reflect.String {
+		return unsupportedTypeEncoder
+	}
+	me := &mapEncoder{typeEncoder(t.Elem())}
+	return me.encode
+}
+
+func encodeByteSlice(e *encodeState, v reflect.Value, _ bool) {
+	if v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	s := v.Bytes()
+	e.WriteByte('"')
+	if len(s) < 1024 {
+		// for small buffers, using Encode directly is much faster.
+		dst := make([]byte, base64.StdEncoding.EncodedLen(len(s)))
+		base64.StdEncoding.Encode(dst, s)
+		e.Write(dst)
+	} else {
+		// for large buffers, avoid unnecessary extra temporary
+		// buffer space.
+		enc := base64.NewEncoder(base64.StdEncoding, e)
+		enc.Write(s)
+		enc.Close()
+	}
+	e.WriteByte('"')
+}
+
+// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.
+type sliceEncoder struct {
+	arrayEnc encoderFunc
+}
+
+func (se *sliceEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
+	if v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	se.arrayEnc(e, v, false)
+}
+
+func newSliceEncoder(t reflect.Type) encoderFunc {
+	// Byte slices get special treatment; arrays don't.
+	if t.Elem().Kind() == reflect.Uint8 {
+		return encodeByteSlice
+	}
+	enc := &sliceEncoder{newArrayEncoder(t)}
+	return enc.encode
+}
+
+type arrayEncoder struct {
+	elemEnc encoderFunc
+}
+
+func (ae *arrayEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
+	e.WriteByte('[')
+	n := v.Len()
+	for i := 0; i < n; i++ {
+		if i > 0 {
+			e.WriteByte(',')
+		}
+		ae.elemEnc(e, v.Index(i), false)
+	}
+	e.WriteByte(']')
+}
+
+func newArrayEncoder(t reflect.Type) encoderFunc {
+	enc := &arrayEncoder{typeEncoder(t.Elem())}
+	return enc.encode
+}
+
+type ptrEncoder struct {
+	elemEnc encoderFunc
+}
+
+func (pe *ptrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
+	if v.IsNil() {
+		e.WriteString("null")
+		return
+	}
+	pe.elemEnc(e, v.Elem(), quoted)
+}
+
+func newPtrEncoder(t reflect.Type) encoderFunc {
+	enc := &ptrEncoder{typeEncoder(t.Elem())}
+	return enc.encode
+}
+
+type condAddrEncoder struct {
+	canAddrEnc, elseEnc encoderFunc
+}
+
+func (ce *condAddrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
+	if v.CanAddr() {
+		ce.canAddrEnc(e, v, quoted)
+	} else {
+		ce.elseEnc(e, v, quoted)
+	}
+}
+
+// newCondAddrEncoder returns an encoder that checks whether its value
+// CanAddr and delegates to canAddrEnc if so, else to elseEnc.
+func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {
+	enc := &condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}
+	return enc.encode
+}
+
+func isValidTag(s string) bool {
+	if s == "" {
+		return false
+	}
+	for _, c := range s {
+		switch {
+		case strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c):
+			// Backslash and quote chars are reserved, but
+			// otherwise any punctuation chars are allowed
+			// in a tag name.
+		default:
+			if !unicode.IsLetter(c) && !unicode.IsDigit(c) {
+				return false
+			}
+		}
+	}
+	return true
+}
+
+func fieldByIndex(v reflect.Value, index []int) reflect.Value {
+	for _, i := range index {
+		if v.Kind() == reflect.Ptr {
+			if v.IsNil() {
+				return reflect.Value{}
+			}
+			v = v.Elem()
+		}
+		v = v.Field(i)
+	}
+	return v
+}
+
+func typeByIndex(t reflect.Type, index []int) reflect.Type {
+	for _, i := range index {
+		if t.Kind() == reflect.Ptr {
+			t = t.Elem()
+		}
+		t = t.Field(i).Type
+	}
+	return t
+}
+
+// stringValues is a slice of reflect.Value holding *reflect.StringValue.
+// It implements the methods to sort by string.
+type stringValues []reflect.Value
+
+func (sv stringValues) Len() int           { return len(sv) }
+func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }
+func (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }
+func (sv stringValues) get(i int) string   { return sv[i].String() }
+
+// NOTE: keep in sync with stringBytes below.
+func (e *encodeState) string(s string) (int, error) {
+	len0 := e.Len()
+	e.WriteByte('"')
+	start := 0
+	for i := 0; i < len(s); {
+		if b := s[i]; b < utf8.RuneSelf {
+			if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
+				i++
+				continue
+			}
+			if start < i {
+				e.WriteString(s[start:i])
+			}
+			switch b {
+			case '\\', '"':
+				e.WriteByte('\\')
+				e.WriteByte(b)
+			case '\n':
+				e.WriteByte('\\')
+				e.WriteByte('n')
+			case '\r':
+				e.WriteByte('\\')
+				e.WriteByte('r')
+			case '\t':
+				e.WriteByte('\\')
+				e.WriteByte('t')
+			default:
+				// This encodes bytes < 0x20 except for \n and \r,
+				// as well as <, > and &. The latter are escaped because they
+				// can lead to security holes when user-controlled strings
+				// are rendered into JSON and served to some browsers.
+				e.WriteString(`\u00`)
+				e.WriteByte(hex[b>>4])
+				e.WriteByte(hex[b&0xF])
+			}
+			i++
+			start = i
+			continue
+		}
+		c, size := utf8.DecodeRuneInString(s[i:])
+		if c == utf8.RuneError && size == 1 {
+			if start < i {
+				e.WriteString(s[start:i])
+			}
+			e.WriteString(`\ufffd`)
+			i += size
+			start = i
+			continue
+		}
+		// U+2028 is LINE SEPARATOR.
+		// U+2029 is PARAGRAPH SEPARATOR.
+		// They are both technically valid characters in JSON strings,
+		// but don't work in JSONP, which has to be evaluated as JavaScript,
+		// and can lead to security holes there. It is valid JSON to
+		// escape them, so we do so unconditionally.
+		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
+		if c == '\u2028' || c == '\u2029' {
+			if start < i {
+				e.WriteString(s[start:i])
+			}
+			e.WriteString(`\u202`)
+			e.WriteByte(hex[c&0xF])
+			i += size
+			start = i
+			continue
+		}
+		i += size
+	}
+	if start < len(s) {
+		e.WriteString(s[start:])
+	}
+	e.WriteByte('"')
+	return e.Len() - len0, nil
+}
+
+// NOTE: keep in sync with string above.
+func (e *encodeState) stringBytes(s []byte) (int, error) {
+	len0 := e.Len()
+	e.WriteByte('"')
+	start := 0
+	for i := 0; i < len(s); {
+		if b := s[i]; b < utf8.RuneSelf {
+			if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
+				i++
+				continue
+			}
+			if start < i {
+				e.Write(s[start:i])
+			}
+			switch b {
+			case '\\', '"':
+				e.WriteByte('\\')
+				e.WriteByte(b)
+			case '\n':
+				e.WriteByte('\\')
+				e.WriteByte('n')
+			case '\r':
+				e.WriteByte('\\')
+				e.WriteByte('r')
+			case '\t':
+				e.WriteByte('\\')
+				e.WriteByte('t')
+			default:
+				// This encodes bytes < 0x20 except for \n and \r,
+				// as well as <, >, and &. The latter are escaped because they
+				// can lead to security holes when user-controlled strings
+				// are rendered into JSON and served to some browsers.
+				e.WriteString(`\u00`)
+				e.WriteByte(hex[b>>4])
+				e.WriteByte(hex[b&0xF])
+			}
+			i++
+			start = i
+			continue
+		}
+		c, size := utf8.DecodeRune(s[i:])
+		if c == utf8.RuneError && size == 1 {
+			if start < i {
+				e.Write(s[start:i])
+			}
+			e.WriteString(`\ufffd`)
+			i += size
+			start = i
+			continue
+		}
+		// U+2028 is LINE SEPARATOR.
+		// U+2029 is PARAGRAPH SEPARATOR.
+		// They are both technically valid characters in JSON strings,
+		// but don't work in JSONP, which has to be evaluated as JavaScript,
+		// and can lead to security holes there. It is valid JSON to
+		// escape them, so we do so unconditionally.
+		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
+		if c == '\u2028' || c == '\u2029' {
+			if start < i {
+				e.Write(s[start:i])
+			}
+			e.WriteString(`\u202`)
+			e.WriteByte(hex[c&0xF])
+			i += size
+			start = i
+			continue
+		}
+		i += size
+	}
+	if start < len(s) {
+		e.Write(s[start:])
+	}
+	e.WriteByte('"')
+	return e.Len() - len0, nil
+}
+
+// A field represents a single field found in a struct.
+type field struct {
+	name      string
+	nameBytes []byte                 // []byte(name)
+	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent
+
+	tag       bool
+	index     []int
+	typ       reflect.Type
+	omitEmpty bool
+	quoted    bool
+}
+
+func fillField(f field) field {
+	f.nameBytes = []byte(f.name)
+	f.equalFold = foldFunc(f.nameBytes)
+	return f
+}
+
+// byName sorts field by name, breaking ties with depth,
+// then breaking ties with "name came from json tag", then
+// breaking ties with index sequence.
+type byName []field
+
+func (x byName) Len() int { return len(x) }
+
+func (x byName) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
+
+func (x byName) Less(i, j int) bool {
+	if x[i].name != x[j].name {
+		return x[i].name < x[j].name
+	}
+	if len(x[i].index) != len(x[j].index) {
+		return len(x[i].index) < len(x[j].index)
+	}
+	if x[i].tag != x[j].tag {
+		return x[i].tag
+	}
+	return byIndex(x).Less(i, j)
+}
+
+// byIndex sorts field by index sequence.
+type byIndex []field
+
+func (x byIndex) Len() int { return len(x) }
+
+func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
+
+func (x byIndex) Less(i, j int) bool {
+	for k, xik := range x[i].index {
+		if k >= len(x[j].index) {
+			return false
+		}
+		if xik != x[j].index[k] {
+			return xik < x[j].index[k]
+		}
+	}
+	return len(x[i].index) < len(x[j].index)
+}
+
+// typeFields returns a list of fields that JSON should recognize for the given type.
+// The algorithm is breadth-first search over the set of structs to include - the top struct
+// and then any reachable anonymous structs.
+func typeFields(t reflect.Type) []field {
+	// Anonymous fields to explore at the current level and the next.
+	current := []field{}
+	next := []field{{typ: t}}
+
+	// Count of queued names for current level and the next.
+	count := map[reflect.Type]int{}
+	nextCount := map[reflect.Type]int{}
+
+	// Types already visited at an earlier level.
+	visited := map[reflect.Type]bool{}
+
+	// Fields found.
+	var fields []field
+
+	for len(next) > 0 {
+		current, next = next, current[:0]
+		count, nextCount = nextCount, map[reflect.Type]int{}
+
+		for _, f := range current {
+			if visited[f.typ] {
+				continue
+			}
+			visited[f.typ] = true
+
+			// Scan f.typ for fields to include.
+			for i := 0; i < f.typ.NumField(); i++ {
+				sf := f.typ.Field(i)
+				if sf.PkgPath != "" { // unexported
+					continue
+				}
+				tag := sf.Tag.Get("json")
+				if tag == "-" {
+					continue
+				}
+				name, opts := parseTag(tag)
+				if !isValidTag(name) {
+					name = ""
+				}
+				index := make([]int, len(f.index)+1)
+				copy(index, f.index)
+				index[len(f.index)] = i
+
+				ft := sf.Type
+				if ft.Name() == "" && ft.Kind() == reflect.Ptr {
+					// Follow pointer.
+					ft = ft.Elem()
+				}
+
+				// Only strings, floats, integers, and booleans can be quoted.
+				quoted := false
+				if opts.Contains("string") {
+					switch ft.Kind() {
+					case reflect.Bool,
+						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
+						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
+						reflect.Float32, reflect.Float64,
+						reflect.String:
+						quoted = true
+					}
+				}
+
+				// Record found field and index sequence.
+				if name != "" || !sf.Anonymous || ft.Kind() != reflect.Struct {
+					tagged := name != ""
+					if name == "" {
+						name = sf.Name
+					}
+					fields = append(fields, fillField(field{
+						name:      name,
+						tag:       tagged,
+						index:     index,
+						typ:       ft,
+						omitEmpty: opts.Contains("omitempty"),
+						quoted:    quoted,
+					}))
+					if count[f.typ] > 1 {
+						// If there were multiple instances, add a second,
+						// so that the annihilation code will see a duplicate.
+						// It only cares about the distinction between 1 or 2,
+						// so don't bother generating any more copies.
+						fields = append(fields, fields[len(fields)-1])
+					}
+					continue
+				}
+
+				// Record new anonymous struct to explore in next round.
+				nextCount[ft]++
+				if nextCount[ft] == 1 {
+					next = append(next, fillField(field{name: ft.Name(), index: index, typ: ft}))
+				}
+			}
+		}
+	}
+
+	sort.Sort(byName(fields))
+
+	// Delete all fields that are hidden by the Go rules for embedded fields,
+	// except that fields with JSON tags are promoted.
+
+	// The fields are sorted in primary order of name, secondary order
+	// of field index length. Loop over names; for each name, delete
+	// hidden fields by choosing the one dominant field that survives.
+	out := fields[:0]
+	for advance, i := 0, 0; i < len(fields); i += advance {
+		// One iteration per name.
+		// Find the sequence of fields with the name of this first field.
+		fi := fields[i]
+		name := fi.name
+		for advance = 1; i+advance < len(fields); advance++ {
+			fj := fields[i+advance]
+			if fj.name != name {
+				break
+			}
+		}
+		if advance == 1 { // Only one field with this name
+			out = append(out, fi)
+			continue
+		}
+		dominant, ok := dominantField(fields[i : i+advance])
+		if ok {
+			out = append(out, dominant)
+		}
+	}
+
+	fields = out
+	sort.Sort(byIndex(fields))
+
+	return fields
+}
+
+// dominantField looks through the fields, all of which are known to
+// have the same name, to find the single field that dominates the
+// others using Go's embedding rules, modified by the presence of
+// JSON tags. If there are multiple top-level fields, the boolean
+// will be false: This condition is an error in Go and we skip all
+// the fields.
+func dominantField(fields []field) (field, bool) {
+	// The fields are sorted in increasing index-length order. The winner
+	// must therefore be one with the shortest index length. Drop all
+	// longer entries, which is easy: just truncate the slice.
+	length := len(fields[0].index)
+	tagged := -1 // Index of first tagged field.
+	for i, f := range fields {
+		if len(f.index) > length {
+			fields = fields[:i]
+			break
+		}
+		if f.tag {
+			if tagged >= 0 {
+				// Multiple tagged fields at the same level: conflict.
+				// Return no field.
+				return field{}, false
+			}
+			tagged = i
+		}
+	}
+	if tagged >= 0 {
+		return fields[tagged], true
+	}
+	// All remaining fields have the same length. If there's more than one,
+	// we have a conflict (two fields named "X" at the same level) and we
+	// return no field.
+	if len(fields) > 1 {
+		return field{}, false
+	}
+	return fields[0], true
+}
+
+var fieldCache struct {
+	sync.RWMutex
+	m map[reflect.Type][]field
+}
+
+// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
+func cachedTypeFields(t reflect.Type) []field {
+	fieldCache.RLock()
+	f := fieldCache.m[t]
+	fieldCache.RUnlock()
+	if f != nil {
+		return f
+	}
+
+	// Compute fields without lock.
+	// Might duplicate effort but won't hold other computations back.
+	f = typeFields(t)
+	if f == nil {
+		f = []field{}
+	}
+
+	fieldCache.Lock()
+	if fieldCache.m == nil {
+		fieldCache.m = map[reflect.Type][]field{}
+	}
+	fieldCache.m[t] = f
+	fieldCache.Unlock()
+	return f
+}
diff --git a/vendor/github.com/ajeddeloh/go-json/fold.go b/vendor/github.com/ajeddeloh/go-json/fold.go
new file mode 100644
index 00000000..9e170127
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/fold.go
@@ -0,0 +1,143 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package json
+
+import (
+	"bytes"
+	"unicode/utf8"
+)
+
+const (
+	caseMask     = ^byte(0x20) // Mask to ignore case in ASCII.
+	kelvin       = '\u212a'
+	smallLongEss = '\u017f'
+)
+
+// foldFunc returns one of four different case folding equivalence
+// functions, from most general (and slow) to fastest:
+//
+// 1) bytes.EqualFold, if the key s contains any non-ASCII UTF-8
+// 2) equalFoldRight, if s contains special folding ASCII ('k', 'K', 's', 'S')
+// 3) asciiEqualFold, no special, but includes non-letters (including _)
+// 4) simpleLetterEqualFold, no specials, no non-letters.
+//
+// The letters S and K are special because they map to 3 runes, not just 2:
+//  * S maps to s and to U+017F 'ſ' Latin small letter long s
+//  * k maps to K and to U+212A 'K' Kelvin sign
+// See https://play.golang.org/p/tTxjOc0OGo
+//
+// The returned function is specialized for matching against s and
+// should only be given s. It's not curried for performance reasons.
+func foldFunc(s []byte) func(s, t []byte) bool {
+	nonLetter := false
+	special := false // special letter
+	for _, b := range s {
+		if b >= utf8.RuneSelf {
+			return bytes.EqualFold
+		}
+		upper := b & caseMask
+		if upper < 'A' || upper > 'Z' {
+			nonLetter = true
+		} else if upper == 'K' || upper == 'S' {
+			// See above for why these letters are special.
+			special = true
+		}
+	}
+	if special {
+		return equalFoldRight
+	}
+	if nonLetter {
+		return asciiEqualFold
+	}
+	return simpleLetterEqualFold
+}
+
+// equalFoldRight is a specialization of bytes.EqualFold when s is
+// known to be all ASCII (including punctuation), but contains an 's',
+// 'S', 'k', or 'K', requiring a Unicode fold on the bytes in t.
+// See comments on foldFunc.
+func equalFoldRight(s, t []byte) bool {
+	for _, sb := range s {
+		if len(t) == 0 {
+			return false
+		}
+		tb := t[0]
+		if tb < utf8.RuneSelf {
+			if sb != tb {
+				sbUpper := sb & caseMask
+				if 'A' <= sbUpper && sbUpper <= 'Z' {
+					if sbUpper != tb&caseMask {
+						return false
+					}
+				} else {
+					return false
+				}
+			}
+			t = t[1:]
+			continue
+		}
+		// sb is ASCII and t is not. t must be either kelvin
+		// sign or long s; sb must be s, S, k, or K.
+		tr, size := utf8.DecodeRune(t)
+		switch sb {
+		case 's', 'S':
+			if tr != smallLongEss {
+				return false
+			}
+		case 'k', 'K':
+			if tr != kelvin {
+				return false
+			}
+		default:
+			return false
+		}
+		t = t[size:]
+
+	}
+	if len(t) > 0 {
+		return false
+	}
+	return true
+}
+
+// asciiEqualFold is a specialization of bytes.EqualFold for use when
+// s is all ASCII (but may contain non-letters) and contains no
+// special-folding letters.
+// See comments on foldFunc.
+func asciiEqualFold(s, t []byte) bool {
+	if len(s) != len(t) {
+		return false
+	}
+	for i, sb := range s {
+		tb := t[i]
+		if sb == tb {
+			continue
+		}
+		if ('a' <= sb && sb <= 'z') || ('A' <= sb && sb <= 'Z') {
+			if sb&caseMask != tb&caseMask {
+				return false
+			}
+		} else {
+			return false
+		}
+	}
+	return true
+}
+
+// simpleLetterEqualFold is a specialization of bytes.EqualFold for
+// use when s is all ASCII letters (no underscores, etc) and also
+// doesn't contain 'k', 'K', 's', or 'S'.
+// See comments on foldFunc.
+func simpleLetterEqualFold(s, t []byte) bool {
+	if len(s) != len(t) {
+		return false
+	}
+	for i, b := range s {
+		if b&caseMask != t[i]&caseMask {
+			return false
+		}
+	}
+	return true
+}
diff --git a/vendor/github.com/ajeddeloh/go-json/indent.go b/vendor/github.com/ajeddeloh/go-json/indent.go
new file mode 100644
index 00000000..e1bacafd
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/indent.go
@@ -0,0 +1,137 @@
+// Copyright 2010 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package json
+
+import "bytes"
+
+// Compact appends to dst the JSON-encoded src with
+// insignificant space characters elided.
+func Compact(dst *bytes.Buffer, src []byte) error {
+	return compact(dst, src, false)
+}
+
+func compact(dst *bytes.Buffer, src []byte, escape bool) error {
+	origLen := dst.Len()
+	var scan scanner
+	scan.reset()
+	start := 0
+	for i, c := range src {
+		if escape && (c == '<' || c == '>' || c == '&') {
+			if start < i {
+				dst.Write(src[start:i])
+			}
+			dst.WriteString(`\u00`)
+			dst.WriteByte(hex[c>>4])
+			dst.WriteByte(hex[c&0xF])
+			start = i + 1
+		}
+		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
+		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
+			if start < i {
+				dst.Write(src[start:i])
+			}
+			dst.WriteString(`\u202`)
+			dst.WriteByte(hex[src[i+2]&0xF])
+			start = i + 3
+		}
+		v := scan.step(&scan, int(c))
+		if v >= scanSkipSpace {
+			if v == scanError {
+				break
+			}
+			if start < i {
+				dst.Write(src[start:i])
+			}
+			start = i + 1
+		}
+	}
+	if scan.eof() == scanError {
+		dst.Truncate(origLen)
+		return scan.err
+	}
+	if start < len(src) {
+		dst.Write(src[start:])
+	}
+	return nil
+}
+
+func newline(dst *bytes.Buffer, prefix, indent string, depth int) {
+	dst.WriteByte('\n')
+	dst.WriteString(prefix)
+	for i := 0; i < depth; i++ {
+		dst.WriteString(indent)
+	}
+}
+
+// Indent appends to dst an indented form of the JSON-encoded src.
+// Each element in a JSON object or array begins on a new,
+// indented line beginning with prefix followed by one or more
+// copies of indent according to the indentation nesting.
+// The data appended to dst does not begin with the prefix nor
+// any indentation, and has no trailing newline, to make it
+// easier to embed inside other formatted JSON data.
+func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {
+	origLen := dst.Len()
+	var scan scanner
+	scan.reset()
+	needIndent := false
+	depth := 0
+	for _, c := range src {
+		scan.bytes++
+		v := scan.step(&scan, int(c))
+		if v == scanSkipSpace {
+			continue
+		}
+		if v == scanError {
+			break
+		}
+		if needIndent && v != scanEndObject && v != scanEndArray {
+			needIndent = false
+			depth++
+			newline(dst, prefix, indent, depth)
+		}
+
+		// Emit semantically uninteresting bytes
+		// (in particular, punctuation in strings) unmodified.
+		if v == scanContinue {
+			dst.WriteByte(c)
+			continue
+		}
+
+		// Add spacing around real punctuation.
+		switch c {
+		case '{', '[':
+			// delay indent so that empty object and array are formatted as {} and [].
+			needIndent = true
+			dst.WriteByte(c)
+
+		case ',':
+			dst.WriteByte(c)
+			newline(dst, prefix, indent, depth)
+
+		case ':':
+			dst.WriteByte(c)
+			dst.WriteByte(' ')
+
+		case '}', ']':
+			if needIndent {
+				// suppress indent in empty object/array
+				needIndent = false
+			} else {
+				depth--
+				newline(dst, prefix, indent, depth)
+			}
+			dst.WriteByte(c)
+
+		default:
+			dst.WriteByte(c)
+		}
+	}
+	if scan.eof() == scanError {
+		dst.Truncate(origLen)
+		return scan.err
+	}
+	return nil
+}
diff --git a/vendor/github.com/ajeddeloh/go-json/scanner.go b/vendor/github.com/ajeddeloh/go-json/scanner.go
new file mode 100644
index 00000000..38d0b080
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/scanner.go
@@ -0,0 +1,630 @@
+// Copyright 2010 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package json
+
+// JSON value parser state machine.
+// Just about at the limit of what is reasonable to write by hand.
+// Some parts are a bit tedious, but overall it nicely factors out the
+// otherwise common code from the multiple scanning functions
+// in this package (Compact, Indent, checkValid, nextValue, etc).
+//
+// This file starts with two simple examples using the scanner
+// before diving into the scanner itself.
+
+import "strconv"
+
+// checkValid verifies that data is valid JSON-encoded data.
+// scan is passed in for use by checkValid to avoid an allocation.
+func checkValid(data []byte, scan *scanner) error {
+	scan.reset()
+	for _, c := range data {
+		scan.bytes++
+		if scan.step(scan, int(c)) == scanError {
+			return scan.err
+		}
+	}
+	if scan.eof() == scanError {
+		return scan.err
+	}
+	return nil
+}
+
+// nextValue splits data after the next whole JSON value,
+// returning that value and the bytes that follow it as separate slices.
+// scan is passed in for use by nextValue to avoid an allocation.
+func nextValue(data []byte, scan *scanner) (value, rest []byte, err error) {
+	scan.reset()
+	for i, c := range data {
+		v := scan.step(scan, int(c))
+		if v >= scanEndObject {
+			switch v {
+			// probe the scanner with a space to determine whether we will
+			// get scanEnd on the next character. Otherwise, if the next character
+			// is not a space, scanEndTop allocates a needless error.
+			case scanEndObject, scanEndArray:
+				if scan.step(scan, ' ') == scanEnd {
+					return data[:i+1], data[i+1:], nil
+				}
+			case scanError:
+				return nil, nil, scan.err
+			case scanEnd:
+				return data[0:i], data[i:], nil
+			}
+		}
+	}
+	if scan.eof() == scanError {
+		return nil, nil, scan.err
+	}
+	return data, nil, nil
+}
+
+// A SyntaxError is a description of a JSON syntax error.
+type SyntaxError struct {
+	msg    string // description of error
+	Offset int64  // error occurred after reading Offset bytes
+}
+
+func (e *SyntaxError) Error() string { return e.msg }
+
+// A scanner is a JSON scanning state machine.
+// Callers call scan.reset() and then pass bytes in one at a time
+// by calling scan.step(&scan, c) for each byte.
+// The return value, referred to as an opcode, tells the
+// caller about significant parsing events like beginning
+// and ending literals, objects, and arrays, so that the
+// caller can follow along if it wishes.
+// The return value scanEnd indicates that a single top-level
+// JSON value has been completed, *before* the byte that
+// just got passed in.  (The indication must be delayed in order
+// to recognize the end of numbers: is 123 a whole value or
+// the beginning of 12345e+6?).
+type scanner struct {
+	// The step is a func to be called to execute the next transition.
+	// Also tried using an integer constant and a single func
+	// with a switch, but using the func directly was 10% faster
+	// on a 64-bit Mac Mini, and it's nicer to read.
+	step func(*scanner, int) int
+
+	// Reached end of top-level value.
+	endTop bool
+
+	// Stack of what we're in the middle of - array values, object keys, object values.
+	parseState []int
+
+	// Error that happened, if any.
+	err error
+
+	// 1-byte redo (see undo method)
+	redo      bool
+	redoCode  int
+	redoState func(*scanner, int) int
+
+	// total bytes consumed, updated by decoder.Decode
+	bytes int64
+}
+
+// These values are returned by the state transition functions
+// assigned to scanner.state and the method scanner.eof.
+// They give details about the current state of the scan that
+// callers might be interested to know about.
+// It is okay to ignore the return value of any particular
+// call to scanner.state: if one call returns scanError,
+// every subsequent call will return scanError too.
+const (
+	// Continue.
+	scanContinue     = iota // uninteresting byte
+	scanBeginLiteral        // end implied by next result != scanContinue
+	scanBeginObject         // begin object
+	scanObjectKey           // just finished object key (string)
+	scanObjectValue         // just finished non-last object value
+	scanEndObject           // end object (implies scanObjectValue if possible)
+	scanBeginArray          // begin array
+	scanArrayValue          // just finished array value
+	scanEndArray            // end array (implies scanArrayValue if possible)
+	scanSkipSpace           // space byte; can skip; known to be last "continue" result
+
+	// Stop.
+	scanEnd   // top-level value ended *before* this byte; known to be first "stop" result
+	scanError // hit an error, scanner.err.
+)
+
+// These values are stored in the parseState stack.
+// They give the current state of a composite value
+// being scanned.  If the parser is inside a nested value
+// the parseState describes the nested state, outermost at entry 0.
+const (
+	parseObjectKey   = iota // parsing object key (before colon)
+	parseObjectValue        // parsing object value (after colon)
+	parseArrayValue         // parsing array value
+)
+
+// reset prepares the scanner for use.
+// It must be called before calling s.step.
+func (s *scanner) reset() {
+	s.step = stateBeginValue
+	s.parseState = s.parseState[0:0]
+	s.err = nil
+	s.redo = false
+	s.endTop = false
+}
+
+// eof tells the scanner that the end of input has been reached.
+// It returns a scan status just as s.step does.
+func (s *scanner) eof() int {
+	if s.err != nil {
+		return scanError
+	}
+	if s.endTop {
+		return scanEnd
+	}
+	s.step(s, ' ')
+	if s.endTop {
+		return scanEnd
+	}
+	if s.err == nil {
+		s.err = &SyntaxError{"unexpected end of JSON input", s.bytes}
+	}
+	return scanError
+}
+
+// pushParseState pushes a new parse state p onto the parse stack.
+func (s *scanner) pushParseState(p int) {
+	s.parseState = append(s.parseState, p)
+}
+
+// popParseState pops a parse state (already obtained) off the stack
+// and updates s.step accordingly.
+func (s *scanner) popParseState() {
+	n := len(s.parseState) - 1
+	s.parseState = s.parseState[0:n]
+	s.redo = false
+	if n == 0 {
+		s.step = stateEndTop
+		s.endTop = true
+	} else {
+		s.step = stateEndValue
+	}
+}
+
+func isSpace(c rune) bool {
+	return c == ' ' || c == '\t' || c == '\r' || c == '\n'
+}
+
+// stateBeginValueOrEmpty is the state after reading `[`.
+func stateBeginValueOrEmpty(s *scanner, c int) int {
+	if c <= ' ' && isSpace(rune(c)) {
+		return scanSkipSpace
+	}
+	if c == ']' {
+		return stateEndValue(s, c)
+	}
+	return stateBeginValue(s, c)
+}
+
+// stateBeginValue is the state at the beginning of the input.
+func stateBeginValue(s *scanner, c int) int {
+	if c <= ' ' && isSpace(rune(c)) {
+		return scanSkipSpace
+	}
+	switch c {
+	case '{':
+		s.step = stateBeginStringOrEmpty
+		s.pushParseState(parseObjectKey)
+		return scanBeginObject
+	case '[':
+		s.step = stateBeginValueOrEmpty
+		s.pushParseState(parseArrayValue)
+		return scanBeginArray
+	case '"':
+		s.step = stateInString
+		return scanBeginLiteral
+	case '-':
+		s.step = stateNeg
+		return scanBeginLiteral
+	case '0': // beginning of 0.123
+		s.step = state0
+		return scanBeginLiteral
+	case 't': // beginning of true
+		s.step = stateT
+		return scanBeginLiteral
+	case 'f': // beginning of false
+		s.step = stateF
+		return scanBeginLiteral
+	case 'n': // beginning of null
+		s.step = stateN
+		return scanBeginLiteral
+	}
+	if '1' <= c && c <= '9' { // beginning of 1234.5
+		s.step = state1
+		return scanBeginLiteral
+	}
+	return s.error(c, "looking for beginning of value")
+}
+
+// stateBeginStringOrEmpty is the state after reading `{`.
+func stateBeginStringOrEmpty(s *scanner, c int) int {
+	if c <= ' ' && isSpace(rune(c)) {
+		return scanSkipSpace
+	}
+	if c == '}' {
+		n := len(s.parseState)
+		s.parseState[n-1] = parseObjectValue
+		return stateEndValue(s, c)
+	}
+	return stateBeginString(s, c)
+}
+
+// stateBeginString is the state after reading `{"key": value,`.
+func stateBeginString(s *scanner, c int) int {
+	if c <= ' ' && isSpace(rune(c)) {
+		return scanSkipSpace
+	}
+	if c == '"' {
+		s.step = stateInString
+		return scanBeginLiteral
+	}
+	return s.error(c, "looking for beginning of object key string")
+}
+
+// stateEndValue is the state after completing a value,
+// such as after reading `{}` or `true` or `["x"`.
+func stateEndValue(s *scanner, c int) int {
+	n := len(s.parseState)
+	if n == 0 {
+		// Completed top-level before the current byte.
+		s.step = stateEndTop
+		s.endTop = true
+		return stateEndTop(s, c)
+	}
+	if c <= ' ' && isSpace(rune(c)) {
+		s.step = stateEndValue
+		return scanSkipSpace
+	}
+	ps := s.parseState[n-1]
+	switch ps {
+	case parseObjectKey:
+		if c == ':' {
+			s.parseState[n-1] = parseObjectValue
+			s.step = stateBeginValue
+			return scanObjectKey
+		}
+		return s.error(c, "after object key")
+	case parseObjectValue:
+		if c == ',' {
+			s.parseState[n-1] = parseObjectKey
+			s.step = stateBeginString
+			return scanObjectValue
+		}
+		if c == '}' {
+			s.popParseState()
+			return scanEndObject
+		}
+		return s.error(c, "after object key:value pair")
+	case parseArrayValue:
+		if c == ',' {
+			s.step = stateBeginValue
+			return scanArrayValue
+		}
+		if c == ']' {
+			s.popParseState()
+			return scanEndArray
+		}
+		return s.error(c, "after array element")
+	}
+	return s.error(c, "")
+}
+
+// stateEndTop is the state after finishing the top-level value,
+// such as after reading `{}` or `[1,2,3]`.
+// Only space characters should be seen now.
+func stateEndTop(s *scanner, c int) int {
+	if c != ' ' && c != '\t' && c != '\r' && c != '\n' {
+		// Complain about non-space byte on next call.
+		s.error(c, "after top-level value")
+	}
+	return scanEnd
+}
+
+// stateInString is the state after reading `"`.
+func stateInString(s *scanner, c int) int {
+	if c == '"' {
+		s.step = stateEndValue
+		return scanContinue
+	}
+	if c == '\\' {
+		s.step = stateInStringEsc
+		return scanContinue
+	}
+	if c < 0x20 {
+		return s.error(c, "in string literal")
+	}
+	return scanContinue
+}
+
+// stateInStringEsc is the state after reading `"\` during a quoted string.
+func stateInStringEsc(s *scanner, c int) int {
+	switch c {
+	case 'b', 'f', 'n', 'r', 't', '\\', '/', '"':
+		s.step = stateInString
+		return scanContinue
+	}
+	if c == 'u' {
+		s.step = stateInStringEscU
+		return scanContinue
+	}
+	return s.error(c, "in string escape code")
+}
+
+// stateInStringEscU is the state after reading `"\u` during a quoted string.
+func stateInStringEscU(s *scanner, c int) int {
+	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
+		s.step = stateInStringEscU1
+		return scanContinue
+	}
+	// numbers
+	return s.error(c, "in \\u hexadecimal character escape")
+}
+
+// stateInStringEscU1 is the state after reading `"\u1` during a quoted string.
+func stateInStringEscU1(s *scanner, c int) int {
+	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
+		s.step = stateInStringEscU12
+		return scanContinue
+	}
+	// numbers
+	return s.error(c, "in \\u hexadecimal character escape")
+}
+
+// stateInStringEscU12 is the state after reading `"\u12` during a quoted string.
+func stateInStringEscU12(s *scanner, c int) int {
+	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
+		s.step = stateInStringEscU123
+		return scanContinue
+	}
+	// numbers
+	return s.error(c, "in \\u hexadecimal character escape")
+}
+
+// stateInStringEscU123 is the state after reading `"\u123` during a quoted string.
+func stateInStringEscU123(s *scanner, c int) int {
+	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
+		s.step = stateInString
+		return scanContinue
+	}
+	// numbers
+	return s.error(c, "in \\u hexadecimal character escape")
+}
+
+// stateNeg is the state after reading `-` during a number.
+func stateNeg(s *scanner, c int) int {
+	if c == '0' {
+		s.step = state0
+		return scanContinue
+	}
+	if '1' <= c && c <= '9' {
+		s.step = state1
+		return scanContinue
+	}
+	return s.error(c, "in numeric literal")
+}
+
+// state1 is the state after reading a non-zero integer during a number,
+// such as after reading `1` or `100` but not `0`.
+func state1(s *scanner, c int) int {
+	if '0' <= c && c <= '9' {
+		s.step = state1
+		return scanContinue
+	}
+	return state0(s, c)
+}
+
+// state0 is the state after reading `0` during a number.
+func state0(s *scanner, c int) int {
+	if c == '.' {
+		s.step = stateDot
+		return scanContinue
+	}
+	if c == 'e' || c == 'E' {
+		s.step = stateE
+		return scanContinue
+	}
+	return stateEndValue(s, c)
+}
+
+// stateDot is the state after reading the integer and decimal point in a number,
+// such as after reading `1.`.
+func stateDot(s *scanner, c int) int {
+	if '0' <= c && c <= '9' {
+		s.step = stateDot0
+		return scanContinue
+	}
+	return s.error(c, "after decimal point in numeric literal")
+}
+
+// stateDot0 is the state after reading the integer, decimal point, and subsequent
+// digits of a number, such as after reading `3.14`.
+func stateDot0(s *scanner, c int) int {
+	if '0' <= c && c <= '9' {
+		s.step = stateDot0
+		return scanContinue
+	}
+	if c == 'e' || c == 'E' {
+		s.step = stateE
+		return scanContinue
+	}
+	return stateEndValue(s, c)
+}
+
+// stateE is the state after reading the mantissa and e in a number,
+// such as after reading `314e` or `0.314e`.
+func stateE(s *scanner, c int) int {
+	if c == '+' {
+		s.step = stateESign
+		return scanContinue
+	}
+	if c == '-' {
+		s.step = stateESign
+		return scanContinue
+	}
+	return stateESign(s, c)
+}
+
+// stateESign is the state after reading the mantissa, e, and sign in a number,
+// such as after reading `314e-` or `0.314e+`.
+func stateESign(s *scanner, c int) int {
+	if '0' <= c && c <= '9' {
+		s.step = stateE0
+		return scanContinue
+	}
+	return s.error(c, "in exponent of numeric literal")
+}
+
+// stateE0 is the state after reading the mantissa, e, optional sign,
+// and at least one digit of the exponent in a number,
+// such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
+func stateE0(s *scanner, c int) int {
+	if '0' <= c && c <= '9' {
+		s.step = stateE0
+		return scanContinue
+	}
+	return stateEndValue(s, c)
+}
+
+// stateT is the state after reading `t`.
+func stateT(s *scanner, c int) int {
+	if c == 'r' {
+		s.step = stateTr
+		return scanContinue
+	}
+	return s.error(c, "in literal true (expecting 'r')")
+}
+
+// stateTr is the state after reading `tr`.
+func stateTr(s *scanner, c int) int {
+	if c == 'u' {
+		s.step = stateTru
+		return scanContinue
+	}
+	return s.error(c, "in literal true (expecting 'u')")
+}
+
+// stateTru is the state after reading `tru`.
+func stateTru(s *scanner, c int) int {
+	if c == 'e' {
+		s.step = stateEndValue
+		return scanContinue
+	}
+	return s.error(c, "in literal true (expecting 'e')")
+}
+
+// stateF is the state after reading `f`.
+func stateF(s *scanner, c int) int {
+	if c == 'a' {
+		s.step = stateFa
+		return scanContinue
+	}
+	return s.error(c, "in literal false (expecting 'a')")
+}
+
+// stateFa is the state after reading `fa`.
+func stateFa(s *scanner, c int) int {
+	if c == 'l' {
+		s.step = stateFal
+		return scanContinue
+	}
+	return s.error(c, "in literal false (expecting 'l')")
+}
+
+// stateFal is the state after reading `fal`.
+func stateFal(s *scanner, c int) int {
+	if c == 's' {
+		s.step = stateFals
+		return scanContinue
+	}
+	return s.error(c, "in literal false (expecting 's')")
+}
+
+// stateFals is the state after reading `fals`.
+func stateFals(s *scanner, c int) int {
+	if c == 'e' {
+		s.step = stateEndValue
+		return scanContinue
+	}
+	return s.error(c, "in literal false (expecting 'e')")
+}
+
+// stateN is the state after reading `n`.
+func stateN(s *scanner, c int) int {
+	if c == 'u' {
+		s.step = stateNu
+		return scanContinue
+	}
+	return s.error(c, "in literal null (expecting 'u')")
+}
+
+// stateNu is the state after reading `nu`.
+func stateNu(s *scanner, c int) int {
+	if c == 'l' {
+		s.step = stateNul
+		return scanContinue
+	}
+	return s.error(c, "in literal null (expecting 'l')")
+}
+
+// stateNul is the state after reading `nul`.
+func stateNul(s *scanner, c int) int {
+	if c == 'l' {
+		s.step = stateEndValue
+		return scanContinue
+	}
+	return s.error(c, "in literal null (expecting 'l')")
+}
+
+// stateError is the state after reaching a syntax error,
+// such as after reading `[1}` or `5.1.2`.
+func stateError(s *scanner, c int) int {
+	return scanError
+}
+
+// error records an error and switches to the error state.
+func (s *scanner) error(c int, context string) int {
+	s.step = stateError
+	s.err = &SyntaxError{"invalid character " + quoteChar(c) + " " + context, s.bytes}
+	return scanError
+}
+
+// quoteChar formats c as a quoted character literal
+func quoteChar(c int) string {
+	// special cases - different from quoted strings
+	if c == '\'' {
+		return `'\''`
+	}
+	if c == '"' {
+		return `'"'`
+	}
+
+	// use quoted string with different quotation marks
+	s := strconv.Quote(string(c))
+	return "'" + s[1:len(s)-1] + "'"
+}
+
+// undo causes the scanner to return scanCode from the next state transition.
+// This gives callers a simple 1-byte undo mechanism.
+func (s *scanner) undo(scanCode int) {
+	if s.redo {
+		panic("json: invalid use of scanner")
+	}
+	s.redoCode = scanCode
+	s.redoState = s.step
+	s.step = stateRedo
+	s.redo = true
+}
+
+// stateRedo helps implement the scanner's 1-byte undo.
+func stateRedo(s *scanner, c int) int {
+	s.redo = false
+	s.step = s.redoState
+	return s.redoCode
+}
diff --git a/vendor/github.com/ajeddeloh/go-json/stream.go b/vendor/github.com/ajeddeloh/go-json/stream.go
new file mode 100644
index 00000000..dc53bcef
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/stream.go
@@ -0,0 +1,480 @@
+// Copyright 2010 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package json
+
+import (
+	"bytes"
+	"errors"
+	"io"
+)
+
+// A Decoder reads and decodes JSON objects from an input stream.
+type Decoder struct {
+	r     io.Reader
+	buf   []byte
+	d     decodeState
+	scanp int // start of unread data in buf
+	scan  scanner
+	err   error
+
+	tokenState int
+	tokenStack []int
+}
+
+// NewDecoder returns a new decoder that reads from r.
+//
+// The decoder introduces its own buffering and may
+// read data from r beyond the JSON values requested.
+func NewDecoder(r io.Reader) *Decoder {
+	return &Decoder{r: r}
+}
+
+// UseNumber causes the Decoder to unmarshal a number into an interface{} as a
+// Number instead of as a float64.
+func (dec *Decoder) UseNumber() { dec.d.useNumber = true }
+
+// Decode reads the next JSON-encoded value from its
+// input and stores it in the value pointed to by v.
+//
+// See the documentation for Unmarshal for details about
+// the conversion of JSON into a Go value.
+func (dec *Decoder) Decode(v interface{}) error {
+	if dec.err != nil {
+		return dec.err
+	}
+
+	if err := dec.tokenPrepareForDecode(); err != nil {
+		return err
+	}
+
+	if !dec.tokenValueAllowed() {
+		return &SyntaxError{msg: "not at beginning of value"}
+	}
+
+	// Read whole value into buffer.
+	n, err := dec.readValue()
+	if err != nil {
+		return err
+	}
+	dec.d.init(dec.buf[dec.scanp : dec.scanp+n])
+	dec.scanp += n
+
+	// Don't save err from unmarshal into dec.err:
+	// the connection is still usable since we read a complete JSON
+	// object from it before the error happened.
+	err = dec.d.unmarshal(v)
+
+	// fixup token streaming state
+	dec.tokenValueEnd()
+
+	return err
+}
+
+// Buffered returns a reader of the data remaining in the Decoder's
+// buffer. The reader is valid until the next call to Decode.
+func (dec *Decoder) Buffered() io.Reader {
+	return bytes.NewReader(dec.buf[dec.scanp:])
+}
+
+// readValue reads a JSON value into dec.buf.
+// It returns the length of the encoding.
+func (dec *Decoder) readValue() (int, error) {
+	dec.scan.reset()
+
+	scanp := dec.scanp
+	var err error
+Input:
+	for {
+		// Look in the buffer for a new value.
+		for i, c := range dec.buf[scanp:] {
+			dec.scan.bytes++
+			v := dec.scan.step(&dec.scan, int(c))
+			if v == scanEnd {
+				scanp += i
+				break Input
+			}
+			// scanEnd is delayed one byte.
+			// We might block trying to get that byte from src,
+			// so instead invent a space byte.
+			if (v == scanEndObject || v == scanEndArray) && dec.scan.step(&dec.scan, ' ') == scanEnd {
+				scanp += i + 1
+				break Input
+			}
+			if v == scanError {
+				dec.err = dec.scan.err
+				return 0, dec.scan.err
+			}
+		}
+		scanp = len(dec.buf)
+
+		// Did the last read have an error?
+		// Delayed until now to allow buffer scan.
+		if err != nil {
+			if err == io.EOF {
+				if dec.scan.step(&dec.scan, ' ') == scanEnd {
+					break Input
+				}
+				if nonSpace(dec.buf) {
+					err = io.ErrUnexpectedEOF
+				}
+			}
+			dec.err = err
+			return 0, err
+		}
+
+		n := scanp - dec.scanp
+		err = dec.refill()
+		scanp = dec.scanp + n
+	}
+	return scanp - dec.scanp, nil
+}
+
+func (dec *Decoder) refill() error {
+	// Make room to read more into the buffer.
+	// First slide down data already consumed.
+	if dec.scanp > 0 {
+		n := copy(dec.buf, dec.buf[dec.scanp:])
+		dec.buf = dec.buf[:n]
+		dec.scanp = 0
+	}
+
+	// Grow buffer if not large enough.
+	const minRead = 512
+	if cap(dec.buf)-len(dec.buf) < minRead {
+		newBuf := make([]byte, len(dec.buf), 2*cap(dec.buf)+minRead)
+		copy(newBuf, dec.buf)
+		dec.buf = newBuf
+	}
+
+	// Read.  Delay error for next iteration (after scan).
+	n, err := dec.r.Read(dec.buf[len(dec.buf):cap(dec.buf)])
+	dec.buf = dec.buf[0 : len(dec.buf)+n]
+
+	return err
+}
+
+func nonSpace(b []byte) bool {
+	for _, c := range b {
+		if !isSpace(rune(c)) {
+			return true
+		}
+	}
+	return false
+}
+
+// An Encoder writes JSON objects to an output stream.
+type Encoder struct {
+	w   io.Writer
+	err error
+}
+
+// NewEncoder returns a new encoder that writes to w.
+func NewEncoder(w io.Writer) *Encoder {
+	return &Encoder{w: w}
+}
+
+// Encode writes the JSON encoding of v to the stream,
+// followed by a newline character.
+//
+// See the documentation for Marshal for details about the
+// conversion of Go values to JSON.
+func (enc *Encoder) Encode(v interface{}) error {
+	if enc.err != nil {
+		return enc.err
+	}
+	e := newEncodeState()
+	err := e.marshal(v)
+	if err != nil {
+		return err
+	}
+
+	// Terminate each value with a newline.
+	// This makes the output look a little nicer
+	// when debugging, and some kind of space
+	// is required if the encoded value was a number,
+	// so that the reader knows there aren't more
+	// digits coming.
+	e.WriteByte('\n')
+
+	if _, err = enc.w.Write(e.Bytes()); err != nil {
+		enc.err = err
+	}
+	encodeStatePool.Put(e)
+	return err
+}
+
+// RawMessage is a raw encoded JSON object.
+// It implements Marshaler and Unmarshaler and can
+// be used to delay JSON decoding or precompute a JSON encoding.
+type RawMessage []byte
+
+// MarshalJSON returns *m as the JSON encoding of m.
+func (m *RawMessage) MarshalJSON() ([]byte, error) {
+	return *m, nil
+}
+
+// UnmarshalJSON sets *m to a copy of data.
+func (m *RawMessage) UnmarshalJSON(data []byte) error {
+	if m == nil {
+		return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")
+	}
+	*m = append((*m)[0:0], data...)
+	return nil
+}
+
+var _ Marshaler = (*RawMessage)(nil)
+var _ Unmarshaler = (*RawMessage)(nil)
+
+// A Token holds a value of one of these types:
+//
+//	Delim, for the four JSON delimiters [ ] { }
+//	bool, for JSON booleans
+//	float64, for JSON numbers
+//	Number, for JSON numbers
+//	string, for JSON string literals
+//	nil, for JSON null
+//
+type Token interface{}
+
+const (
+	tokenTopValue = iota
+	tokenArrayStart
+	tokenArrayValue
+	tokenArrayComma
+	tokenObjectStart
+	tokenObjectKey
+	tokenObjectColon
+	tokenObjectValue
+	tokenObjectComma
+)
+
+// advance tokenstate from a separator state to a value state
+func (dec *Decoder) tokenPrepareForDecode() error {
+	// Note: Not calling peek before switch, to avoid
+	// putting peek into the standard Decode path.
+	// peek is only called when using the Token API.
+	switch dec.tokenState {
+	case tokenArrayComma:
+		c, err := dec.peek()
+		if err != nil {
+			return err
+		}
+		if c != ',' {
+			return &SyntaxError{"expected comma after array element", 0}
+		}
+		dec.scanp++
+		dec.tokenState = tokenArrayValue
+	case tokenObjectColon:
+		c, err := dec.peek()
+		if err != nil {
+			return err
+		}
+		if c != ':' {
+			return &SyntaxError{"expected colon after object key", 0}
+		}
+		dec.scanp++
+		dec.tokenState = tokenObjectValue
+	}
+	return nil
+}
+
+func (dec *Decoder) tokenValueAllowed() bool {
+	switch dec.tokenState {
+	case tokenTopValue, tokenArrayStart, tokenArrayValue, tokenObjectValue:
+		return true
+	}
+	return false
+}
+
+func (dec *Decoder) tokenValueEnd() {
+	switch dec.tokenState {
+	case tokenArrayStart, tokenArrayValue:
+		dec.tokenState = tokenArrayComma
+	case tokenObjectValue:
+		dec.tokenState = tokenObjectComma
+	}
+}
+
+// A Delim is a JSON array or object delimiter, one of [ ] { or }.
+type Delim rune
+
+func (d Delim) String() string {
+	return string(d)
+}
+
+// Token returns the next JSON token in the input stream.
+// At the end of the input stream, Token returns nil, io.EOF.
+//
+// Token guarantees that the delimiters [ ] { } it returns are
+// properly nested and matched: if Token encounters an unexpected
+// delimiter in the input, it will return an error.
+//
+// The input stream consists of basic JSON values—bool, string,
+// number, and null—along with delimiters [ ] { } of type Delim
+// to mark the start and end of arrays and objects.
+// Commas and colons are elided.
+func (dec *Decoder) Token() (Token, error) {
+	for {
+		c, err := dec.peek()
+		if err != nil {
+			return nil, err
+		}
+		switch c {
+		case '[':
+			if !dec.tokenValueAllowed() {
+				return dec.tokenError(c)
+			}
+			dec.scanp++
+			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
+			dec.tokenState = tokenArrayStart
+			return Delim('['), nil
+
+		case ']':
+			if dec.tokenState != tokenArrayStart && dec.tokenState != tokenArrayComma {
+				return dec.tokenError(c)
+			}
+			dec.scanp++
+			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
+			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
+			dec.tokenValueEnd()
+			return Delim(']'), nil
+
+		case '{':
+			if !dec.tokenValueAllowed() {
+				return dec.tokenError(c)
+			}
+			dec.scanp++
+			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
+			dec.tokenState = tokenObjectStart
+			return Delim('{'), nil
+
+		case '}':
+			if dec.tokenState != tokenObjectStart && dec.tokenState != tokenObjectComma {
+				return dec.tokenError(c)
+			}
+			dec.scanp++
+			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
+			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
+			dec.tokenValueEnd()
+			return Delim('}'), nil
+
+		case ':':
+			if dec.tokenState != tokenObjectColon {
+				return dec.tokenError(c)
+			}
+			dec.scanp++
+			dec.tokenState = tokenObjectValue
+			continue
+
+		case ',':
+			if dec.tokenState == tokenArrayComma {
+				dec.scanp++
+				dec.tokenState = tokenArrayValue
+				continue
+			}
+			if dec.tokenState == tokenObjectComma {
+				dec.scanp++
+				dec.tokenState = tokenObjectKey
+				continue
+			}
+			return dec.tokenError(c)
+
+		case '"':
+			if dec.tokenState == tokenObjectStart || dec.tokenState == tokenObjectKey {
+				var x string
+				old := dec.tokenState
+				dec.tokenState = tokenTopValue
+				err := dec.Decode(&x)
+				dec.tokenState = old
+				if err != nil {
+					clearOffset(err)
+					return nil, err
+				}
+				dec.tokenState = tokenObjectColon
+				return x, nil
+			}
+			fallthrough
+
+		default:
+			if !dec.tokenValueAllowed() {
+				return dec.tokenError(c)
+			}
+			var x interface{}
+			if err := dec.Decode(&x); err != nil {
+				clearOffset(err)
+				return nil, err
+			}
+			return x, nil
+		}
+	}
+}
+
+func clearOffset(err error) {
+	if s, ok := err.(*SyntaxError); ok {
+		s.Offset = 0
+	}
+}
+
+func (dec *Decoder) tokenError(c byte) (Token, error) {
+	var context string
+	switch dec.tokenState {
+	case tokenTopValue:
+		context = " looking for beginning of value"
+	case tokenArrayStart, tokenArrayValue, tokenObjectValue:
+		context = " looking for beginning of value"
+	case tokenArrayComma:
+		context = " after array element"
+	case tokenObjectKey:
+		context = " looking for beginning of object key string"
+	case tokenObjectColon:
+		context = " after object key"
+	case tokenObjectComma:
+		context = " after object key:value pair"
+	}
+	return nil, &SyntaxError{"invalid character " + quoteChar(int(c)) + " " + context, 0}
+}
+
+// More reports whether there is another element in the
+// current array or object being parsed.
+func (dec *Decoder) More() bool {
+	c, err := dec.peek()
+	return err == nil && c != ']' && c != '}'
+}
+
+func (dec *Decoder) peek() (byte, error) {
+	var err error
+	for {
+		for i := dec.scanp; i < len(dec.buf); i++ {
+			c := dec.buf[i]
+			if isSpace(rune(c)) {
+				continue
+			}
+			dec.scanp = i
+			return c, nil
+		}
+		// buffer has been scanned, now report any error
+		if err != nil {
+			return 0, err
+		}
+		err = dec.refill()
+	}
+}
+
+/*
+TODO
+
+// EncodeToken writes the given JSON token to the stream.
+// It returns an error if the delimiters [ ] { } are not properly used.
+//
+// EncodeToken does not call Flush, because usually it is part of
+// a larger operation such as Encode, and those will call Flush when finished.
+// Callers that create an Encoder and then invoke EncodeToken directly,
+// without using Encode, need to call Flush when finished to ensure that
+// the JSON is written to the underlying writer.
+func (e *Encoder) EncodeToken(t Token) error  {
+	...
+}
+
+*/
diff --git a/vendor/github.com/ajeddeloh/go-json/tags.go b/vendor/github.com/ajeddeloh/go-json/tags.go
new file mode 100644
index 00000000..c38fd510
--- /dev/null
+++ b/vendor/github.com/ajeddeloh/go-json/tags.go
@@ -0,0 +1,44 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package json
+
+import (
+	"strings"
+)
+
+// tagOptions is the string following a comma in a struct field's "json"
+// tag, or the empty string. It does not include the leading comma.
+type tagOptions string
+
+// parseTag splits a struct field's json tag into its name and
+// comma-separated options.
+func parseTag(tag string) (string, tagOptions) {
+	if idx := strings.Index(tag, ","); idx != -1 {
+		return tag[:idx], tagOptions(tag[idx+1:])
+	}
+	return tag, tagOptions("")
+}
+
+// Contains reports whether a comma-separated list of options
+// contains a particular substr flag. substr must be surrounded by a
+// string boundary or commas.
+func (o tagOptions) Contains(optionName string) bool {
+	if len(o) == 0 {
+		return false
+	}
+	s := string(o)
+	for s != "" {
+		var next string
+		i := strings.Index(s, ",")
+		if i >= 0 {
+			s, next = s[:i], s[i+1:]
+		}
+		if s == optionName {
+			return true
+		}
+		s = next
+	}
+	return false
+}
diff --git a/vendor/github.com/coreos/go-systemd/LICENSE b/vendor/github.com/coreos/go-systemd/LICENSE
new file mode 100644
index 00000000..37ec93a1
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/LICENSE
@@ -0,0 +1,191 @@
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and
+distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright
+owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities
+that control, are controlled by, or are under common control with that entity.
+For the purposes of this definition, "control" means (i) the power, direct or
+indirect, to cause the direction or management of such entity, whether by
+contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
+outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising
+permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including
+but not limited to software source code, documentation source, and configuration
+files.
+
+"Object" form shall mean any form resulting from mechanical transformation or
+translation of a Source form, including but not limited to compiled object code,
+generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made
+available under the License, as indicated by a copyright notice that is included
+in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that
+is based on (or derived from) the Work and for which the editorial revisions,
+annotations, elaborations, or other modifications represent, as a whole, an
+original work of authorship. For the purposes of this License, Derivative Works
+shall not include works that remain separable from, or merely link (or bind by
+name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version
+of the Work and any modifications or additions to that Work or Derivative Works
+thereof, that is intentionally submitted to Licensor for inclusion in the Work
+by the copyright owner or by an individual or Legal Entity authorized to submit
+on behalf of the copyright owner. For the purposes of this definition,
+"submitted" means any form of electronic, verbal, or written communication sent
+to the Licensor or its representatives, including but not limited to
+communication on electronic mailing lists, source code control systems, and
+issue tracking systems that are managed by, or on behalf of, the Licensor for
+the purpose of discussing and improving the Work, but excluding communication
+that is conspicuously marked or otherwise designated in writing by the copyright
+owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf
+of whom a Contribution has been received by Licensor and subsequently
+incorporated within the Work.
+
+2. Grant of Copyright License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable copyright license to reproduce, prepare Derivative Works of,
+publicly display, publicly perform, sublicense, and distribute the Work and such
+Derivative Works in Source or Object form.
+
+3. Grant of Patent License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable (except as stated in this section) patent license to make, have
+made, use, offer to sell, sell, import, and otherwise transfer the Work, where
+such license applies only to those patent claims licensable by such Contributor
+that are necessarily infringed by their Contribution(s) alone or by combination
+of their Contribution(s) with the Work to which such Contribution(s) was
+submitted. If You institute patent litigation against any entity (including a
+cross-claim or counterclaim in a lawsuit) alleging that the Work or a
+Contribution incorporated within the Work constitutes direct or contributory
+patent infringement, then any patent licenses granted to You under this License
+for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution.
+
+You may reproduce and distribute copies of the Work or Derivative Works thereof
+in any medium, with or without modifications, and in Source or Object form,
+provided that You meet the following conditions:
+
+You must give any other recipients of the Work or Derivative Works a copy of
+this License; and
+You must cause any modified files to carry prominent notices stating that You
+changed the files; and
+You must retain, in the Source form of any Derivative Works that You distribute,
+all copyright, patent, trademark, and attribution notices from the Source form
+of the Work, excluding those notices that do not pertain to any part of the
+Derivative Works; and
+If the Work includes a "NOTICE" text file as part of its distribution, then any
+Derivative Works that You distribute must include a readable copy of the
+attribution notices contained within such NOTICE file, excluding those notices
+that do not pertain to any part of the Derivative Works, in at least one of the
+following places: within a NOTICE text file distributed as part of the
+Derivative Works; within the Source form or documentation, if provided along
+with the Derivative Works; or, within a display generated by the Derivative
+Works, if and wherever such third-party notices normally appear. The contents of
+the NOTICE file are for informational purposes only and do not modify the
+License. You may add Your own attribution notices within Derivative Works that
+You distribute, alongside or as an addendum to the NOTICE text from the Work,
+provided that such additional attribution notices cannot be construed as
+modifying the License.
+You may add Your own copyright statement to Your modifications and may provide
+additional or different license terms and conditions for use, reproduction, or
+distribution of Your modifications, or for any such Derivative Works as a whole,
+provided Your use, reproduction, and distribution of the Work otherwise complies
+with the conditions stated in this License.
+
+5. Submission of Contributions.
+
+Unless You explicitly state otherwise, any Contribution intentionally submitted
+for inclusion in the Work by You to the Licensor shall be under the terms and
+conditions of this License, without any additional terms or conditions.
+Notwithstanding the above, nothing herein shall supersede or modify the terms of
+any separate license agreement you may have executed with Licensor regarding
+such Contributions.
+
+6. Trademarks.
+
+This License does not grant permission to use the trade names, trademarks,
+service marks, or product names of the Licensor, except as required for
+reasonable and customary use in describing the origin of the Work and
+reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty.
+
+Unless required by applicable law or agreed to in writing, Licensor provides the
+Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
+including, without limitation, any warranties or conditions of TITLE,
+NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
+solely responsible for determining the appropriateness of using or
+redistributing the Work and assume any risks associated with Your exercise of
+permissions under this License.
+
+8. Limitation of Liability.
+
+In no event and under no legal theory, whether in tort (including negligence),
+contract, or otherwise, unless required by applicable law (such as deliberate
+and grossly negligent acts) or agreed to in writing, shall any Contributor be
+liable to You for damages, including any direct, indirect, special, incidental,
+or consequential damages of any character arising as a result of this License or
+out of the use or inability to use the Work (including but not limited to
+damages for loss of goodwill, work stoppage, computer failure or malfunction, or
+any and all other commercial damages or losses), even if such Contributor has
+been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability.
+
+While redistributing the Work or Derivative Works thereof, You may choose to
+offer, and charge a fee for, acceptance of support, warranty, indemnity, or
+other liability obligations and/or rights consistent with this License. However,
+in accepting such obligations, You may act only on Your own behalf and on Your
+sole responsibility, not on behalf of any other Contributor, and only if You
+agree to indemnify, defend, and hold each Contributor harmless for any liability
+incurred by, or claims asserted against, such Contributor by reason of your
+accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work
+
+To apply the Apache License to your work, attach the following boilerplate
+notice, with the fields enclosed by brackets "[]" replaced with your own
+identifying information. (Don't include the brackets!) The text should be
+enclosed in the appropriate comment syntax for the file format. We also
+recommend that a file or class name and description of purpose be included on
+the same "printed page" as the copyright notice for easier identification within
+third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/vendor/github.com/coreos/go-systemd/NOTICE b/vendor/github.com/coreos/go-systemd/NOTICE
new file mode 100644
index 00000000..23a0ada2
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/NOTICE
@@ -0,0 +1,5 @@
+CoreOS Project
+Copyright 2018 CoreOS, Inc
+
+This product includes software developed at CoreOS, Inc.
+(http://www.coreos.com/).
diff --git a/vendor/github.com/coreos/go-systemd/unit/deserialize.go b/vendor/github.com/coreos/go-systemd/unit/deserialize.go
new file mode 100644
index 00000000..c0c06bdf
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/unit/deserialize.go
@@ -0,0 +1,278 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package unit
+
+import (
+	"bufio"
+	"bytes"
+	"errors"
+	"fmt"
+	"io"
+	"strings"
+	"unicode"
+)
+
+const (
+	// SYSTEMD_LINE_MAX mimics the maximum line length that systemd can use.
+	// On typical systemd platforms (i.e. modern Linux), this will most
+	// commonly be 2048, so let's use that as a sanity check.
+	// Technically, we should probably pull this at runtime:
+	//    SYSTEMD_LINE_MAX = int(C.sysconf(C.__SC_LINE_MAX))
+	// but this would introduce an (unfortunate) dependency on cgo
+	SYSTEMD_LINE_MAX = 2048
+
+	// SYSTEMD_NEWLINE defines characters that systemd considers indicators
+	// for a newline.
+	SYSTEMD_NEWLINE = "\r\n"
+)
+
+var (
+	// ErrLineTooLong gets returned when a line is too long for systemd to handle.
+	ErrLineTooLong = fmt.Errorf("line too long (max %d bytes)", SYSTEMD_LINE_MAX)
+)
+
+// Deserialize parses a systemd unit file into a list of UnitOption objects.
+func Deserialize(f io.Reader) (opts []*UnitOption, err error) {
+	lexer, optchan, errchan := newLexer(f)
+	go lexer.lex()
+
+	for opt := range optchan {
+		opts = append(opts, &(*opt))
+	}
+
+	err = <-errchan
+	return opts, err
+}
+
+func newLexer(f io.Reader) (*lexer, <-chan *UnitOption, <-chan error) {
+	optchan := make(chan *UnitOption)
+	errchan := make(chan error, 1)
+	buf := bufio.NewReader(f)
+
+	return &lexer{buf, optchan, errchan, ""}, optchan, errchan
+}
+
+type lexer struct {
+	buf     *bufio.Reader
+	optchan chan *UnitOption
+	errchan chan error
+	section string
+}
+
+func (l *lexer) lex() {
+	defer func() {
+		close(l.optchan)
+		close(l.errchan)
+	}()
+	next := l.lexNextSection
+	for next != nil {
+		if l.buf.Buffered() >= SYSTEMD_LINE_MAX {
+			// systemd truncates lines longer than LINE_MAX
+			// https://bugs.freedesktop.org/show_bug.cgi?id=85308
+			// Rather than allowing this to pass silently, let's
+			// explicitly gate people from encountering this
+			line, err := l.buf.Peek(SYSTEMD_LINE_MAX)
+			if err != nil {
+				l.errchan <- err
+				return
+			}
+			if !bytes.ContainsAny(line, SYSTEMD_NEWLINE) {
+				l.errchan <- ErrLineTooLong
+				return
+			}
+		}
+
+		var err error
+		next, err = next()
+		if err != nil {
+			l.errchan <- err
+			return
+		}
+	}
+}
+
+type lexStep func() (lexStep, error)
+
+func (l *lexer) lexSectionName() (lexStep, error) {
+	sec, err := l.buf.ReadBytes(']')
+	if err != nil {
+		return nil, errors.New("unable to find end of section")
+	}
+
+	return l.lexSectionSuffixFunc(string(sec[:len(sec)-1])), nil
+}
+
+func (l *lexer) lexSectionSuffixFunc(section string) lexStep {
+	return func() (lexStep, error) {
+		garbage, _, err := l.toEOL()
+		if err != nil {
+			return nil, err
+		}
+
+		garbage = bytes.TrimSpace(garbage)
+		if len(garbage) > 0 {
+			return nil, fmt.Errorf("found garbage after section name %s: %v", l.section, garbage)
+		}
+
+		return l.lexNextSectionOrOptionFunc(section), nil
+	}
+}
+
+func (l *lexer) ignoreLineFunc(next lexStep) lexStep {
+	return func() (lexStep, error) {
+		for {
+			line, _, err := l.toEOL()
+			if err != nil {
+				return nil, err
+			}
+
+			line = bytes.TrimSuffix(line, []byte{' '})
+
+			// lack of continuation means this line has been exhausted
+			if !bytes.HasSuffix(line, []byte{'\\'}) {
+				break
+			}
+		}
+
+		// reached end of buffer, safe to exit
+		return next, nil
+	}
+}
+
+func (l *lexer) lexNextSection() (lexStep, error) {
+	r, _, err := l.buf.ReadRune()
+	if err != nil {
+		if err == io.EOF {
+			err = nil
+		}
+		return nil, err
+	}
+
+	if r == '[' {
+		return l.lexSectionName, nil
+	} else if isComment(r) {
+		return l.ignoreLineFunc(l.lexNextSection), nil
+	}
+
+	return l.lexNextSection, nil
+}
+
+func (l *lexer) lexNextSectionOrOptionFunc(section string) lexStep {
+	return func() (lexStep, error) {
+		r, _, err := l.buf.ReadRune()
+		if err != nil {
+			if err == io.EOF {
+				err = nil
+			}
+			return nil, err
+		}
+
+		if unicode.IsSpace(r) {
+			return l.lexNextSectionOrOptionFunc(section), nil
+		} else if r == '[' {
+			return l.lexSectionName, nil
+		} else if isComment(r) {
+			return l.ignoreLineFunc(l.lexNextSectionOrOptionFunc(section)), nil
+		}
+
+		l.buf.UnreadRune()
+		return l.lexOptionNameFunc(section), nil
+	}
+}
+
+func (l *lexer) lexOptionNameFunc(section string) lexStep {
+	return func() (lexStep, error) {
+		var partial bytes.Buffer
+		for {
+			r, _, err := l.buf.ReadRune()
+			if err != nil {
+				return nil, err
+			}
+
+			if r == '\n' || r == '\r' {
+				return nil, errors.New("unexpected newline encountered while parsing option name")
+			}
+
+			if r == '=' {
+				break
+			}
+
+			partial.WriteRune(r)
+		}
+
+		name := strings.TrimSpace(partial.String())
+		return l.lexOptionValueFunc(section, name, bytes.Buffer{}), nil
+	}
+}
+
+func (l *lexer) lexOptionValueFunc(section, name string, partial bytes.Buffer) lexStep {
+	return func() (lexStep, error) {
+		for {
+			line, eof, err := l.toEOL()
+			if err != nil {
+				return nil, err
+			}
+
+			if len(bytes.TrimSpace(line)) == 0 {
+				break
+			}
+
+			partial.Write(line)
+
+			// lack of continuation means this value has been exhausted
+			idx := bytes.LastIndex(line, []byte{'\\'})
+			if idx == -1 || idx != (len(line)-1) {
+				break
+			}
+
+			if !eof {
+				partial.WriteRune('\n')
+			}
+
+			return l.lexOptionValueFunc(section, name, partial), nil
+		}
+
+		val := partial.String()
+		if strings.HasSuffix(val, "\n") {
+			// A newline was added to the end, so the file didn't end with a backslash.
+			// => Keep the newline
+			val = strings.TrimSpace(val) + "\n"
+		} else {
+			val = strings.TrimSpace(val)
+		}
+		l.optchan <- &UnitOption{Section: section, Name: name, Value: val}
+
+		return l.lexNextSectionOrOptionFunc(section), nil
+	}
+}
+
+// toEOL reads until the end-of-line or end-of-file.
+// Returns (data, EOFfound, error)
+func (l *lexer) toEOL() ([]byte, bool, error) {
+	line, err := l.buf.ReadBytes('\n')
+	// ignore EOF here since it's roughly equivalent to EOL
+	if err != nil && err != io.EOF {
+		return nil, false, err
+	}
+
+	line = bytes.TrimSuffix(line, []byte{'\r'})
+	line = bytes.TrimSuffix(line, []byte{'\n'})
+
+	return line, err == io.EOF, nil
+}
+
+func isComment(r rune) bool {
+	return r == '#' || r == ';'
+}
diff --git a/vendor/github.com/coreos/go-systemd/unit/escape.go b/vendor/github.com/coreos/go-systemd/unit/escape.go
new file mode 100644
index 00000000..63b11726
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/unit/escape.go
@@ -0,0 +1,116 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Implements systemd-escape [--unescape] [--path]
+
+package unit
+
+import (
+	"fmt"
+	"strconv"
+	"strings"
+)
+
+const (
+	allowed = `:_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`
+)
+
+// If isPath is true:
+//   We remove redundant '/'s, the leading '/', and trailing '/'.
+//   If the result is empty, a '/' is inserted.
+//
+// We always:
+//  Replace the following characters with `\x%x`:
+//   Leading `.`
+//   `-`, `\`, and anything not in this set: `:-_.\[0-9a-zA-Z]`
+//  Replace '/' with '-'.
+func escape(unescaped string, isPath bool) string {
+	e := []byte{}
+	inSlashes := false
+	start := true
+	for i := 0; i < len(unescaped); i++ {
+		c := unescaped[i]
+		if isPath {
+			if c == '/' {
+				inSlashes = true
+				continue
+			} else if inSlashes {
+				inSlashes = false
+				if !start {
+					e = append(e, '-')
+				}
+			}
+		}
+
+		if c == '/' {
+			e = append(e, '-')
+		} else if start && c == '.' || strings.IndexByte(allowed, c) == -1 {
+			e = append(e, []byte(fmt.Sprintf(`\x%x`, c))...)
+		} else {
+			e = append(e, c)
+		}
+		start = false
+	}
+	if isPath && len(e) == 0 {
+		e = append(e, '-')
+	}
+	return string(e)
+}
+
+// If isPath is true:
+//   We always return a string beginning with '/'.
+//
+// We always:
+//  Replace '-' with '/'.
+//  Replace `\x%x` with the value represented in hex.
+func unescape(escaped string, isPath bool) string {
+	u := []byte{}
+	for i := 0; i < len(escaped); i++ {
+		c := escaped[i]
+		if c == '-' {
+			c = '/'
+		} else if c == '\\' && len(escaped)-i >= 4 && escaped[i+1] == 'x' {
+			n, err := strconv.ParseInt(escaped[i+2:i+4], 16, 8)
+			if err == nil {
+				c = byte(n)
+				i += 3
+			}
+		}
+		u = append(u, c)
+	}
+	if isPath && (len(u) == 0 || u[0] != '/') {
+		u = append([]byte("/"), u...)
+	}
+	return string(u)
+}
+
+// UnitNameEscape escapes a string as `systemd-escape` would
+func UnitNameEscape(unescaped string) string {
+	return escape(unescaped, false)
+}
+
+// UnitNameUnescape unescapes a string as `systemd-escape --unescape` would
+func UnitNameUnescape(escaped string) string {
+	return unescape(escaped, false)
+}
+
+// UnitNamePathEscape escapes a string as `systemd-escape --path` would
+func UnitNamePathEscape(unescaped string) string {
+	return escape(unescaped, true)
+}
+
+// UnitNamePathUnescape unescapes a string as `systemd-escape --path --unescape` would
+func UnitNamePathUnescape(escaped string) string {
+	return unescape(escaped, true)
+}
diff --git a/vendor/github.com/coreos/go-systemd/unit/option.go b/vendor/github.com/coreos/go-systemd/unit/option.go
new file mode 100644
index 00000000..98e1af5c
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/unit/option.go
@@ -0,0 +1,59 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package unit
+
+import (
+	"fmt"
+)
+
+// UnitOption represents an option in a systemd unit file.
+type UnitOption struct {
+	Section string
+	Name    string
+	Value   string
+}
+
+// NewUnitOption returns a new UnitOption instance with pre-set values.
+func NewUnitOption(section, name, value string) *UnitOption {
+	return &UnitOption{Section: section, Name: name, Value: value}
+}
+
+func (uo *UnitOption) String() string {
+	return fmt.Sprintf("{Section: %q, Name: %q, Value: %q}", uo.Section, uo.Name, uo.Value)
+}
+
+// Match compares two UnitOptions and returns true if they are identical.
+func (uo *UnitOption) Match(other *UnitOption) bool {
+	return uo.Section == other.Section &&
+		uo.Name == other.Name &&
+		uo.Value == other.Value
+}
+
+// AllMatch compares two slices of UnitOptions and returns true if they are
+// identical.
+func AllMatch(u1 []*UnitOption, u2 []*UnitOption) bool {
+	length := len(u1)
+	if length != len(u2) {
+		return false
+	}
+
+	for i := 0; i < length; i++ {
+		if !u1[i].Match(u2[i]) {
+			return false
+		}
+	}
+
+	return true
+}
diff --git a/vendor/github.com/coreos/go-systemd/unit/serialize.go b/vendor/github.com/coreos/go-systemd/unit/serialize.go
new file mode 100644
index 00000000..e07799ca
--- /dev/null
+++ b/vendor/github.com/coreos/go-systemd/unit/serialize.go
@@ -0,0 +1,75 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package unit
+
+import (
+	"bytes"
+	"io"
+)
+
+// Serialize encodes all of the given UnitOption objects into a
+// unit file. When serialized the options are sorted in their
+// supplied order but grouped by section.
+func Serialize(opts []*UnitOption) io.Reader {
+	var buf bytes.Buffer
+
+	if len(opts) == 0 {
+		return &buf
+	}
+
+	// Index of sections -> ordered options
+	idx := map[string][]*UnitOption{}
+	// Separately preserve order in which sections were seen
+	sections := []string{}
+	for _, opt := range opts {
+		sec := opt.Section
+		if _, ok := idx[sec]; !ok {
+			sections = append(sections, sec)
+		}
+		idx[sec] = append(idx[sec], opt)
+	}
+
+	for i, sect := range sections {
+		writeSectionHeader(&buf, sect)
+		writeNewline(&buf)
+
+		opts := idx[sect]
+		for _, opt := range opts {
+			writeOption(&buf, opt)
+			writeNewline(&buf)
+		}
+		if i < len(sections)-1 {
+			writeNewline(&buf)
+		}
+	}
+
+	return &buf
+}
+
+func writeNewline(buf *bytes.Buffer) {
+	buf.WriteRune('\n')
+}
+
+func writeSectionHeader(buf *bytes.Buffer, section string) {
+	buf.WriteRune('[')
+	buf.WriteString(section)
+	buf.WriteRune(']')
+}
+
+func writeOption(buf *bytes.Buffer, opt *UnitOption) {
+	buf.WriteString(opt.Name)
+	buf.WriteRune('=')
+	buf.WriteString(opt.Value)
+}
diff --git a/vendor/github.com/flatcar/ignition/LICENSE b/vendor/github.com/flatcar/ignition/LICENSE
new file mode 100644
index 00000000..e06d2081
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/LICENSE
@@ -0,0 +1,202 @@
+Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
diff --git a/vendor/github.com/flatcar/ignition/NOTICE b/vendor/github.com/flatcar/ignition/NOTICE
new file mode 100644
index 00000000..e520005c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/NOTICE
@@ -0,0 +1,5 @@
+CoreOS Project
+Copyright 2015 CoreOS, Inc
+
+This product includes software developed at CoreOS, Inc.
+(http://www.coreos.com/).
diff --git a/vendor/github.com/flatcar/ignition/config/shared/errors/errors.go b/vendor/github.com/flatcar/ignition/config/shared/errors/errors.go
new file mode 100644
index 00000000..f2b47cf9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/shared/errors/errors.go
@@ -0,0 +1,109 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package errors includes errors that are used in multiple config versions
+package errors
+
+import (
+	"errors"
+	"fmt"
+)
+
+var (
+	// Parsing / general errors
+	ErrInvalid            = errors.New("config is not valid")
+	ErrCloudConfig        = errors.New("not a config (found coreos-cloudconfig)")
+	ErrEmpty              = errors.New("not a config (empty)")
+	ErrUnknownVersion     = errors.New("unsupported config version")
+	ErrScript             = errors.New("not a config (found coreos-cloudinit script)")
+	ErrDeprecated         = errors.New("config format deprecated")
+	ErrCompressionInvalid = errors.New("invalid compression method")
+
+	// Ignition section errors
+	ErrOldVersion     = errors.New("incorrect config version (too old)")
+	ErrNewVersion     = errors.New("incorrect config version (too new)")
+	ErrInvalidVersion = errors.New("invalid config version (couldn't parse)")
+
+	// Storage section errors
+	ErrPermissionsUnset            = errors.New("permissions unset, defaulting to 0000")
+	ErrDiskDeviceRequired          = errors.New("disk device is required")
+	ErrPartitionNumbersCollide     = errors.New("partition numbers collide")
+	ErrPartitionsOverlap           = errors.New("partitions overlap")
+	ErrPartitionsMisaligned        = errors.New("partitions misaligned")
+	ErrAppendAndOverwrite          = errors.New("cannot set both append and overwrite to true")
+	ErrFilesystemInvalidFormat     = errors.New("invalid filesystem format")
+	ErrFilesystemNoMountPath       = errors.New("filesystem is missing mount or path")
+	ErrFilesystemMountAndPath      = errors.New("filesystem has both mount and path defined")
+	ErrUsedCreateAndMountOpts      = errors.New("cannot use both create object and mount-level options field")
+	ErrUsedCreateAndWipeFilesystem = errors.New("cannot use both create object and wipeFilesystem field")
+	ErrWarningCreateDeprecated     = errors.New("the create object has been deprecated in favor of mount-level options")
+	ErrExt4LabelTooLong            = errors.New("filesystem labels cannot be longer than 16 characters when using ext4")
+	ErrBtrfsLabelTooLong           = errors.New("filesystem labels cannot be longer than 256 characters when using btrfs")
+	ErrXfsLabelTooLong             = errors.New("filesystem labels cannot be longer than 12 characters when using xfs")
+	ErrSwapLabelTooLong            = errors.New("filesystem labels cannot be longer than 15 characters when using swap")
+	ErrVfatLabelTooLong            = errors.New("filesystem labels cannot be longer than 11 characters when using vfat")
+	ErrFileIllegalMode             = errors.New("illegal file mode")
+	ErrNoFilesystem                = errors.New("no filesystem specified")
+	ErrBothIDAndNameSet            = errors.New("cannot set both id and name")
+	ErrLabelTooLong                = errors.New("partition labels may not exceed 36 characters")
+	ErrDoesntMatchGUIDRegex        = errors.New("doesn't match the form \"01234567-89AB-CDEF-EDCB-A98765432101\"")
+	ErrLabelContainsColon          = errors.New("partition label will be truncated to text before the colon")
+	ErrPathRelative                = errors.New("path not absolute")
+	ErrSparesUnsupportedForLevel   = errors.New("spares unsupported for arrays with a level greater than 0")
+	ErrUnrecognizedRaidLevel       = errors.New("unrecognized raid level")
+	ErrShouldNotExistWithOthers    = errors.New("shouldExist specified false with other options also specified")
+	ErrZeroesWithShouldNotExist    = errors.New("shouldExist is false for a partition and other partition(s) has start or size 0")
+	ErrPartitionsUnitsMismatch     = errors.New("cannot mix MBs and sectors within a disk")
+	ErrSizeDeprecated              = errors.New("size is deprecated; use sizeMB instead")
+	ErrStartDeprecated             = errors.New("start is deprecated; use startMB instead")
+
+	// Passwd section errors
+	ErrPasswdCreateDeprecated      = errors.New("the create object has been deprecated in favor of user-level options")
+	ErrPasswdCreateAndGecos        = errors.New("cannot use both the create object and the user-level gecos field")
+	ErrPasswdCreateAndGroups       = errors.New("cannot use both the create object and the user-level groups field")
+	ErrPasswdCreateAndHomeDir      = errors.New("cannot use both the create object and the user-level homeDir field")
+	ErrPasswdCreateAndNoCreateHome = errors.New("cannot use both the create object and the user-level noCreateHome field")
+	ErrPasswdCreateAndNoLogInit    = errors.New("cannot use both the create object and the user-level noLogInit field")
+	ErrPasswdCreateAndNoUserGroup  = errors.New("cannot use both the create object and the user-level noUserGroup field")
+	ErrPasswdCreateAndPrimaryGroup = errors.New("cannot use both the create object and the user-level primaryGroup field")
+	ErrPasswdCreateAndShell        = errors.New("cannot use both the create object and the user-level shell field")
+	ErrPasswdCreateAndSystem       = errors.New("cannot use both the create object and the user-level system field")
+	ErrPasswdCreateAndUID          = errors.New("cannot use both the create object and the user-level uid field")
+
+	// Systemd and Networkd section errors
+	ErrInvalidSystemdExt        = errors.New("invalid systemd unit extension")
+	ErrInvalidSystemdDropinExt  = errors.New("invalid systemd drop-in extension")
+	ErrInvalidNetworkdExt       = errors.New("invalid networkd unit extension")
+	ErrInvalidNetworkdDropinExt = errors.New("invalid networkd drop-in extension")
+
+	// Misc errors
+	ErrInvalidScheme                   = errors.New("invalid url scheme")
+	ErrInvalidUrl                      = errors.New("unable to parse url")
+	ErrEmptyHTTPHeaderName             = errors.New("HTTP header name can't be empty")
+	ErrDuplicateHTTPHeaders            = errors.New("all header names in the list must be unique")
+	ErrUnsupportedSchemeForHTTPHeaders = errors.New("cannot use HTTP headers with this source scheme")
+	ErrHashMalformed                   = errors.New("malformed hash specifier")
+	ErrHashWrongSize                   = errors.New("incorrect size for hash sum")
+	ErrHashUnrecognized                = errors.New("unrecognized hash function")
+	ErrEngineConfiguration             = errors.New("engine incorrectly configured")
+
+	// AWS S3 specific errors
+	ErrInvalidS3ObjectVersionId = errors.New("invalid S3 object VersionId")
+)
+
+// NewNoInstallSectionError produces an error indicating the given unit, named
+// name, is missing an Install section.
+func NewNoInstallSectionError(name string) error {
+	return fmt.Errorf("unit %q is enabled, but has no install section so enable does nothing", name)
+}
diff --git a/vendor/github.com/flatcar/ignition/config/shared/validations/unit.go b/vendor/github.com/flatcar/ignition/config/shared/validations/unit.go
new file mode 100644
index 00000000..a7061dce
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/shared/validations/unit.go
@@ -0,0 +1,54 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package validations contains validations shared between multiple config
+// versions.
+package validations
+
+import (
+	"github.com/coreos/go-systemd/unit"
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+// ValidateInstallSection is a helper to validate a given unit
+func ValidateInstallSection(name string, enabled bool, contentsEmpty bool, contentSections []*unit.UnitOption) report.Report {
+	if !enabled {
+		// install sections don't matter for not-enabled units
+		return report.Report{}
+	}
+	if contentsEmpty {
+		// install sections don't matter if it has no contents, e.g. it's being masked or just has dropins or such
+		return report.Report{}
+	}
+	if contentSections == nil {
+		// Should only happen if the unit could not be parsed, at which point an
+		// error is probably already in the report so we don't need to double-up on
+		// errors + warnings.
+		return report.Report{}
+	}
+
+	for _, section := range contentSections {
+		if section.Section == "Install" {
+			return report.Report{}
+		}
+	}
+
+	return report.Report{
+		Entries: []report.Entry{{
+			Message: errors.NewNoInstallSectionError(name).Error(),
+			Kind:    report.EntryWarning,
+		}},
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/util/helpers.go b/vendor/github.com/flatcar/ignition/config/util/helpers.go
new file mode 100644
index 00000000..7d55548f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/util/helpers.go
@@ -0,0 +1,34 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+func IntToPtr(x int) *int {
+	return &x
+}
+
+func StrToPtr(s string) *string {
+	if s == "" {
+		return nil
+	}
+	return &s
+}
+
+func StrToPtrStrict(s string) *string {
+	return &s
+}
+
+func BoolToPtr(b bool) *bool {
+	return &b
+}
diff --git a/vendor/github.com/flatcar/ignition/config/util/parsingErrors.go b/vendor/github.com/flatcar/ignition/config/util/parsingErrors.go
new file mode 100644
index 00000000..170f20fe
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/util/parsingErrors.go
@@ -0,0 +1,74 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import (
+	"bytes"
+	"errors"
+
+	configErrors "github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v2_4/types"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+	"go4.org/errorutil"
+)
+
+var (
+	ErrValidConfig = errors.New("HandleParseErrors called with a valid config")
+)
+
+// HandleParseErrors will attempt to unmarshal an invalid rawConfig into the
+// latest config struct, so as to generate a report.Report from the errors. It
+// will always return an error. This is called after config/v* parse functions
+// chain has failed to parse a config.
+func HandleParseErrors(rawConfig []byte) (report.Report, error) {
+	config := types.Config{}
+	err := json.Unmarshal(rawConfig, &config)
+	if err == nil {
+		return report.Report{}, ErrValidConfig
+	}
+
+	// Handle json syntax and type errors first, since they are fatal but have offset info
+	if serr, ok := err.(*json.SyntaxError); ok {
+		line, col, highlight := errorutil.HighlightBytePosition(bytes.NewReader(rawConfig), serr.Offset)
+		return report.Report{
+				Entries: []report.Entry{{
+					Kind:      report.EntryError,
+					Message:   serr.Error(),
+					Line:      line,
+					Column:    col,
+					Highlight: highlight,
+				}},
+			},
+			configErrors.ErrInvalid
+	}
+
+	if terr, ok := err.(*json.UnmarshalTypeError); ok {
+		line, col, highlight := errorutil.HighlightBytePosition(bytes.NewReader(rawConfig), terr.Offset)
+		return report.Report{
+				Entries: []report.Entry{{
+					Kind:      report.EntryError,
+					Message:   terr.Error(),
+					Line:      line,
+					Column:    col,
+					Highlight: highlight,
+				}},
+			},
+			configErrors.ErrInvalid
+	}
+
+	return report.ReportFromError(err, report.EntryError), err
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v1/cloudinit.go
new file mode 100644
index 00000000..7cfeb455
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v1
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/config.go b/vendor/github.com/flatcar/ignition/config/v1/config.go
new file mode 100644
index 00000000..95803050
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/config.go
@@ -0,0 +1,59 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/util"
+	"github.com/flatcar/ignition/config/v1/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+)
+
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+	if err != nil {
+		rpt, err := util.HandleParseErrors(rawConfig)
+		// HandleParseErrors always returns an error
+		return types.Config{}, rpt, err
+	}
+
+	if config.Version != types.Version {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/config.go b/vendor/github.com/flatcar/ignition/config/v1/types/config.go
new file mode 100644
index 00000000..3a369e4f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/config.go
@@ -0,0 +1,35 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import "github.com/coreos/go-semver/semver"
+
+const (
+	Version = 1
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: Version,
+	}
+)
+
+type Config struct {
+	Version  int      `json:"ignitionVersion"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/disk.go b/vendor/github.com/flatcar/ignition/config/v1/types/disk.go
new file mode 100644
index 00000000..d1b04748
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/disk.go
@@ -0,0 +1,123 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Disk struct {
+	Device     Path        `json:"device,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+	Partitions []Partition `json:"partitions,omitempty"`
+}
+
+func (n Disk) Validate() report.Report {
+	r := report.Report{}
+	if len(n.Device) == 0 {
+		r.Add(report.Entry{
+			Kind:    report.EntryError,
+			Message: errors.ErrDiskDeviceRequired.Error(),
+		})
+	}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Kind:    report.EntryError,
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Kind:    report.EntryError,
+			Message: errors.ErrPartitionsOverlap.Error(),
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Kind:    report.EntryError,
+			Message: errors.ErrPartitionsMisaligned.Error(),
+		})
+	}
+	// Disks which get to this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		m[p.Number] = append(m[p.Number], p)
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition.
+func (p Partition) end() PartitionDimension {
+	if p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return p.Start
+	}
+	return p.Start + p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if p == o || o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if p.Start >= o.Start && p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if p.Start < o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if (p.Start & (2048 - 1)) != 0 {
+			return true
+		}
+	}
+	return false
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/file.go b/vendor/github.com/flatcar/ignition/config/v1/types/file.go
new file mode 100644
index 00000000..a77bba3a
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/file.go
@@ -0,0 +1,39 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"os"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type FileMode os.FileMode
+
+type File struct {
+	Path     Path     `json:"path,omitempty"`
+	Contents string   `json:"contents,omitempty"`
+	Mode     FileMode `json:"mode,omitempty"`
+	Uid      int      `json:"uid,omitempty"`
+	Gid      int      `json:"gid,omitempty"`
+}
+
+func (m FileMode) Validate() report.Report {
+	if (m &^ 07777) != 0 {
+		return report.ReportFromError(errors.ErrFileIllegalMode, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v1/types/filesystem.go
new file mode 100644
index 00000000..5cfbe095
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/filesystem.go
@@ -0,0 +1,45 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Filesystem struct {
+	Device Path              `json:"device,omitempty"`
+	Format FilesystemFormat  `json:"format,omitempty"`
+	Create *FilesystemCreate `json:"create,omitempty"`
+	Files  []File            `json:"files,omitempty"`
+}
+
+type FilesystemCreate struct {
+	Force   bool        `json:"force,omitempty"`
+	Options MkfsOptions `json:"options,omitempty"`
+}
+
+type FilesystemFormat string
+
+func (f FilesystemFormat) Validate() report.Report {
+	switch f {
+	case "ext4", "btrfs", "xfs":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrFilesystemInvalidFormat, report.EntryError)
+	}
+}
+
+type MkfsOptions []string
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/group.go b/vendor/github.com/flatcar/ignition/config/v1/types/group.go
new file mode 100644
index 00000000..27e51048
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/group.go
@@ -0,0 +1,22 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Group struct {
+	Name         string `json:"name,omitempty"`
+	Gid          *uint  `json:"gid,omitempty"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/networkd.go b/vendor/github.com/flatcar/ignition/config/v1/types/networkd.go
new file mode 100644
index 00000000..470c7211
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/networkd.go
@@ -0,0 +1,19 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Networkd struct {
+	Units []NetworkdUnit `json:"units,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/partition.go b/vendor/github.com/flatcar/ignition/config/v1/types/partition.go
new file mode 100644
index 00000000..c84091ac
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/partition.go
@@ -0,0 +1,60 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Partition struct {
+	Label    PartitionLabel     `json:"label,omitempty"`
+	Number   int                `json:"number"`
+	Size     PartitionDimension `json:"size"`
+	Start    PartitionDimension `json:"start"`
+	TypeGUID PartitionTypeGUID  `json:"typeGuid,omitempty"`
+}
+
+type PartitionLabel string
+
+func (n PartitionLabel) Validate() report.Report {
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(string(n)) > 36 {
+		return report.ReportFromError(errors.ErrLabelTooLong, report.EntryError)
+	}
+	return report.Report{}
+}
+
+type PartitionDimension uint64
+
+type PartitionTypeGUID string
+
+func (d PartitionTypeGUID) Validate() report.Report {
+	ok, err := regexp.MatchString("^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$", string(d))
+	if err != nil {
+		return report.ReportFromError(fmt.Errorf("error matching type-guid regexp: %v", err), report.EntryError)
+	}
+	if !ok {
+		return report.ReportFromError(fmt.Errorf(`partition type-guid must have the form "01234567-89AB-CDEF-EDCB-A98765432101", got: %q`, string(d)), report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v1/types/passwd.go
new file mode 100644
index 00000000..0ffff43b
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/passwd.go
@@ -0,0 +1,20 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Passwd struct {
+	Users  []User  `json:"users,omitempty"`
+	Groups []Group `json:"groups,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/path.go b/vendor/github.com/flatcar/ignition/config/v1/types/path.go
new file mode 100644
index 00000000..5d94af95
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/path.go
@@ -0,0 +1,31 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Path string
+
+func (d Path) Validate() report.Report {
+	if !path.IsAbs(string(d)) {
+		return report.ReportFromError(errors.ErrPathRelative, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/raid.go b/vendor/github.com/flatcar/ignition/config/v1/types/raid.go
new file mode 100644
index 00000000..ca995cf9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/raid.go
@@ -0,0 +1,44 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Raid struct {
+	Name    string `json:"name"`
+	Level   string `json:"level"`
+	Devices []Path `json:"devices,omitempty"`
+	Spares  int    `json:"spares,omitempty"`
+}
+
+func (n Raid) Validate() report.Report {
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			return report.ReportFromError(errors.ErrSparesUnsupportedForLevel, report.EntryError)
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		return report.ReportFromError(errors.ErrUnrecognizedRaidLevel, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/storage.go b/vendor/github.com/flatcar/ignition/config/v1/types/storage.go
new file mode 100644
index 00000000..2649751a
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/storage.go
@@ -0,0 +1,21 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Storage struct {
+	Disks       []Disk       `json:"disks,omitempty"`
+	Arrays      []Raid       `json:"raid,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/systemd.go b/vendor/github.com/flatcar/ignition/config/v1/types/systemd.go
new file mode 100644
index 00000000..97194b91
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/systemd.go
@@ -0,0 +1,19 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Systemd struct {
+	Units []SystemdUnit `json:"units,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/unit.go b/vendor/github.com/flatcar/ignition/config/v1/types/unit.go
new file mode 100644
index 00000000..e1e5510c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/unit.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type SystemdUnit struct {
+	Name     SystemdUnitName     `json:"name,omitempty"`
+	Enable   bool                `json:"enable,omitempty"`
+	Mask     bool                `json:"mask,omitempty"`
+	Contents string              `json:"contents,omitempty"`
+	DropIns  []SystemdUnitDropIn `json:"dropins,omitempty"`
+}
+
+type SystemdUnitDropIn struct {
+	Name     SystemdUnitDropInName `json:"name,omitempty"`
+	Contents string                `json:"contents,omitempty"`
+}
+
+type SystemdUnitName string
+
+func (n SystemdUnitName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidSystemdExt, report.EntryError)
+	}
+}
+
+type SystemdUnitDropInName string
+
+func (n SystemdUnitDropInName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".conf":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidSystemdDropinExt, report.EntryError)
+	}
+}
+
+type NetworkdUnit struct {
+	Name     NetworkdUnitName `json:"name,omitempty"`
+	Contents string           `json:"contents,omitempty"`
+}
+
+type NetworkdUnitName string
+
+func (n NetworkdUnitName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".link", ".netdev", ".network":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidNetworkdExt, report.EntryError)
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v1/types/user.go b/vendor/github.com/flatcar/ignition/config/v1/types/user.go
new file mode 100644
index 00000000..f6653e27
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v1/types/user.go
@@ -0,0 +1,35 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type User struct {
+	Name              string      `json:"name,omitempty"`
+	PasswordHash      string      `json:"passwordHash,omitempty"`
+	SSHAuthorizedKeys []string    `json:"sshAuthorizedKeys,omitempty"`
+	Create            *UserCreate `json:"create,omitempty"`
+}
+
+type UserCreate struct {
+	Uid          *uint    `json:"uid,omitempty"`
+	GECOS        string   `json:"gecos,omitempty"`
+	Homedir      string   `json:"homeDir,omitempty"`
+	NoCreateHome bool     `json:"noCreateHome,omitempty"`
+	PrimaryGroup string   `json:"primaryGroup,omitempty"`
+	Groups       []string `json:"groups,omitempty"`
+	NoUserGroup  bool     `json:"noUserGroup,omitempty"`
+	System       bool     `json:"system,omitempty"`
+	NoLogInit    bool     `json:"noLogInit,omitempty"`
+	Shell        string   `json:"shell,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/append.go b/vendor/github.com/flatcar/ignition/config/v2_0/append.go
new file mode 100644
index 00000000..aca0ebbf
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/append.go
@@ -0,0 +1,76 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_0
+
+import (
+	"reflect"
+
+	"github.com/flatcar/ignition/config/v2_0/types"
+)
+
+// Append appends newConfig to oldConfig and returns the result. Appending one
+// config to another is accomplished by iterating over every field in the
+// config structure, appending slices, recursively appending structs, and
+// overwriting old values with new values for all other types.
+func Append(oldConfig, newConfig types.Config) types.Config {
+	vOld := reflect.ValueOf(oldConfig)
+	vNew := reflect.ValueOf(newConfig)
+
+	vResult := appendStruct(vOld, vNew)
+
+	return vResult.Interface().(types.Config)
+}
+
+// appendStruct is an internal helper function to AppendConfig. Given two values
+// of structures (assumed to be the same type), recursively iterate over every
+// field in the struct, appending slices, recursively appending structs, and
+// overwriting old values with the new for all other types. Some individual
+// struct fields have alternate merge strategies, determined by the field name.
+// Currently these fields are "ignition.version", which uses the old value, and
+// "ignition.config" which uses the new value.
+func appendStruct(vOld, vNew reflect.Value) reflect.Value {
+	tOld := vOld.Type()
+	vRes := reflect.New(tOld)
+
+	for i := 0; i < tOld.NumField(); i++ {
+		vfOld := vOld.Field(i)
+		vfNew := vNew.Field(i)
+		vfRes := vRes.Elem().Field(i)
+
+		switch tOld.Field(i).Name {
+		case "Version":
+			vfRes.Set(vfOld)
+			continue
+		case "Config":
+			vfRes.Set(vfNew)
+			continue
+		}
+
+		switch vfOld.Type().Kind() {
+		case reflect.Struct:
+			vfRes.Set(appendStruct(vfOld, vfNew))
+		case reflect.Slice:
+			vfRes.Set(reflect.AppendSlice(vfOld, vfNew))
+		default:
+			if vfNew.Kind() == reflect.Ptr && vfNew.IsNil() {
+				vfRes.Set(vfOld)
+			} else {
+				vfRes.Set(vfNew)
+			}
+		}
+	}
+
+	return vRes.Elem()
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v2_0/cloudinit.go
new file mode 100644
index 00000000..9e1f2ad0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v2_0
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/config.go b/vendor/github.com/flatcar/ignition/config/v2_0/config.go
new file mode 100644
index 00000000..dcb8e7bd
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/config.go
@@ -0,0 +1,70 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_0
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v1"
+	"github.com/flatcar/ignition/config/v2_0/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/coreos/go-semver/semver"
+)
+
+// Parse parses the raw config into a types.Config struct and generates a report of any
+// errors, warnings, info, and deprecations it encountered
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+
+	if err != nil || semver.Version(config.Ignition.Version).LessThan(types.MaxVersion) {
+		// We can fail unmarshaling if it's an older config. Attempt to parse
+		// it as such.
+		config, rpt, err := v1.Parse(rawConfig)
+		if err != nil {
+			return types.Config{}, rpt, err
+		}
+
+		rpt.Merge(report.ReportFromError(errors.ErrDeprecated, report.EntryDeprecated))
+		return TranslateFromV1(config), rpt, err
+	}
+
+	if semver.Version(config.Ignition.Version) != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/translate.go b/vendor/github.com/flatcar/ignition/config/v2_0/translate.go
new file mode 100644
index 00000000..f7b89c41
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/translate.go
@@ -0,0 +1,173 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_0
+
+import (
+	"fmt"
+
+	v1 "github.com/flatcar/ignition/config/v1/types"
+	"github.com/flatcar/ignition/config/v2_0/types"
+	"github.com/vincent-petithory/dataurl"
+)
+
+func TranslateFromV1(old v1.Config) types.Config {
+	config := types.Config{
+		Ignition: types.Ignition{
+			Version: types.IgnitionVersion(types.MaxVersion),
+		},
+	}
+
+	for _, oldDisk := range old.Storage.Disks {
+		disk := types.Disk{
+			Device:    types.Path(oldDisk.Device),
+			WipeTable: oldDisk.WipeTable,
+		}
+
+		for _, oldPartition := range oldDisk.Partitions {
+			disk.Partitions = append(disk.Partitions, types.Partition{
+				Label:    types.PartitionLabel(oldPartition.Label),
+				Number:   oldPartition.Number,
+				Size:     types.PartitionDimension(oldPartition.Size),
+				Start:    types.PartitionDimension(oldPartition.Start),
+				TypeGUID: types.PartitionTypeGUID(oldPartition.TypeGUID),
+			})
+		}
+
+		config.Storage.Disks = append(config.Storage.Disks, disk)
+	}
+
+	for _, oldArray := range old.Storage.Arrays {
+		array := types.Raid{
+			Name:   oldArray.Name,
+			Level:  oldArray.Level,
+			Spares: oldArray.Spares,
+		}
+
+		for _, oldDevice := range oldArray.Devices {
+			array.Devices = append(array.Devices, types.Path(oldDevice))
+		}
+
+		config.Storage.Arrays = append(config.Storage.Arrays, array)
+	}
+
+	for i, oldFilesystem := range old.Storage.Filesystems {
+		filesystem := types.Filesystem{
+			Name: fmt.Sprintf("_translate-filesystem-%d", i),
+			Mount: &types.FilesystemMount{
+				Device: types.Path(oldFilesystem.Device),
+				Format: types.FilesystemFormat(oldFilesystem.Format),
+			},
+		}
+
+		if oldFilesystem.Create != nil {
+			filesystem.Mount.Create = &types.FilesystemCreate{
+				Force:   oldFilesystem.Create.Force,
+				Options: types.MkfsOptions(oldFilesystem.Create.Options),
+			}
+		}
+
+		config.Storage.Filesystems = append(config.Storage.Filesystems, filesystem)
+
+		for _, oldFile := range oldFilesystem.Files {
+			file := types.File{
+				Filesystem: filesystem.Name,
+				Path:       types.Path(oldFile.Path),
+				User:       types.FileUser{Id: oldFile.Uid},
+				Group:      types.FileGroup{Id: oldFile.Gid},
+				Mode:       types.FileMode(oldFile.Mode),
+				Contents: types.FileContents{
+					Source: types.Url{
+						Scheme: "data",
+						Opaque: "," + dataurl.EscapeString(oldFile.Contents),
+					},
+				},
+			}
+
+			config.Storage.Files = append(config.Storage.Files, file)
+		}
+	}
+
+	for _, oldUnit := range old.Systemd.Units {
+		unit := types.SystemdUnit{
+			Name:     types.SystemdUnitName(oldUnit.Name),
+			Enable:   oldUnit.Enable,
+			Mask:     oldUnit.Mask,
+			Contents: oldUnit.Contents,
+		}
+
+		for _, oldDropIn := range oldUnit.DropIns {
+			unit.DropIns = append(unit.DropIns, types.SystemdUnitDropIn{
+				Name:     types.SystemdUnitDropInName(oldDropIn.Name),
+				Contents: oldDropIn.Contents,
+			})
+		}
+
+		config.Systemd.Units = append(config.Systemd.Units, unit)
+	}
+
+	for _, oldUnit := range old.Networkd.Units {
+		config.Networkd.Units = append(config.Networkd.Units, types.NetworkdUnit{
+			Name:     types.NetworkdUnitName(oldUnit.Name),
+			Contents: oldUnit.Contents,
+		})
+	}
+
+	for _, oldUser := range old.Passwd.Users {
+		user := types.User{
+			Name:              oldUser.Name,
+			PasswordHash:      oldUser.PasswordHash,
+			SSHAuthorizedKeys: oldUser.SSHAuthorizedKeys,
+		}
+
+		if oldUser.Create != nil {
+			var uid *uint
+			if oldUser.Create.Uid != nil {
+				tmp := uint(*oldUser.Create.Uid)
+				uid = &tmp
+			}
+
+			user.Create = &types.UserCreate{
+				Uid:          uid,
+				GECOS:        oldUser.Create.GECOS,
+				Homedir:      oldUser.Create.Homedir,
+				NoCreateHome: oldUser.Create.NoCreateHome,
+				PrimaryGroup: oldUser.Create.PrimaryGroup,
+				Groups:       oldUser.Create.Groups,
+				NoUserGroup:  oldUser.Create.NoUserGroup,
+				System:       oldUser.Create.System,
+				NoLogInit:    oldUser.Create.NoLogInit,
+				Shell:        oldUser.Create.Shell,
+			}
+		}
+
+		config.Passwd.Users = append(config.Passwd.Users, user)
+	}
+
+	for _, oldGroup := range old.Passwd.Groups {
+		var gid *uint
+		if oldGroup.Gid != nil {
+			tmp := uint(*oldGroup.Gid)
+			gid = &tmp
+		}
+		config.Passwd.Groups = append(config.Passwd.Groups, types.Group{
+			Name:         oldGroup.Name,
+			Gid:          gid,
+			PasswordHash: oldGroup.PasswordHash,
+			System:       oldGroup.System,
+		})
+	}
+
+	return config
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/compression.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/compression.go
new file mode 100644
index 00000000..3bc7299f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/compression.go
@@ -0,0 +1,31 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Compression string
+
+func (c Compression) Validate() report.Report {
+	switch c {
+	case "", "gzip":
+	default:
+		return report.ReportFromError(errors.ErrCompressionInvalid, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/config.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/config.go
new file mode 100644
index 00000000..208de491
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/config.go
@@ -0,0 +1,87 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 2,
+		Minor: 0,
+	}
+)
+
+type Config struct {
+	Ignition Ignition `json:"ignition"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+}
+
+func (c Config) Validate() report.Report {
+	r := report.Report{}
+	rules := []rule{
+		checkFilesFilesystems,
+		checkDuplicateFilesystems,
+	}
+
+	for _, rule := range rules {
+		rule(c, &r)
+	}
+	return r
+}
+
+type rule func(cfg Config, report *report.Report)
+
+func checkFilesFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		filesystems[filesystem.Name] = struct{}{}
+	}
+	for _, file := range cfg.Storage.Files {
+		if file.Filesystem == "" {
+			// Filesystem was not specified. This is an error, but its handled in types.File's Validate, not here
+			continue
+		}
+		_, ok := filesystems[file.Filesystem]
+		if !ok {
+			r.Add(report.Entry{
+				Kind: report.EntryWarning,
+				Message: fmt.Sprintf("File %q references nonexistent filesystem %q. (This is ok if it is defined in a referenced config)",
+					file.Path, file.Filesystem),
+			})
+		}
+	}
+}
+
+func checkDuplicateFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		if _, ok := filesystems[filesystem.Name]; ok {
+			r.Add(report.Entry{
+				Kind:    report.EntryWarning,
+				Message: fmt.Sprintf("Filesystem %q shadows exising filesystem definition", filesystem.Name),
+			})
+		}
+		filesystems[filesystem.Name] = struct{}{}
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/disk.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/disk.go
new file mode 100644
index 00000000..fa508fe0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/disk.go
@@ -0,0 +1,126 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Disk struct {
+	Device     Path        `json:"device,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+	Partitions []Partition `json:"partitions,omitempty"`
+}
+
+func (n Disk) Validate() report.Report {
+	r := report.Report{}
+	if len(n.Device) == 0 {
+		r.Add(report.Entry{
+			Message: errors.ErrDiskDeviceRequired.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsOverlap.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsMisaligned.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	// Disks which have no errors at this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], p)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition.
+func (p Partition) end() PartitionDimension {
+	if p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return p.Start
+	}
+	return p.Start + p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if p == o || o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if p.Start >= o.Start && p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if p.Start < o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if (p.Start & (2048 - 1)) != 0 {
+			return true
+		}
+	}
+	return false
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/file.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/file.go
new file mode 100644
index 00000000..75022732
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/file.go
@@ -0,0 +1,61 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"os"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type File struct {
+	Filesystem string       `json:"filesystem,omitempty"`
+	Path       Path         `json:"path,omitempty"`
+	Contents   FileContents `json:"contents,omitempty"`
+	Mode       FileMode     `json:"mode,omitempty"`
+	User       FileUser     `json:"user,omitempty"`
+	Group      FileGroup    `json:"group,omitempty"`
+}
+
+func (f File) Validate() report.Report {
+	if f.Filesystem == "" {
+		return report.ReportFromError(errors.ErrNoFilesystem, report.EntryError)
+	}
+	return report.Report{}
+}
+
+type FileUser struct {
+	Id int `json:"id,omitempty"`
+}
+
+type FileGroup struct {
+	Id int `json:"id,omitempty"`
+}
+
+type FileContents struct {
+	Compression  Compression  `json:"compression,omitempty"`
+	Source       Url          `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type FileMode os.FileMode
+
+func (m FileMode) Validate() report.Report {
+	if (m &^ 07777) != 0 {
+		return report.ReportFromError(errors.ErrFileIllegalMode, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/filesystem.go
new file mode 100644
index 00000000..8967918e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/filesystem.go
@@ -0,0 +1,60 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Filesystem struct {
+	Name  string           `json:"name,omitempty"`
+	Mount *FilesystemMount `json:"mount,omitempty"`
+	Path  *Path            `json:"path,omitempty"`
+}
+
+type FilesystemMount struct {
+	Device Path              `json:"device,omitempty"`
+	Format FilesystemFormat  `json:"format,omitempty"`
+	Create *FilesystemCreate `json:"create,omitempty"`
+}
+
+type FilesystemCreate struct {
+	Force   bool        `json:"force,omitempty"`
+	Options MkfsOptions `json:"options,omitempty"`
+}
+
+func (f Filesystem) Validate() report.Report {
+	if f.Mount == nil && f.Path == nil {
+		return report.ReportFromError(errors.ErrFilesystemNoMountPath, report.EntryError)
+	}
+	if f.Mount != nil && f.Path != nil {
+		return report.ReportFromError(errors.ErrFilesystemMountAndPath, report.EntryError)
+	}
+	return report.Report{}
+}
+
+type FilesystemFormat string
+
+func (f FilesystemFormat) Validate() report.Report {
+	switch f {
+	case "ext4", "btrfs", "xfs":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrFilesystemInvalidFormat, report.EntryError)
+	}
+}
+
+type MkfsOptions []string
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/group.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/group.go
new file mode 100644
index 00000000..27e51048
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/group.go
@@ -0,0 +1,22 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Group struct {
+	Name         string `json:"name,omitempty"`
+	Gid          *uint  `json:"gid,omitempty"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/hash.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/hash.go
new file mode 100644
index 00000000..ae0edce6
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/hash.go
@@ -0,0 +1,72 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"encoding/json"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Hash struct {
+	Function string
+	Sum      string
+}
+
+func (h *Hash) UnmarshalJSON(data []byte) error {
+	var th string
+	if err := json.Unmarshal(data, &th); err != nil {
+		return err
+	}
+
+	parts := strings.SplitN(th, "-", 2)
+	if len(parts) != 2 {
+		return errors.ErrHashMalformed
+	}
+
+	h.Function = parts[0]
+	h.Sum = parts[1]
+
+	return nil
+}
+
+func (h Hash) MarshalJSON() ([]byte, error) {
+	return []byte(`"` + h.Function + "-" + h.Sum + `"`), nil
+}
+
+func (h Hash) String() string {
+	bytes, _ := h.MarshalJSON()
+	return string(bytes)
+}
+
+func (h Hash) Validate() report.Report {
+	var hash crypto.Hash
+	switch h.Function {
+	case "sha512":
+		hash = crypto.SHA512
+	default:
+		return report.ReportFromError(errors.ErrHashUnrecognized, report.EntryError)
+	}
+
+	if len(h.Sum) != hex.EncodedLen(hash.Size()) {
+		return report.ReportFromError(errors.ErrHashWrongSize, report.EntryError)
+	}
+
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/ignition.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/ignition.go
new file mode 100644
index 00000000..d337225f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/ignition.go
@@ -0,0 +1,64 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"encoding/json"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Ignition struct {
+	Version IgnitionVersion `json:"version,omitempty" merge:"old"`
+	Config  IgnitionConfig  `json:"config,omitempty"  merge:"new"`
+}
+
+type IgnitionConfig struct {
+	Append  []ConfigReference `json:"append,omitempty"`
+	Replace *ConfigReference  `json:"replace,omitempty"`
+}
+
+type ConfigReference struct {
+	Source       Url          `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type IgnitionVersion semver.Version
+
+func (v *IgnitionVersion) UnmarshalJSON(data []byte) error {
+	tv := semver.Version(*v)
+	if err := json.Unmarshal(data, &tv); err != nil {
+		return err
+	}
+	*v = IgnitionVersion(tv)
+	return nil
+}
+
+func (v IgnitionVersion) MarshalJSON() ([]byte, error) {
+	return semver.Version(v).MarshalJSON()
+}
+
+func (v IgnitionVersion) Validate() report.Report {
+	if MaxVersion.Major > v.Major {
+		return report.ReportFromError(errors.ErrOldVersion, report.EntryError)
+	}
+	if MaxVersion.LessThan(semver.Version(v)) {
+		return report.ReportFromError(errors.ErrNewVersion, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/networkd.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/networkd.go
new file mode 100644
index 00000000..470c7211
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/networkd.go
@@ -0,0 +1,19 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Networkd struct {
+	Units []NetworkdUnit `json:"units,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/partition.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/partition.go
new file mode 100644
index 00000000..37c09577
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/partition.go
@@ -0,0 +1,64 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Partition struct {
+	Label    PartitionLabel     `json:"label,omitempty"`
+	Number   int                `json:"number"`
+	Size     PartitionDimension `json:"size"`
+	Start    PartitionDimension `json:"start"`
+	TypeGUID PartitionTypeGUID  `json:"typeGuid,omitempty"`
+}
+
+type PartitionLabel string
+
+func (n PartitionLabel) Validate() report.Report {
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(string(n)) > 36 {
+		return report.ReportFromError(errors.ErrLabelTooLong, report.EntryError)
+	}
+	if strings.Contains(string(n), ":") {
+		return report.ReportFromError(errors.ErrLabelContainsColon, report.EntryWarning)
+	}
+	return report.Report{}
+}
+
+type PartitionDimension uint64
+
+type PartitionTypeGUID string
+
+func (d PartitionTypeGUID) Validate() report.Report {
+	ok, err := regexp.MatchString("^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$", string(d))
+	if err != nil {
+		return report.ReportFromError(fmt.Errorf("error matching type-guid regexp: %v", err), report.EntryError)
+	}
+	if !ok {
+		return report.ReportFromError(errors.ErrDoesntMatchGUIDRegex, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/passwd.go
new file mode 100644
index 00000000..0ffff43b
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/passwd.go
@@ -0,0 +1,20 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Passwd struct {
+	Users  []User  `json:"users,omitempty"`
+	Groups []Group `json:"groups,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/path.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/path.go
new file mode 100644
index 00000000..235fc03f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/path.go
@@ -0,0 +1,35 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Path string
+
+func (p Path) MarshalJSON() ([]byte, error) {
+	return []byte(`"` + string(p) + `"`), nil
+}
+
+func (p Path) Validate() report.Report {
+	if !path.IsAbs(string(p)) {
+		return report.ReportFromError(errors.ErrPathRelative, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/raid.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/raid.go
new file mode 100644
index 00000000..ca995cf9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/raid.go
@@ -0,0 +1,44 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Raid struct {
+	Name    string `json:"name"`
+	Level   string `json:"level"`
+	Devices []Path `json:"devices,omitempty"`
+	Spares  int    `json:"spares,omitempty"`
+}
+
+func (n Raid) Validate() report.Report {
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			return report.ReportFromError(errors.ErrSparesUnsupportedForLevel, report.EntryError)
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		return report.ReportFromError(errors.ErrUnrecognizedRaidLevel, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/storage.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/storage.go
new file mode 100644
index 00000000..bd734377
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/storage.go
@@ -0,0 +1,22 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Storage struct {
+	Disks       []Disk       `json:"disks,omitempty"`
+	Arrays      []Raid       `json:"raid,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/systemd.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/systemd.go
new file mode 100644
index 00000000..97194b91
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/systemd.go
@@ -0,0 +1,19 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Systemd struct {
+	Units []SystemdUnit `json:"units,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/unit.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/unit.go
new file mode 100644
index 00000000..1e6ef2b0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/unit.go
@@ -0,0 +1,115 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"path"
+	"strings"
+
+	"github.com/coreos/go-systemd/unit"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/shared/validations"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type SystemdUnit struct {
+	Name     SystemdUnitName     `json:"name,omitempty"`
+	Enable   bool                `json:"enable,omitempty"`
+	Mask     bool                `json:"mask,omitempty"`
+	Contents string              `json:"contents,omitempty"`
+	DropIns  []SystemdUnitDropIn `json:"dropins,omitempty"`
+}
+
+func (u SystemdUnit) Validate() report.Report {
+	r := report.Report{}
+	opts, err := validateUnitContent(u.Contents)
+	if err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+
+	r.Merge(validations.ValidateInstallSection(string(u.Name), u.Enable, u.Contents == "", opts))
+
+	return r
+}
+
+type SystemdUnitDropIn struct {
+	Name     SystemdUnitDropInName `json:"name,omitempty"`
+	Contents string                `json:"contents,omitempty"`
+}
+
+func (u SystemdUnitDropIn) Validate() report.Report {
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+
+	return report.Report{}
+}
+
+type SystemdUnitName string
+
+func (n SystemdUnitName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidSystemdExt, report.EntryError)
+	}
+}
+
+type SystemdUnitDropInName string
+
+func (n SystemdUnitDropInName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".conf":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidSystemdDropinExt, report.EntryError)
+	}
+}
+
+type NetworkdUnit struct {
+	Name     NetworkdUnitName `json:"name,omitempty"`
+	Contents string           `json:"contents,omitempty"`
+}
+
+func (u NetworkdUnit) Validate() report.Report {
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+
+	return report.Report{}
+}
+
+type NetworkdUnitName string
+
+func (n NetworkdUnitName) Validate() report.Report {
+	switch path.Ext(string(n)) {
+	case ".link", ".netdev", ".network":
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidNetworkdExt, report.EntryError)
+	}
+}
+
+func validateUnitContent(content string) ([]*unit.UnitOption, error) {
+	c := strings.NewReader(content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/url.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/url.go
new file mode 100644
index 00000000..01d82e8c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/url.go
@@ -0,0 +1,69 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"encoding/json"
+	"net/url"
+
+	"github.com/vincent-petithory/dataurl"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type Url url.URL
+
+func (u *Url) UnmarshalJSON(data []byte) error {
+	var tu string
+	if err := json.Unmarshal(data, &tu); err != nil {
+		return err
+	}
+
+	pu, err := url.Parse(tu)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	*u = Url(*pu)
+	return nil
+}
+
+func (u Url) MarshalJSON() ([]byte, error) {
+	return []byte(`"` + u.String() + `"`), nil
+}
+
+func (u Url) String() string {
+	tu := url.URL(u)
+	return (&tu).String()
+}
+
+func (u Url) Validate() report.Report {
+	// Empty url is valid, indicates an empty file
+	if u.String() == "" {
+		return report.Report{}
+	}
+	switch url.URL(u).Scheme {
+	case "http", "https", "oem":
+		return report.Report{}
+	case "data":
+		if _, err := dataurl.DecodeString(u.String()); err != nil {
+			return report.ReportFromError(err, report.EntryError)
+		}
+		return report.Report{}
+	default:
+		return report.ReportFromError(errors.ErrInvalidScheme, report.EntryError)
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/user.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/user.go
new file mode 100644
index 00000000..f6653e27
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/user.go
@@ -0,0 +1,35 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type User struct {
+	Name              string      `json:"name,omitempty"`
+	PasswordHash      string      `json:"passwordHash,omitempty"`
+	SSHAuthorizedKeys []string    `json:"sshAuthorizedKeys,omitempty"`
+	Create            *UserCreate `json:"create,omitempty"`
+}
+
+type UserCreate struct {
+	Uid          *uint    `json:"uid,omitempty"`
+	GECOS        string   `json:"gecos,omitempty"`
+	Homedir      string   `json:"homeDir,omitempty"`
+	NoCreateHome bool     `json:"noCreateHome,omitempty"`
+	PrimaryGroup string   `json:"primaryGroup,omitempty"`
+	Groups       []string `json:"groups,omitempty"`
+	NoUserGroup  bool     `json:"noUserGroup,omitempty"`
+	System       bool     `json:"system,omitempty"`
+	NoLogInit    bool     `json:"noLogInit,omitempty"`
+	Shell        string   `json:"shell,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_0/types/verification.go b/vendor/github.com/flatcar/ignition/config/v2_0/types/verification.go
new file mode 100644
index 00000000..b7cef403
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_0/types/verification.go
@@ -0,0 +1,19 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+type Verification struct {
+	Hash *Hash `json:"hash,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/append.go b/vendor/github.com/flatcar/ignition/config/v2_1/append.go
new file mode 100644
index 00000000..c4257dab
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/append.go
@@ -0,0 +1,76 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_1
+
+import (
+	"reflect"
+
+	"github.com/flatcar/ignition/config/v2_1/types"
+)
+
+// Append appends newConfig to oldConfig and returns the result. Appending one
+// config to another is accomplished by iterating over every field in the
+// config structure, appending slices, recursively appending structs, and
+// overwriting old values with new values for all other types.
+func Append(oldConfig, newConfig types.Config) types.Config {
+	vOld := reflect.ValueOf(oldConfig)
+	vNew := reflect.ValueOf(newConfig)
+
+	vResult := appendStruct(vOld, vNew)
+
+	return vResult.Interface().(types.Config)
+}
+
+// appendStruct is an internal helper function to AppendConfig. Given two values
+// of structures (assumed to be the same type), recursively iterate over every
+// field in the struct, appending slices, recursively appending structs, and
+// overwriting old values with the new for all other types. Some individual
+// struct fields have alternate merge strategies, determined by the field name.
+// Currently these fields are "ignition.version", which uses the old value, and
+// "ignition.config" which uses the new value.
+func appendStruct(vOld, vNew reflect.Value) reflect.Value {
+	tOld := vOld.Type()
+	vRes := reflect.New(tOld)
+
+	for i := 0; i < tOld.NumField(); i++ {
+		vfOld := vOld.Field(i)
+		vfNew := vNew.Field(i)
+		vfRes := vRes.Elem().Field(i)
+
+		switch tOld.Field(i).Name {
+		case "Version":
+			vfRes.Set(vfOld)
+			continue
+		case "Config":
+			vfRes.Set(vfNew)
+			continue
+		}
+
+		switch vfOld.Type().Kind() {
+		case reflect.Struct:
+			vfRes.Set(appendStruct(vfOld, vfNew))
+		case reflect.Slice:
+			vfRes.Set(reflect.AppendSlice(vfOld, vfNew))
+		default:
+			if vfNew.Kind() == reflect.Ptr && vfNew.IsNil() {
+				vfRes.Set(vfOld)
+			} else {
+				vfRes.Set(vfNew)
+			}
+		}
+	}
+
+	return vRes.Elem()
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v2_1/cloudinit.go
new file mode 100644
index 00000000..a019320f
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v2_1
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/config.go b/vendor/github.com/flatcar/ignition/config/v2_1/config.go
new file mode 100644
index 00000000..cf12fe79
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/config.go
@@ -0,0 +1,68 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_1
+
+import (
+	"github.com/coreos/go-semver/semver"
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v2_0"
+	"github.com/flatcar/ignition/config/v2_1/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+)
+
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+
+	version, semverErr := semver.NewVersion(config.Ignition.Version)
+
+	if err != nil || semverErr != nil || version.LessThan(types.MaxVersion) {
+		// We can fail unmarshaling if it's an older config. Attempt to parse
+		// it as such.
+		config, rpt, err := v2_0.Parse(rawConfig)
+		if err != nil {
+			return types.Config{}, rpt, err
+		}
+		return TranslateFromV2_0(config), rpt, err
+	}
+
+	if *version != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/translate.go b/vendor/github.com/flatcar/ignition/config/v2_1/translate.go
new file mode 100644
index 00000000..ae8a4d35
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/translate.go
@@ -0,0 +1,236 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_1
+
+import (
+	"strings"
+
+	"github.com/flatcar/ignition/config/util"
+	v2_0 "github.com/flatcar/ignition/config/v2_0/types"
+	"github.com/flatcar/ignition/config/v2_1/types"
+)
+
+// golang--
+func translateV2_0MkfsOptionsTov2_1OptionSlice(opts v2_0.MkfsOptions) []types.CreateOption {
+	newOpts := make([]types.CreateOption, len(opts))
+	for i, o := range opts {
+		newOpts[i] = types.CreateOption(o)
+	}
+	return newOpts
+}
+
+// golang--
+func translateStringSliceTov2_1SSHAuthorizedKeySlice(keys []string) []types.SSHAuthorizedKey {
+	newKeys := make([]types.SSHAuthorizedKey, len(keys))
+	for i, k := range keys {
+		newKeys[i] = types.SSHAuthorizedKey(k)
+	}
+	return newKeys
+}
+
+// golang--
+func translateStringSliceTov2_1UsercreateGroupSlice(groups []string) []types.UsercreateGroup {
+	var newGroups []types.UsercreateGroup
+	for _, g := range groups {
+		newGroups = append(newGroups, types.UsercreateGroup(g))
+	}
+	return newGroups
+}
+
+func TranslateFromV2_0(old v2_0.Config) types.Config {
+	translateVerification := func(old v2_0.Verification) types.Verification {
+		var ver types.Verification
+		if old.Hash != nil {
+			// .String() here is a wrapper around MarshalJSON, which will put the hash in quotes
+			h := strings.Trim(old.Hash.String(), "\"")
+			ver.Hash = &h
+		}
+		return ver
+	}
+	translateConfigReference := func(old v2_0.ConfigReference) types.ConfigReference {
+		return types.ConfigReference{
+			Source:       old.Source.String(),
+			Verification: translateVerification(old.Verification),
+		}
+	}
+
+	config := types.Config{
+		Ignition: types.Ignition{
+			Version: types.MaxVersion.String(),
+		},
+	}
+
+	if old.Ignition.Config.Replace != nil {
+		ref := translateConfigReference(*old.Ignition.Config.Replace)
+		config.Ignition.Config.Replace = &ref
+	}
+
+	for _, oldAppend := range old.Ignition.Config.Append {
+		config.Ignition.Config.Append =
+			append(config.Ignition.Config.Append, translateConfigReference(oldAppend))
+	}
+
+	for _, oldDisk := range old.Storage.Disks {
+		disk := types.Disk{
+			Device:    string(oldDisk.Device),
+			WipeTable: oldDisk.WipeTable,
+		}
+
+		for _, oldPartition := range oldDisk.Partitions {
+			disk.Partitions = append(disk.Partitions, types.Partition{
+				Label:    string(oldPartition.Label),
+				Number:   oldPartition.Number,
+				Size:     int(oldPartition.Size),
+				Start:    int(oldPartition.Start),
+				TypeGUID: string(oldPartition.TypeGUID),
+			})
+		}
+
+		config.Storage.Disks = append(config.Storage.Disks, disk)
+	}
+
+	for _, oldArray := range old.Storage.Arrays {
+		array := types.Raid{
+			Name:   oldArray.Name,
+			Level:  oldArray.Level,
+			Spares: oldArray.Spares,
+		}
+
+		for _, oldDevice := range oldArray.Devices {
+			array.Devices = append(array.Devices, types.Device(oldDevice))
+		}
+
+		config.Storage.Raid = append(config.Storage.Raid, array)
+	}
+
+	for _, oldFilesystem := range old.Storage.Filesystems {
+		filesystem := types.Filesystem{
+			Name: oldFilesystem.Name,
+		}
+
+		if oldFilesystem.Mount != nil {
+			filesystem.Mount = &types.Mount{
+				Device: string(oldFilesystem.Mount.Device),
+				Format: string(oldFilesystem.Mount.Format),
+			}
+
+			if oldFilesystem.Mount.Create != nil {
+				filesystem.Mount.Create = &types.Create{
+					Force:   oldFilesystem.Mount.Create.Force,
+					Options: translateV2_0MkfsOptionsTov2_1OptionSlice(oldFilesystem.Mount.Create.Options),
+				}
+			}
+		}
+
+		if oldFilesystem.Path != nil {
+			p := string(*oldFilesystem.Path)
+			filesystem.Path = &p
+		}
+
+		config.Storage.Filesystems = append(config.Storage.Filesystems, filesystem)
+	}
+
+	for _, oldFile := range old.Storage.Files {
+		file := types.File{
+			Node: types.Node{
+				Filesystem: oldFile.Filesystem,
+				Path:       string(oldFile.Path),
+				User:       types.NodeUser{ID: util.IntToPtr(oldFile.User.Id)},
+				Group:      types.NodeGroup{ID: util.IntToPtr(oldFile.Group.Id)},
+			},
+			FileEmbedded1: types.FileEmbedded1{
+				Mode: int(oldFile.Mode),
+				Contents: types.FileContents{
+					Compression:  string(oldFile.Contents.Compression),
+					Source:       oldFile.Contents.Source.String(),
+					Verification: translateVerification(oldFile.Contents.Verification),
+				},
+			},
+		}
+
+		config.Storage.Files = append(config.Storage.Files, file)
+	}
+
+	for _, oldUnit := range old.Systemd.Units {
+		unit := types.Unit{
+			Name:     string(oldUnit.Name),
+			Enable:   oldUnit.Enable,
+			Mask:     oldUnit.Mask,
+			Contents: oldUnit.Contents,
+		}
+
+		for _, oldDropIn := range oldUnit.DropIns {
+			unit.Dropins = append(unit.Dropins, types.Dropin{
+				Name:     string(oldDropIn.Name),
+				Contents: oldDropIn.Contents,
+			})
+		}
+
+		config.Systemd.Units = append(config.Systemd.Units, unit)
+	}
+
+	for _, oldUnit := range old.Networkd.Units {
+		config.Networkd.Units = append(config.Networkd.Units, types.Networkdunit{
+			Name:     string(oldUnit.Name),
+			Contents: oldUnit.Contents,
+		})
+	}
+
+	for _, oldUser := range old.Passwd.Users {
+		user := types.PasswdUser{
+			Name:              oldUser.Name,
+			PasswordHash:      util.StrToPtr(oldUser.PasswordHash),
+			SSHAuthorizedKeys: translateStringSliceTov2_1SSHAuthorizedKeySlice(oldUser.SSHAuthorizedKeys),
+		}
+
+		if oldUser.Create != nil {
+			var u *int
+			if oldUser.Create.Uid != nil {
+				tmp := int(*oldUser.Create.Uid)
+				u = &tmp
+			}
+			user.Create = &types.Usercreate{
+				UID:          u,
+				Gecos:        oldUser.Create.GECOS,
+				HomeDir:      oldUser.Create.Homedir,
+				NoCreateHome: oldUser.Create.NoCreateHome,
+				PrimaryGroup: oldUser.Create.PrimaryGroup,
+				Groups:       translateStringSliceTov2_1UsercreateGroupSlice(oldUser.Create.Groups),
+				NoUserGroup:  oldUser.Create.NoUserGroup,
+				System:       oldUser.Create.System,
+				NoLogInit:    oldUser.Create.NoLogInit,
+				Shell:        oldUser.Create.Shell,
+			}
+		}
+
+		config.Passwd.Users = append(config.Passwd.Users, user)
+	}
+
+	for _, oldGroup := range old.Passwd.Groups {
+		var g *int
+		if oldGroup.Gid != nil {
+			tmp := int(*oldGroup.Gid)
+			g = &tmp
+		}
+		config.Passwd.Groups = append(config.Passwd.Groups, types.PasswdGroup{
+			Name:         oldGroup.Name,
+			Gid:          g,
+			PasswordHash: oldGroup.PasswordHash,
+			System:       oldGroup.System,
+		})
+	}
+
+	return config
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/config.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/config.go
new file mode 100644
index 00000000..4a931b61
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/config.go
@@ -0,0 +1,91 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 2,
+		Minor: 1,
+	}
+)
+
+func (c Config) Validate() report.Report {
+	r := report.Report{}
+	rules := []rule{
+		checkFilesFilesystems,
+		checkDuplicateFilesystems,
+	}
+
+	for _, rule := range rules {
+		rule(c, &r)
+	}
+	return r
+}
+
+type rule func(cfg Config, report *report.Report)
+
+func checkNodeFilesystems(node Node, filesystems map[string]struct{}, nodeType string) report.Report {
+	r := report.Report{}
+	if node.Filesystem == "" {
+		// Filesystem was not specified. This is an error, but its handled in types.File's Validate, not here
+		return r
+	}
+	_, ok := filesystems[node.Filesystem]
+	if !ok {
+		r.Add(report.Entry{
+			Kind: report.EntryWarning,
+			Message: fmt.Sprintf("%v %q references nonexistent filesystem %q. (This is ok if it is defined in a referenced config)",
+				nodeType, node.Path, node.Filesystem),
+		})
+	}
+	return r
+}
+
+func checkFilesFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		filesystems[filesystem.Name] = struct{}{}
+	}
+	for _, file := range cfg.Storage.Files {
+		r.Merge(checkNodeFilesystems(file.Node, filesystems, "File"))
+	}
+	for _, link := range cfg.Storage.Links {
+		r.Merge(checkNodeFilesystems(link.Node, filesystems, "Link"))
+	}
+	for _, dir := range cfg.Storage.Directories {
+		r.Merge(checkNodeFilesystems(dir.Node, filesystems, "Directory"))
+	}
+}
+
+func checkDuplicateFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		if _, ok := filesystems[filesystem.Name]; ok {
+			r.Add(report.Entry{
+				Kind:    report.EntryWarning,
+				Message: fmt.Sprintf("Filesystem %q shadows exising filesystem definition", filesystem.Name),
+			})
+		}
+		filesystems[filesystem.Name] = struct{}{}
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/directory.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/directory.go
new file mode 100644
index 00000000..d6767c07
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/directory.go
@@ -0,0 +1,30 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (d Directory) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(d.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/disk.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/disk.go
new file mode 100644
index 00000000..ecc84a3e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/disk.go
@@ -0,0 +1,128 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Disk) Validate() report.Report {
+	return report.Report{}
+}
+
+func (n Disk) ValidateDevice() report.Report {
+	if len(n.Device) == 0 {
+		return report.ReportFromError(errors.ErrDiskDeviceRequired, report.EntryError)
+	}
+	if err := validatePath(string(n.Device)); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (n Disk) ValidatePartitions() report.Report {
+	r := report.Report{}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsOverlap.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsMisaligned.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	// Disks which have no errors at this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], p)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition.
+func (p Partition) end() int {
+	if p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return p.Start
+	}
+	return p.Start + p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if p == o || o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if p.Start >= o.Start && p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if p.Start < o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if (p.Start & (2048 - 1)) != 0 {
+			return true
+		}
+	}
+	return false
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/file.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/file.go
new file mode 100644
index 00000000..12c01937
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/file.go
@@ -0,0 +1,56 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f File) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(f.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateCompression() report.Report {
+	r := report.Report{}
+	switch fc.Compression {
+	case "", "gzip":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrCompressionInvalid.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(fc.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/filesystem.go
new file mode 100644
index 00000000..da3e766a
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/filesystem.go
@@ -0,0 +1,144 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f Filesystem) Validate() report.Report {
+	r := report.Report{}
+	if f.Mount == nil && f.Path == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemNoMountPath.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mount != nil {
+		if f.Path != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrFilesystemMountAndPath.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if f.Mount.Create != nil {
+			if f.Mount.WipeFilesystem {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndWipeFilesystem.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			if len(f.Mount.Options) > 0 {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndMountOpts.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			r.Add(report.Entry{
+				Message: errors.ErrWarningCreateDeprecated.Error(),
+				Kind:    report.EntryWarning,
+			})
+		}
+	}
+	return r
+}
+
+func (f Filesystem) ValidatePath() report.Report {
+	r := report.Report{}
+	if f.Path != nil && validatePath(*f.Path) != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPathRelative.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) Validate() report.Report {
+	r := report.Report{}
+	switch m.Format {
+	case "ext4", "btrfs", "xfs", "swap", "vfat":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemInvalidFormat.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateDevice() report.Report {
+	r := report.Report{}
+	if err := validatePath(m.Device); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateLabel() report.Report {
+	r := report.Report{}
+	if m.Label == nil {
+		return r
+	}
+	switch m.Format {
+	case "ext4":
+		if len(*m.Label) > 16 {
+			// source: man mkfs.ext4
+			r.Add(report.Entry{
+				Message: errors.ErrExt4LabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "btrfs":
+		if len(*m.Label) > 256 {
+			// source: man mkfs.btrfs
+			r.Add(report.Entry{
+				Message: errors.ErrBtrfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "xfs":
+		if len(*m.Label) > 12 {
+			// source: man mkfs.xfs
+			r.Add(report.Entry{
+				Message: errors.ErrXfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "swap":
+		// mkswap's man page does not state a limit on label size, but through
+		// experimentation it appears that mkswap will truncate long labels to
+		// 15 characters, so let's enforce that.
+		if len(*m.Label) > 15 {
+			r.Add(report.Entry{
+				Message: errors.ErrSwapLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "vfat":
+		if len(*m.Label) > 11 {
+			// source: man mkfs.fat
+			r.Add(report.Entry{
+				Message: errors.ErrVfatLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/ignition.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/ignition.go
new file mode 100644
index 00000000..e7a0d520
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/ignition.go
@@ -0,0 +1,52 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c ConfigReference) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (v Ignition) Semver() (*semver.Version, error) {
+	return semver.NewVersion(v.Version)
+}
+
+func (v Ignition) Validate() report.Report {
+	tv, err := v.Semver()
+	if err != nil {
+		return report.ReportFromError(errors.ErrInvalidVersion, report.EntryError)
+	}
+	if MaxVersion.Major > tv.Major {
+		return report.ReportFromError(errors.ErrOldVersion, report.EntryError)
+	}
+	if MaxVersion.LessThan(*tv) {
+		return report.ReportFromError(errors.ErrNewVersion, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/mode.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/mode.go
new file mode 100644
index 00000000..adbb2ba2
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/mode.go
@@ -0,0 +1,26 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateMode(m int) error {
+	if m < 0 || m > 07777 {
+		return errors.ErrFileIllegalMode
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/node.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/node.go
new file mode 100644
index 00000000..dd0489c0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/node.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path/filepath"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Node) ValidateFilesystem() report.Report {
+	r := report.Report{}
+	if n.Filesystem == "" {
+		r.Add(report.Entry{
+			Message: errors.ErrNoFilesystem.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) ValidatePath() report.Report {
+	r := report.Report{}
+	if err := validatePath(n.Path); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) Depth() int {
+	count := 0
+	for p := filepath.Clean(string(n.Path)); p != "/"; count++ {
+		p = filepath.Dir(p)
+	}
+	return count
+}
+
+func (nu NodeUser) Validate() report.Report {
+	r := report.Report{}
+	if nu.ID != nil && nu.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+func (ng NodeGroup) Validate() report.Report {
+	r := report.Report{}
+	if ng.ID != nil && ng.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/partition.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/partition.go
new file mode 100644
index 00000000..08e16dc2
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/partition.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+const (
+	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
+)
+
+func (p Partition) ValidateLabel() report.Report {
+	r := report.Report{}
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(p.Label) > 36 {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelTooLong.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
+	if strings.Contains(p.Label, ":") {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelContainsColon.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateTypeGUID() report.Report {
+	return validateGUID(p.TypeGUID)
+}
+
+func (p Partition) ValidateGUID() report.Report {
+	return validateGUID(p.GUID)
+}
+
+func validateGUID(guid string) report.Report {
+	r := report.Report{}
+	ok, err := regexp.MatchString(guidRegexStr, guid)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("error matching guid regexp: %v", err),
+			Kind:    report.EntryError,
+		})
+	} else if !ok {
+		r.Add(report.Entry{
+			Message: errors.ErrDoesntMatchGUIDRegex.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/passwd.go
new file mode 100644
index 00000000..095ddc5e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/passwd.go
@@ -0,0 +1,67 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (p PasswdUser) Validate() report.Report {
+	r := report.Report{}
+	if p.Create != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPasswdCreateDeprecated.Error(),
+			Kind:    report.EntryWarning,
+		})
+		addErr := func(err error) {
+			r.Add(report.Entry{
+				Message: err.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if p.Gecos != "" {
+			addErr(errors.ErrPasswdCreateAndGecos)
+		}
+		if len(p.Groups) > 0 {
+			addErr(errors.ErrPasswdCreateAndGroups)
+		}
+		if p.HomeDir != "" {
+			addErr(errors.ErrPasswdCreateAndHomeDir)
+		}
+		if p.NoCreateHome {
+			addErr(errors.ErrPasswdCreateAndNoCreateHome)
+		}
+		if p.NoLogInit {
+			addErr(errors.ErrPasswdCreateAndNoLogInit)
+		}
+		if p.NoUserGroup {
+			addErr(errors.ErrPasswdCreateAndNoUserGroup)
+		}
+		if p.PrimaryGroup != "" {
+			addErr(errors.ErrPasswdCreateAndPrimaryGroup)
+		}
+		if p.Shell != "" {
+			addErr(errors.ErrPasswdCreateAndShell)
+		}
+		if p.System {
+			addErr(errors.ErrPasswdCreateAndSystem)
+		}
+		if p.UID != nil {
+			addErr(errors.ErrPasswdCreateAndUID)
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/path.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/path.go
new file mode 100644
index 00000000..f52ec956
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/path.go
@@ -0,0 +1,28 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validatePath(p string) error {
+	if !path.IsAbs(p) {
+		return errors.ErrPathRelative
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/raid.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/raid.go
new file mode 100644
index 00000000..87a10ee7
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/raid.go
@@ -0,0 +1,57 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Raid) ValidateLevel() report.Report {
+	r := report.Report{}
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			r.Add(report.Entry{
+				Message: errors.ErrSparesUnsupportedForLevel.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnrecognizedRaidLevel.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Raid) ValidateDevices() report.Report {
+	r := report.Report{}
+	for _, d := range n.Devices {
+		if err := validatePath(string(d)); err != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrPathRelative.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/schema.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/schema.go
new file mode 100644
index 00000000..e0caed5e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/schema.go
@@ -0,0 +1,221 @@
+package types
+
+// generated by "schematyper --package=types schema/ignition.json -o config/types/schema.go --root-type=Config" -- DO NOT EDIT
+
+type Config struct {
+	Ignition Ignition `json:"ignition"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+}
+
+type ConfigReference struct {
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Create struct {
+	Force   bool           `json:"force,omitempty"`
+	Options []CreateOption `json:"options,omitempty"`
+}
+
+type CreateOption string
+
+type Device string
+
+type Directory struct {
+	Node
+	DirectoryEmbedded1
+}
+
+type DirectoryEmbedded1 struct {
+	Mode int `json:"mode,omitempty"`
+}
+
+type Disk struct {
+	Device     string      `json:"device,omitempty"`
+	Partitions []Partition `json:"partitions,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+}
+
+type Dropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name,omitempty"`
+}
+
+type File struct {
+	Node
+	FileEmbedded1
+}
+
+type FileContents struct {
+	Compression  string       `json:"compression,omitempty"`
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type FileEmbedded1 struct {
+	Contents FileContents `json:"contents,omitempty"`
+	Mode     int          `json:"mode,omitempty"`
+}
+
+type Filesystem struct {
+	Mount *Mount  `json:"mount,omitempty"`
+	Name  string  `json:"name,omitempty"`
+	Path  *string `json:"path,omitempty"`
+}
+
+type Ignition struct {
+	Config   IgnitionConfig `json:"config,omitempty"`
+	Timeouts Timeouts       `json:"timeouts,omitempty"`
+	Version  string         `json:"version,omitempty"`
+}
+
+type IgnitionConfig struct {
+	Append  []ConfigReference `json:"append,omitempty"`
+	Replace *ConfigReference  `json:"replace,omitempty"`
+}
+
+type Link struct {
+	Node
+	LinkEmbedded1
+}
+
+type LinkEmbedded1 struct {
+	Hard   bool   `json:"hard,omitempty"`
+	Target string `json:"target,omitempty"`
+}
+
+type Mount struct {
+	Create         *Create       `json:"create,omitempty"`
+	Device         string        `json:"device,omitempty"`
+	Format         string        `json:"format,omitempty"`
+	Label          *string       `json:"label,omitempty"`
+	Options        []MountOption `json:"options,omitempty"`
+	UUID           *string       `json:"uuid,omitempty"`
+	WipeFilesystem bool          `json:"wipeFilesystem,omitempty"`
+}
+
+type MountOption string
+
+type Networkd struct {
+	Units []Networkdunit `json:"units,omitempty"`
+}
+
+type Networkdunit struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name,omitempty"`
+}
+
+type Node struct {
+	Filesystem string    `json:"filesystem,omitempty"`
+	Group      NodeGroup `json:"group,omitempty"`
+	Path       string    `json:"path,omitempty"`
+	User       NodeUser  `json:"user,omitempty"`
+}
+
+type NodeGroup struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type NodeUser struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type Partition struct {
+	GUID     string `json:"guid,omitempty"`
+	Label    string `json:"label,omitempty"`
+	Number   int    `json:"number,omitempty"`
+	Size     int    `json:"size,omitempty"`
+	Start    int    `json:"start,omitempty"`
+	TypeGUID string `json:"typeGuid,omitempty"`
+}
+
+type Passwd struct {
+	Groups []PasswdGroup `json:"groups,omitempty"`
+	Users  []PasswdUser  `json:"users,omitempty"`
+}
+
+type PasswdGroup struct {
+	Gid          *int   `json:"gid,omitempty"`
+	Name         string `json:"name,omitempty"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
+
+type PasswdUser struct {
+	Create            *Usercreate        `json:"create,omitempty"`
+	Gecos             string             `json:"gecos,omitempty"`
+	Groups            []PasswdUserGroup  `json:"groups,omitempty"`
+	HomeDir           string             `json:"homeDir,omitempty"`
+	Name              string             `json:"name,omitempty"`
+	NoCreateHome      bool               `json:"noCreateHome,omitempty"`
+	NoLogInit         bool               `json:"noLogInit,omitempty"`
+	NoUserGroup       bool               `json:"noUserGroup,omitempty"`
+	PasswordHash      *string            `json:"passwordHash,omitempty"`
+	PrimaryGroup      string             `json:"primaryGroup,omitempty"`
+	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
+	Shell             string             `json:"shell,omitempty"`
+	System            bool               `json:"system,omitempty"`
+	UID               *int               `json:"uid,omitempty"`
+}
+
+type PasswdUserGroup string
+
+type Raid struct {
+	Devices []Device `json:"devices,omitempty"`
+	Level   string   `json:"level,omitempty"`
+	Name    string   `json:"name,omitempty"`
+	Spares  int      `json:"spares,omitempty"`
+}
+
+type SSHAuthorizedKey string
+
+type Storage struct {
+	Directories []Directory  `json:"directories,omitempty"`
+	Disks       []Disk       `json:"disks,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Links       []Link       `json:"links,omitempty"`
+	Raid        []Raid       `json:"raid,omitempty"`
+}
+
+type Systemd struct {
+	Units []Unit `json:"units,omitempty"`
+}
+
+type Timeouts struct {
+	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
+	HTTPTotal           *int `json:"httpTotal,omitempty"`
+}
+
+type Unit struct {
+	Contents string   `json:"contents,omitempty"`
+	Dropins  []Dropin `json:"dropins,omitempty"`
+	Enable   bool     `json:"enable,omitempty"`
+	Enabled  *bool    `json:"enabled,omitempty"`
+	Mask     bool     `json:"mask,omitempty"`
+	Name     string   `json:"name,omitempty"`
+}
+
+type Usercreate struct {
+	Gecos        string            `json:"gecos,omitempty"`
+	Groups       []UsercreateGroup `json:"groups,omitempty"`
+	HomeDir      string            `json:"homeDir,omitempty"`
+	NoCreateHome bool              `json:"noCreateHome,omitempty"`
+	NoLogInit    bool              `json:"noLogInit,omitempty"`
+	NoUserGroup  bool              `json:"noUserGroup,omitempty"`
+	PrimaryGroup string            `json:"primaryGroup,omitempty"`
+	Shell        string            `json:"shell,omitempty"`
+	System       bool              `json:"system,omitempty"`
+	UID          *int              `json:"uid,omitempty"`
+}
+
+type UsercreateGroup string
+
+type Verification struct {
+	Hash *string `json:"hash,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/unit.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/unit.go
new file mode 100644
index 00000000..76c77e82
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/unit.go
@@ -0,0 +1,109 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"path"
+	"strings"
+
+	"github.com/coreos/go-systemd/unit"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/shared/validations"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (u Unit) ValidateContents() report.Report {
+	r := report.Report{}
+	opts, err := validateUnitContent(u.Contents)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	isEnabled := u.Enable || (u.Enabled != nil && *u.Enabled)
+	r.Merge(validations.ValidateInstallSection(u.Name, isEnabled, u.Contents == "", opts))
+
+	return r
+}
+
+func (u Unit) ValidateName() report.Report {
+	r := report.Report{}
+	switch path.Ext(u.Name) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (d Dropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (u Networkdunit) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(u.Name) {
+	case ".link", ".netdev", ".network":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func validateUnitContent(content string) ([]*unit.UnitOption, error) {
+	c := strings.NewReader(content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/url.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/url.go
new file mode 100644
index 00000000..e4156582
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/url.go
@@ -0,0 +1,52 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/vincent-petithory/dataurl"
+)
+
+func validateURL(s string) error {
+	// Empty url is valid, indicates an empty file
+	if s == "" {
+		return nil
+	}
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https", "oem", "tftp":
+		return nil
+	case "s3":
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "data":
+		if _, err := dataurl.DecodeString(s); err != nil {
+			return err
+		}
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_1/types/verification.go b/vendor/github.com/flatcar/ignition/config/v2_1/types/verification.go
new file mode 100644
index 00000000..cb06d76e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_1/types/verification.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+// HashParts will return the sum and function (in that order) of the hash stored
+// in this Verification, or an error if there is an issue during parsing.
+func (v Verification) HashParts() (string, string, error) {
+	if v.Hash == nil {
+		// The hash can be nil
+		return "", "", nil
+	}
+	parts := strings.SplitN(*v.Hash, "-", 2)
+	if len(parts) != 2 {
+		return "", "", errors.ErrHashMalformed
+	}
+
+	return parts[0], parts[1], nil
+}
+
+func (v Verification) Validate() report.Report {
+	r := report.Report{}
+
+	if v.Hash == nil {
+		// The hash can be nil
+		return r
+	}
+
+	function, sum, err := v.HashParts()
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+	var hash crypto.Hash
+	switch function {
+	case "sha512":
+		hash = crypto.SHA512
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrHashUnrecognized.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	if len(sum) != hex.EncodedLen(hash.Size()) {
+		r.Add(report.Entry{
+			Message: errors.ErrHashWrongSize.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/append.go b/vendor/github.com/flatcar/ignition/config/v2_2/append.go
new file mode 100644
index 00000000..f3598eaf
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/append.go
@@ -0,0 +1,76 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_2
+
+import (
+	"reflect"
+
+	"github.com/flatcar/ignition/config/v2_2/types"
+)
+
+// Append appends newConfig to oldConfig and returns the result. Appending one
+// config to another is accomplished by iterating over every field in the
+// config structure, appending slices, recursively appending structs, and
+// overwriting old values with new values for all other types.
+func Append(oldConfig, newConfig types.Config) types.Config {
+	vOld := reflect.ValueOf(oldConfig)
+	vNew := reflect.ValueOf(newConfig)
+
+	vResult := appendStruct(vOld, vNew)
+
+	return vResult.Interface().(types.Config)
+}
+
+// appendStruct is an internal helper function to AppendConfig. Given two values
+// of structures (assumed to be the same type), recursively iterate over every
+// field in the struct, appending slices, recursively appending structs, and
+// overwriting old values with the new for all other types. Some individual
+// struct fields have alternate merge strategies, determined by the field name.
+// Currently these fields are "ignition.version", which uses the old value, and
+// "ignition.config" which uses the new value.
+func appendStruct(vOld, vNew reflect.Value) reflect.Value {
+	tOld := vOld.Type()
+	vRes := reflect.New(tOld)
+
+	for i := 0; i < tOld.NumField(); i++ {
+		vfOld := vOld.Field(i)
+		vfNew := vNew.Field(i)
+		vfRes := vRes.Elem().Field(i)
+
+		switch tOld.Field(i).Name {
+		case "Version":
+			vfRes.Set(vfOld)
+			continue
+		case "Config":
+			vfRes.Set(vfNew)
+			continue
+		}
+
+		switch vfOld.Type().Kind() {
+		case reflect.Struct:
+			vfRes.Set(appendStruct(vfOld, vfNew))
+		case reflect.Slice:
+			vfRes.Set(reflect.AppendSlice(vfOld, vfNew))
+		default:
+			if vfNew.Kind() == reflect.Ptr && vfNew.IsNil() {
+				vfRes.Set(vfOld)
+			} else {
+				vfRes.Set(vfNew)
+			}
+		}
+	}
+
+	return vRes.Elem()
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v2_2/cloudinit.go
new file mode 100644
index 00000000..36a54393
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v2_2
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/config.go b/vendor/github.com/flatcar/ignition/config/v2_2/config.go
new file mode 100644
index 00000000..7df84501
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/config.go
@@ -0,0 +1,71 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_2
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v2_1"
+	"github.com/flatcar/ignition/config/v2_2/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/coreos/go-semver/semver"
+)
+
+// Parse parses the raw config into a types.Config struct and generates a report of any
+// errors, warnings, info, and deprecations it encountered. Unlike config.Parse,
+// it does not attempt to translate the config.
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+
+	version, semverErr := semver.NewVersion(config.Ignition.Version)
+
+	if err != nil || semverErr != nil || version.LessThan(types.MaxVersion) {
+		// We can fail unmarshaling if it's an older config. Attempt to parse
+		// it as such.
+		config, rpt, err := v2_1.Parse(rawConfig)
+		if err != nil {
+			return types.Config{}, rpt, err
+		}
+		return TranslateFromV2_1(config), rpt, err
+	}
+
+	if *version != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/translate.go b/vendor/github.com/flatcar/ignition/config/v2_2/translate.go
new file mode 100644
index 00000000..e591aecc
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/translate.go
@@ -0,0 +1,354 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_2
+
+import (
+	"github.com/flatcar/ignition/config/util"
+	v2_1 "github.com/flatcar/ignition/config/v2_1/types"
+	"github.com/flatcar/ignition/config/v2_2/types"
+)
+
+// golang--
+func translateStringSliceToV2_2SSHAuthorizedKeySlice(keys []string) []types.SSHAuthorizedKey {
+	newKeys := make([]types.SSHAuthorizedKey, len(keys))
+	for i, k := range keys {
+		newKeys[i] = types.SSHAuthorizedKey(k)
+	}
+	return newKeys
+}
+
+// golang--
+func translateStringSliceToV2_2UsercreateGroupSlice(groups []string) []types.UsercreateGroup {
+	var newGroups []types.UsercreateGroup
+	for _, g := range groups {
+		newGroups = append(newGroups, types.UsercreateGroup(g))
+	}
+	return newGroups
+}
+
+func TranslateFromV2_1(old v2_1.Config) types.Config {
+	translateConfigReference := func(old *v2_1.ConfigReference) *types.ConfigReference {
+		if old == nil {
+			return nil
+		}
+		return &types.ConfigReference{
+			Source: old.Source,
+			Verification: types.Verification{
+				Hash: old.Verification.Hash,
+			},
+		}
+	}
+	translateConfigReferenceSlice := func(old []v2_1.ConfigReference) []types.ConfigReference {
+		var res []types.ConfigReference
+		for _, c := range old {
+			res = append(res, *translateConfigReference(&c))
+		}
+		return res
+	}
+	translateNetworkdUnitSlice := func(old []v2_1.Networkdunit) []types.Networkdunit {
+		var res []types.Networkdunit
+		for _, u := range old {
+			res = append(res, types.Networkdunit{
+				Contents: u.Contents,
+				Name:     u.Name,
+			})
+		}
+		return res
+	}
+	translatePasswdGroupSlice := func(old []v2_1.PasswdGroup) []types.PasswdGroup {
+		var res []types.PasswdGroup
+		for _, g := range old {
+			res = append(res, types.PasswdGroup{
+				Gid:          g.Gid,
+				Name:         g.Name,
+				PasswordHash: g.PasswordHash,
+				System:       g.System,
+			})
+		}
+		return res
+	}
+	translatePasswdUsercreateGroupSlice := func(old []v2_1.UsercreateGroup) []types.UsercreateGroup {
+		var res []types.UsercreateGroup
+		for _, g := range old {
+			res = append(res, types.UsercreateGroup(g))
+		}
+		return res
+	}
+	translatePasswdUsercreate := func(old *v2_1.Usercreate) *types.Usercreate {
+		if old == nil {
+			return nil
+		}
+		return &types.Usercreate{
+			Gecos:        old.Gecos,
+			Groups:       translatePasswdUsercreateGroupSlice(old.Groups),
+			HomeDir:      old.HomeDir,
+			NoCreateHome: old.NoCreateHome,
+			NoLogInit:    old.NoLogInit,
+			NoUserGroup:  old.NoUserGroup,
+			PrimaryGroup: old.PrimaryGroup,
+			Shell:        old.Shell,
+			System:       old.System,
+			UID:          old.UID,
+		}
+	}
+	translatePasswdUserGroupSlice := func(old []v2_1.PasswdUserGroup) []types.Group {
+		var res []types.Group
+		for _, g := range old {
+			res = append(res, types.Group(g))
+		}
+		return res
+	}
+	translatePasswdSSHAuthorizedKeySlice := func(old []v2_1.SSHAuthorizedKey) []types.SSHAuthorizedKey {
+		res := make([]types.SSHAuthorizedKey, len(old))
+		for i, k := range old {
+			res[i] = types.SSHAuthorizedKey(k)
+		}
+		return res
+	}
+	translatePasswdUserSlice := func(old []v2_1.PasswdUser) []types.PasswdUser {
+		var res []types.PasswdUser
+		for _, u := range old {
+			res = append(res, types.PasswdUser{
+				Create:            translatePasswdUsercreate(u.Create),
+				Gecos:             u.Gecos,
+				Groups:            translatePasswdUserGroupSlice(u.Groups),
+				HomeDir:           u.HomeDir,
+				Name:              u.Name,
+				NoCreateHome:      u.NoCreateHome,
+				NoLogInit:         u.NoLogInit,
+				NoUserGroup:       u.NoUserGroup,
+				PasswordHash:      u.PasswordHash,
+				PrimaryGroup:      u.PrimaryGroup,
+				SSHAuthorizedKeys: translatePasswdSSHAuthorizedKeySlice(u.SSHAuthorizedKeys),
+				Shell:             u.Shell,
+				System:            u.System,
+				UID:               u.UID,
+			})
+		}
+		return res
+	}
+	translateNodeGroup := func(old v2_1.NodeGroup) *types.NodeGroup {
+		return &types.NodeGroup{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNodeUser := func(old v2_1.NodeUser) *types.NodeUser {
+		return &types.NodeUser{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNode := func(old v2_1.Node) types.Node {
+		return types.Node{
+			Filesystem: old.Filesystem,
+			Group:      translateNodeGroup(old.Group),
+			Path:       old.Path,
+			User:       translateNodeUser(old.User),
+		}
+	}
+	translateDirectorySlice := func(old []v2_1.Directory) []types.Directory {
+		var res []types.Directory
+		for _, x := range old {
+			res = append(res, types.Directory{
+				Node: translateNode(x.Node),
+				DirectoryEmbedded1: types.DirectoryEmbedded1{
+					Mode: util.IntToPtr(x.DirectoryEmbedded1.Mode),
+				},
+			})
+		}
+		return res
+	}
+	translatePartitionSlice := func(old []v2_1.Partition) []types.Partition {
+		var res []types.Partition
+		for _, x := range old {
+			res = append(res, types.Partition{
+				GUID:     x.GUID,
+				Label:    x.Label,
+				Number:   x.Number,
+				Size:     x.Size,
+				Start:    x.Start,
+				TypeGUID: x.TypeGUID,
+			})
+		}
+		return res
+	}
+	translateDiskSlice := func(old []v2_1.Disk) []types.Disk {
+		var res []types.Disk
+		for _, x := range old {
+			res = append(res, types.Disk{
+				Device:     x.Device,
+				Partitions: translatePartitionSlice(x.Partitions),
+				WipeTable:  x.WipeTable,
+			})
+		}
+		return res
+	}
+	translateFileSlice := func(old []v2_1.File) []types.File {
+		var res []types.File
+		for _, x := range old {
+			res = append(res, types.File{
+				Node: translateNode(x.Node),
+				FileEmbedded1: types.FileEmbedded1{
+					Contents: types.FileContents{
+						Compression: x.Contents.Compression,
+						Source:      x.Contents.Source,
+						Verification: types.Verification{
+							Hash: x.Contents.Verification.Hash,
+						},
+					},
+					Mode: util.IntToPtr(x.Mode),
+				},
+			})
+		}
+		return res
+	}
+	translateMountCreateOptionSlice := func(old []v2_1.CreateOption) []types.CreateOption {
+		var res []types.CreateOption
+		for _, x := range old {
+			res = append(res, types.CreateOption(x))
+		}
+		return res
+	}
+	translateMountCreate := func(old *v2_1.Create) *types.Create {
+		if old == nil {
+			return nil
+		}
+		return &types.Create{
+			Force:   old.Force,
+			Options: translateMountCreateOptionSlice(old.Options),
+		}
+	}
+	translateMountOptionSlice := func(old []v2_1.MountOption) []types.MountOption {
+		var res []types.MountOption
+		for _, x := range old {
+			res = append(res, types.MountOption(x))
+		}
+		return res
+	}
+	translateMount := func(old *v2_1.Mount) *types.Mount {
+		if old == nil {
+			return nil
+		}
+		return &types.Mount{
+			Create:         translateMountCreate(old.Create),
+			Device:         old.Device,
+			Format:         old.Format,
+			Label:          old.Label,
+			Options:        translateMountOptionSlice(old.Options),
+			UUID:           old.UUID,
+			WipeFilesystem: old.WipeFilesystem,
+		}
+	}
+	translateFilesystemSlice := func(old []v2_1.Filesystem) []types.Filesystem {
+		var res []types.Filesystem
+		for _, x := range old {
+			res = append(res, types.Filesystem{
+				Mount: translateMount(x.Mount),
+				Name:  x.Name,
+				Path:  x.Path,
+			})
+		}
+		return res
+	}
+	translateLinkSlice := func(old []v2_1.Link) []types.Link {
+		var res []types.Link
+		for _, x := range old {
+			res = append(res, types.Link{
+				Node: translateNode(x.Node),
+				LinkEmbedded1: types.LinkEmbedded1{
+					Hard:   x.Hard,
+					Target: x.Target,
+				},
+			})
+		}
+		return res
+	}
+	translateDeviceSlice := func(old []v2_1.Device) []types.Device {
+		var res []types.Device
+		for _, x := range old {
+			res = append(res, types.Device(x))
+		}
+		return res
+	}
+	translateRaidSlice := func(old []v2_1.Raid) []types.Raid {
+		var res []types.Raid
+		for _, x := range old {
+			res = append(res, types.Raid{
+				Devices: translateDeviceSlice(x.Devices),
+				Level:   x.Level,
+				Name:    x.Name,
+				Spares:  x.Spares,
+			})
+		}
+		return res
+	}
+	translateSystemdDropinSlice := func(old []v2_1.Dropin) []types.SystemdDropin {
+		var res []types.SystemdDropin
+		for _, x := range old {
+			res = append(res, types.SystemdDropin{
+				Contents: x.Contents,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	translateSystemdUnitSlice := func(old []v2_1.Unit) []types.Unit {
+		var res []types.Unit
+		for _, x := range old {
+			res = append(res, types.Unit{
+				Contents: x.Contents,
+				Dropins:  translateSystemdDropinSlice(x.Dropins),
+				Enable:   x.Enable,
+				Enabled:  x.Enabled,
+				Mask:     x.Mask,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	config := types.Config{
+		Ignition: types.Ignition{
+			Version: types.MaxVersion.String(),
+			Timeouts: types.Timeouts{
+				HTTPResponseHeaders: old.Ignition.Timeouts.HTTPResponseHeaders,
+				HTTPTotal:           old.Ignition.Timeouts.HTTPTotal,
+			},
+			Config: types.IgnitionConfig{
+				Replace: translateConfigReference(old.Ignition.Config.Replace),
+				Append:  translateConfigReferenceSlice(old.Ignition.Config.Append),
+			},
+		},
+		Networkd: types.Networkd{
+			Units: translateNetworkdUnitSlice(old.Networkd.Units),
+		},
+		Passwd: types.Passwd{
+			Groups: translatePasswdGroupSlice(old.Passwd.Groups),
+			Users:  translatePasswdUserSlice(old.Passwd.Users),
+		},
+		Storage: types.Storage{
+			Directories: translateDirectorySlice(old.Storage.Directories),
+			Disks:       translateDiskSlice(old.Storage.Disks),
+			Files:       translateFileSlice(old.Storage.Files),
+			Filesystems: translateFilesystemSlice(old.Storage.Filesystems),
+			Links:       translateLinkSlice(old.Storage.Links),
+			Raid:        translateRaidSlice(old.Storage.Raid),
+		},
+		Systemd: types.Systemd{
+			Units: translateSystemdUnitSlice(old.Systemd.Units),
+		},
+	}
+	return config
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/ca.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/ca.go
new file mode 100644
index 00000000..313b3ad5
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/ca.go
@@ -0,0 +1,27 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c CaReference) ValidateSource() report.Report {
+	err := validateURL(c.Source)
+	if err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/config.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/config.go
new file mode 100644
index 00000000..d6af950d
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/config.go
@@ -0,0 +1,91 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 2,
+		Minor: 2,
+	}
+)
+
+func (c Config) Validate() report.Report {
+	r := report.Report{}
+	rules := []rule{
+		checkFilesFilesystems,
+		checkDuplicateFilesystems,
+	}
+
+	for _, rule := range rules {
+		rule(c, &r)
+	}
+	return r
+}
+
+type rule func(cfg Config, report *report.Report)
+
+func checkNodeFilesystems(node Node, filesystems map[string]struct{}, nodeType string) report.Report {
+	r := report.Report{}
+	if node.Filesystem == "" {
+		// Filesystem was not specified. This is an error, but its handled in types.File's Validate, not here
+		return r
+	}
+	_, ok := filesystems[node.Filesystem]
+	if !ok {
+		r.Add(report.Entry{
+			Kind: report.EntryWarning,
+			Message: fmt.Sprintf("%v %q references nonexistent filesystem %q. (This is ok if it is defined in a referenced config)",
+				nodeType, node.Path, node.Filesystem),
+		})
+	}
+	return r
+}
+
+func checkFilesFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		filesystems[filesystem.Name] = struct{}{}
+	}
+	for _, file := range cfg.Storage.Files {
+		r.Merge(checkNodeFilesystems(file.Node, filesystems, "File"))
+	}
+	for _, link := range cfg.Storage.Links {
+		r.Merge(checkNodeFilesystems(link.Node, filesystems, "Link"))
+	}
+	for _, dir := range cfg.Storage.Directories {
+		r.Merge(checkNodeFilesystems(dir.Node, filesystems, "Directory"))
+	}
+}
+
+func checkDuplicateFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		if _, ok := filesystems[filesystem.Name]; ok {
+			r.Add(report.Entry{
+				Kind:    report.EntryWarning,
+				Message: fmt.Sprintf("Filesystem %q shadows exising filesystem definition", filesystem.Name),
+			})
+		}
+		filesystems[filesystem.Name] = struct{}{}
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/directory.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/directory.go
new file mode 100644
index 00000000..50ded7dd
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/directory.go
@@ -0,0 +1,37 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (d Directory) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(d.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if d.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/disk.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/disk.go
new file mode 100644
index 00000000..ecc84a3e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/disk.go
@@ -0,0 +1,128 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Disk) Validate() report.Report {
+	return report.Report{}
+}
+
+func (n Disk) ValidateDevice() report.Report {
+	if len(n.Device) == 0 {
+		return report.ReportFromError(errors.ErrDiskDeviceRequired, report.EntryError)
+	}
+	if err := validatePath(string(n.Device)); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (n Disk) ValidatePartitions() report.Report {
+	r := report.Report{}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsOverlap.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsMisaligned.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	// Disks which have no errors at this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], p)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition.
+func (p Partition) end() int {
+	if p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return p.Start
+	}
+	return p.Start + p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if p == o || o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if p.Start >= o.Start && p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if p.Start < o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if (p.Start & (2048 - 1)) != 0 {
+			return true
+		}
+	}
+	return false
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/file.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/file.go
new file mode 100644
index 00000000..d5ab7437
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/file.go
@@ -0,0 +1,69 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f File) Validate() report.Report {
+	if f.Overwrite != nil && *f.Overwrite && f.Append {
+		return report.ReportFromError(errors.ErrAppendAndOverwrite, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (f File) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(f.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateCompression() report.Report {
+	r := report.Report{}
+	switch fc.Compression {
+	case "", "gzip":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrCompressionInvalid.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(fc.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/filesystem.go
new file mode 100644
index 00000000..da3e766a
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/filesystem.go
@@ -0,0 +1,144 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f Filesystem) Validate() report.Report {
+	r := report.Report{}
+	if f.Mount == nil && f.Path == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemNoMountPath.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mount != nil {
+		if f.Path != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrFilesystemMountAndPath.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if f.Mount.Create != nil {
+			if f.Mount.WipeFilesystem {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndWipeFilesystem.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			if len(f.Mount.Options) > 0 {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndMountOpts.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			r.Add(report.Entry{
+				Message: errors.ErrWarningCreateDeprecated.Error(),
+				Kind:    report.EntryWarning,
+			})
+		}
+	}
+	return r
+}
+
+func (f Filesystem) ValidatePath() report.Report {
+	r := report.Report{}
+	if f.Path != nil && validatePath(*f.Path) != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPathRelative.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) Validate() report.Report {
+	r := report.Report{}
+	switch m.Format {
+	case "ext4", "btrfs", "xfs", "swap", "vfat":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemInvalidFormat.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateDevice() report.Report {
+	r := report.Report{}
+	if err := validatePath(m.Device); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateLabel() report.Report {
+	r := report.Report{}
+	if m.Label == nil {
+		return r
+	}
+	switch m.Format {
+	case "ext4":
+		if len(*m.Label) > 16 {
+			// source: man mkfs.ext4
+			r.Add(report.Entry{
+				Message: errors.ErrExt4LabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "btrfs":
+		if len(*m.Label) > 256 {
+			// source: man mkfs.btrfs
+			r.Add(report.Entry{
+				Message: errors.ErrBtrfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "xfs":
+		if len(*m.Label) > 12 {
+			// source: man mkfs.xfs
+			r.Add(report.Entry{
+				Message: errors.ErrXfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "swap":
+		// mkswap's man page does not state a limit on label size, but through
+		// experimentation it appears that mkswap will truncate long labels to
+		// 15 characters, so let's enforce that.
+		if len(*m.Label) > 15 {
+			r.Add(report.Entry{
+				Message: errors.ErrSwapLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "vfat":
+		if len(*m.Label) > 11 {
+			// source: man mkfs.fat
+			r.Add(report.Entry{
+				Message: errors.ErrVfatLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/ignition.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/ignition.go
new file mode 100644
index 00000000..e7a0d520
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/ignition.go
@@ -0,0 +1,52 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c ConfigReference) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (v Ignition) Semver() (*semver.Version, error) {
+	return semver.NewVersion(v.Version)
+}
+
+func (v Ignition) Validate() report.Report {
+	tv, err := v.Semver()
+	if err != nil {
+		return report.ReportFromError(errors.ErrInvalidVersion, report.EntryError)
+	}
+	if MaxVersion.Major > tv.Major {
+		return report.ReportFromError(errors.ErrOldVersion, report.EntryError)
+	}
+	if MaxVersion.LessThan(*tv) {
+		return report.ReportFromError(errors.ErrNewVersion, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/mode.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/mode.go
new file mode 100644
index 00000000..b746217c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/mode.go
@@ -0,0 +1,26 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateMode(m *int) error {
+	if m != nil && (*m < 0 || *m > 07777) {
+		return errors.ErrFileIllegalMode
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/node.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/node.go
new file mode 100644
index 00000000..dd0489c0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/node.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path/filepath"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Node) ValidateFilesystem() report.Report {
+	r := report.Report{}
+	if n.Filesystem == "" {
+		r.Add(report.Entry{
+			Message: errors.ErrNoFilesystem.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) ValidatePath() report.Report {
+	r := report.Report{}
+	if err := validatePath(n.Path); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) Depth() int {
+	count := 0
+	for p := filepath.Clean(string(n.Path)); p != "/"; count++ {
+		p = filepath.Dir(p)
+	}
+	return count
+}
+
+func (nu NodeUser) Validate() report.Report {
+	r := report.Report{}
+	if nu.ID != nil && nu.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+func (ng NodeGroup) Validate() report.Report {
+	r := report.Report{}
+	if ng.ID != nil && ng.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/partition.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/partition.go
new file mode 100644
index 00000000..08e16dc2
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/partition.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+const (
+	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
+)
+
+func (p Partition) ValidateLabel() report.Report {
+	r := report.Report{}
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(p.Label) > 36 {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelTooLong.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
+	if strings.Contains(p.Label, ":") {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelContainsColon.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateTypeGUID() report.Report {
+	return validateGUID(p.TypeGUID)
+}
+
+func (p Partition) ValidateGUID() report.Report {
+	return validateGUID(p.GUID)
+}
+
+func validateGUID(guid string) report.Report {
+	r := report.Report{}
+	ok, err := regexp.MatchString(guidRegexStr, guid)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("error matching guid regexp: %v", err),
+			Kind:    report.EntryError,
+		})
+	} else if !ok {
+		r.Add(report.Entry{
+			Message: errors.ErrDoesntMatchGUIDRegex.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/passwd.go
new file mode 100644
index 00000000..095ddc5e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/passwd.go
@@ -0,0 +1,67 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (p PasswdUser) Validate() report.Report {
+	r := report.Report{}
+	if p.Create != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPasswdCreateDeprecated.Error(),
+			Kind:    report.EntryWarning,
+		})
+		addErr := func(err error) {
+			r.Add(report.Entry{
+				Message: err.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if p.Gecos != "" {
+			addErr(errors.ErrPasswdCreateAndGecos)
+		}
+		if len(p.Groups) > 0 {
+			addErr(errors.ErrPasswdCreateAndGroups)
+		}
+		if p.HomeDir != "" {
+			addErr(errors.ErrPasswdCreateAndHomeDir)
+		}
+		if p.NoCreateHome {
+			addErr(errors.ErrPasswdCreateAndNoCreateHome)
+		}
+		if p.NoLogInit {
+			addErr(errors.ErrPasswdCreateAndNoLogInit)
+		}
+		if p.NoUserGroup {
+			addErr(errors.ErrPasswdCreateAndNoUserGroup)
+		}
+		if p.PrimaryGroup != "" {
+			addErr(errors.ErrPasswdCreateAndPrimaryGroup)
+		}
+		if p.Shell != "" {
+			addErr(errors.ErrPasswdCreateAndShell)
+		}
+		if p.System {
+			addErr(errors.ErrPasswdCreateAndSystem)
+		}
+		if p.UID != nil {
+			addErr(errors.ErrPasswdCreateAndUID)
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/path.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/path.go
new file mode 100644
index 00000000..f52ec956
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/path.go
@@ -0,0 +1,28 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validatePath(p string) error {
+	if !path.IsAbs(p) {
+		return errors.ErrPathRelative
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/raid.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/raid.go
new file mode 100644
index 00000000..87a10ee7
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/raid.go
@@ -0,0 +1,57 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Raid) ValidateLevel() report.Report {
+	r := report.Report{}
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			r.Add(report.Entry{
+				Message: errors.ErrSparesUnsupportedForLevel.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnrecognizedRaidLevel.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Raid) ValidateDevices() report.Report {
+	r := report.Report{}
+	for _, d := range n.Devices {
+		if err := validatePath(string(d)); err != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrPathRelative.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/schema.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/schema.go
new file mode 100644
index 00000000..4b32b337
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/schema.go
@@ -0,0 +1,246 @@
+package types
+
+// generated by "schematyper --package=types schema/ignition.json -o config/types/schema.go --root-type=Config" -- DO NOT EDIT
+
+type CaReference struct {
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Config struct {
+	Ignition Ignition `json:"ignition"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+}
+
+type ConfigReference struct {
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Create struct {
+	Force   bool           `json:"force,omitempty"`
+	Options []CreateOption `json:"options,omitempty"`
+}
+
+type CreateOption string
+
+type Device string
+
+type Directory struct {
+	Node
+	DirectoryEmbedded1
+}
+
+type DirectoryEmbedded1 struct {
+	Mode *int `json:"mode,omitempty"`
+}
+
+type Disk struct {
+	Device     string      `json:"device,omitempty"`
+	Partitions []Partition `json:"partitions,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+}
+
+type File struct {
+	Node
+	FileEmbedded1
+}
+
+type FileContents struct {
+	Compression  string       `json:"compression,omitempty"`
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type FileEmbedded1 struct {
+	Append   bool         `json:"append,omitempty"`
+	Contents FileContents `json:"contents,omitempty"`
+	Mode     *int         `json:"mode,omitempty"`
+}
+
+type Filesystem struct {
+	Mount *Mount  `json:"mount,omitempty"`
+	Name  string  `json:"name,omitempty"`
+	Path  *string `json:"path,omitempty"`
+}
+
+type Group string
+
+type Ignition struct {
+	Config   IgnitionConfig `json:"config,omitempty"`
+	Security Security       `json:"security,omitempty"`
+	Timeouts Timeouts       `json:"timeouts,omitempty"`
+	Version  string         `json:"version,omitempty"`
+}
+
+type IgnitionConfig struct {
+	Append  []ConfigReference `json:"append,omitempty"`
+	Replace *ConfigReference  `json:"replace,omitempty"`
+}
+
+type Link struct {
+	Node
+	LinkEmbedded1
+}
+
+type LinkEmbedded1 struct {
+	Hard   bool   `json:"hard,omitempty"`
+	Target string `json:"target,omitempty"`
+}
+
+type Mount struct {
+	Create         *Create       `json:"create,omitempty"`
+	Device         string        `json:"device,omitempty"`
+	Format         string        `json:"format,omitempty"`
+	Label          *string       `json:"label,omitempty"`
+	Options        []MountOption `json:"options,omitempty"`
+	UUID           *string       `json:"uuid,omitempty"`
+	WipeFilesystem bool          `json:"wipeFilesystem,omitempty"`
+}
+
+type MountOption string
+
+type Networkd struct {
+	Units []Networkdunit `json:"units,omitempty"`
+}
+
+type NetworkdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name,omitempty"`
+}
+
+type Networkdunit struct {
+	Contents string           `json:"contents,omitempty"`
+	Dropins  []NetworkdDropin `json:"dropins,omitempty"`
+	Name     string           `json:"name,omitempty"`
+}
+
+type Node struct {
+	Filesystem string     `json:"filesystem,omitempty"`
+	Group      *NodeGroup `json:"group,omitempty"`
+	Overwrite  *bool      `json:"overwrite,omitempty"`
+	Path       string     `json:"path,omitempty"`
+	User       *NodeUser  `json:"user,omitempty"`
+}
+
+type NodeGroup struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type NodeUser struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type Partition struct {
+	GUID     string `json:"guid,omitempty"`
+	Label    string `json:"label,omitempty"`
+	Number   int    `json:"number,omitempty"`
+	Size     int    `json:"size,omitempty"`
+	Start    int    `json:"start,omitempty"`
+	TypeGUID string `json:"typeGuid,omitempty"`
+}
+
+type Passwd struct {
+	Groups []PasswdGroup `json:"groups,omitempty"`
+	Users  []PasswdUser  `json:"users,omitempty"`
+}
+
+type PasswdGroup struct {
+	Gid          *int   `json:"gid,omitempty"`
+	Name         string `json:"name,omitempty"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
+
+type PasswdUser struct {
+	Create            *Usercreate        `json:"create,omitempty"`
+	Gecos             string             `json:"gecos,omitempty"`
+	Groups            []Group            `json:"groups,omitempty"`
+	HomeDir           string             `json:"homeDir,omitempty"`
+	Name              string             `json:"name,omitempty"`
+	NoCreateHome      bool               `json:"noCreateHome,omitempty"`
+	NoLogInit         bool               `json:"noLogInit,omitempty"`
+	NoUserGroup       bool               `json:"noUserGroup,omitempty"`
+	PasswordHash      *string            `json:"passwordHash,omitempty"`
+	PrimaryGroup      string             `json:"primaryGroup,omitempty"`
+	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
+	Shell             string             `json:"shell,omitempty"`
+	System            bool               `json:"system,omitempty"`
+	UID               *int               `json:"uid,omitempty"`
+}
+
+type Raid struct {
+	Devices []Device     `json:"devices,omitempty"`
+	Level   string       `json:"level,omitempty"`
+	Name    string       `json:"name,omitempty"`
+	Options []RaidOption `json:"options,omitempty"`
+	Spares  int          `json:"spares,omitempty"`
+}
+
+type RaidOption string
+
+type SSHAuthorizedKey string
+
+type Security struct {
+	TLS TLS `json:"tls,omitempty"`
+}
+
+type Storage struct {
+	Directories []Directory  `json:"directories,omitempty"`
+	Disks       []Disk       `json:"disks,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Links       []Link       `json:"links,omitempty"`
+	Raid        []Raid       `json:"raid,omitempty"`
+}
+
+type Systemd struct {
+	Units []Unit `json:"units,omitempty"`
+}
+
+type SystemdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name,omitempty"`
+}
+
+type TLS struct {
+	CertificateAuthorities []CaReference `json:"certificateAuthorities,omitempty"`
+}
+
+type Timeouts struct {
+	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
+	HTTPTotal           *int `json:"httpTotal,omitempty"`
+}
+
+type Unit struct {
+	Contents string          `json:"contents,omitempty"`
+	Dropins  []SystemdDropin `json:"dropins,omitempty"`
+	Enable   bool            `json:"enable,omitempty"`
+	Enabled  *bool           `json:"enabled,omitempty"`
+	Mask     bool            `json:"mask,omitempty"`
+	Name     string          `json:"name,omitempty"`
+}
+
+type Usercreate struct {
+	Gecos        string            `json:"gecos,omitempty"`
+	Groups       []UsercreateGroup `json:"groups,omitempty"`
+	HomeDir      string            `json:"homeDir,omitempty"`
+	NoCreateHome bool              `json:"noCreateHome,omitempty"`
+	NoLogInit    bool              `json:"noLogInit,omitempty"`
+	NoUserGroup  bool              `json:"noUserGroup,omitempty"`
+	PrimaryGroup string            `json:"primaryGroup,omitempty"`
+	Shell        string            `json:"shell,omitempty"`
+	System       bool              `json:"system,omitempty"`
+	UID          *int              `json:"uid,omitempty"`
+}
+
+type UsercreateGroup string
+
+type Verification struct {
+	Hash *string `json:"hash,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/unit.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/unit.go
new file mode 100644
index 00000000..3d57428e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/unit.go
@@ -0,0 +1,131 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"path"
+	"strings"
+
+	"github.com/coreos/go-systemd/unit"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/shared/validations"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (u Unit) ValidateContents() report.Report {
+	r := report.Report{}
+	opts, err := validateUnitContent(u.Contents)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	isEnabled := u.Enable || (u.Enabled != nil && *u.Enabled)
+	r.Merge(validations.ValidateInstallSection(u.Name, isEnabled, u.Contents == "", opts))
+
+	return r
+}
+
+func (u Unit) ValidateName() report.Report {
+	r := report.Report{}
+	switch path.Ext(u.Name) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (d SystemdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (u Networkdunit) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(u.Name) {
+	case ".link", ".netdev", ".network":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (d NetworkdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func validateUnitContent(content string) ([]*unit.UnitOption, error) {
+	c := strings.NewReader(content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/url.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/url.go
new file mode 100644
index 00000000..aedd9a56
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/url.go
@@ -0,0 +1,53 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/vincent-petithory/dataurl"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateURL(s string) error {
+	// Empty url is valid, indicates an empty file
+	if s == "" {
+		return nil
+	}
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https", "oem", "tftp":
+		return nil
+	case "s3":
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "data":
+		if _, err := dataurl.DecodeString(s); err != nil {
+			return err
+		}
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_2/types/verification.go b/vendor/github.com/flatcar/ignition/config/v2_2/types/verification.go
new file mode 100644
index 00000000..cb06d76e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_2/types/verification.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+// HashParts will return the sum and function (in that order) of the hash stored
+// in this Verification, or an error if there is an issue during parsing.
+func (v Verification) HashParts() (string, string, error) {
+	if v.Hash == nil {
+		// The hash can be nil
+		return "", "", nil
+	}
+	parts := strings.SplitN(*v.Hash, "-", 2)
+	if len(parts) != 2 {
+		return "", "", errors.ErrHashMalformed
+	}
+
+	return parts[0], parts[1], nil
+}
+
+func (v Verification) Validate() report.Report {
+	r := report.Report{}
+
+	if v.Hash == nil {
+		// The hash can be nil
+		return r
+	}
+
+	function, sum, err := v.HashParts()
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+	var hash crypto.Hash
+	switch function {
+	case "sha512":
+		hash = crypto.SHA512
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrHashUnrecognized.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	if len(sum) != hex.EncodedLen(hash.Size()) {
+		r.Add(report.Entry{
+			Message: errors.ErrHashWrongSize.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/append.go b/vendor/github.com/flatcar/ignition/config/v2_3/append.go
new file mode 100644
index 00000000..2d099087
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/append.go
@@ -0,0 +1,76 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_3
+
+import (
+	"reflect"
+
+	"github.com/flatcar/ignition/config/v2_3/types"
+)
+
+// Append appends newConfig to oldConfig and returns the result. Appending one
+// config to another is accomplished by iterating over every field in the
+// config structure, appending slices, recursively appending structs, and
+// overwriting old values with new values for all other types.
+func Append(oldConfig, newConfig types.Config) types.Config {
+	vOld := reflect.ValueOf(oldConfig)
+	vNew := reflect.ValueOf(newConfig)
+
+	vResult := appendStruct(vOld, vNew)
+
+	return vResult.Interface().(types.Config)
+}
+
+// appendStruct is an internal helper function to AppendConfig. Given two values
+// of structures (assumed to be the same type), recursively iterate over every
+// field in the struct, appending slices, recursively appending structs, and
+// overwriting old values with the new for all other types. Some individual
+// struct fields have alternate merge strategies, determined by the field name.
+// Currently these fields are "ignition.version", which uses the old value, and
+// "ignition.config" which uses the new value.
+func appendStruct(vOld, vNew reflect.Value) reflect.Value {
+	tOld := vOld.Type()
+	vRes := reflect.New(tOld)
+
+	for i := 0; i < tOld.NumField(); i++ {
+		vfOld := vOld.Field(i)
+		vfNew := vNew.Field(i)
+		vfRes := vRes.Elem().Field(i)
+
+		switch tOld.Field(i).Name {
+		case "Version":
+			vfRes.Set(vfOld)
+			continue
+		case "Config":
+			vfRes.Set(vfNew)
+			continue
+		}
+
+		switch vfOld.Type().Kind() {
+		case reflect.Struct:
+			vfRes.Set(appendStruct(vfOld, vfNew))
+		case reflect.Slice:
+			vfRes.Set(reflect.AppendSlice(vfOld, vfNew))
+		default:
+			if vfNew.Kind() == reflect.Ptr && vfNew.IsNil() {
+				vfRes.Set(vfOld)
+			} else {
+				vfRes.Set(vfNew)
+			}
+		}
+	}
+
+	return vRes.Elem()
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v2_3/cloudinit.go
new file mode 100644
index 00000000..3b83fbd9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v2_3
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/config.go b/vendor/github.com/flatcar/ignition/config/v2_3/config.go
new file mode 100644
index 00000000..4693547a
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/config.go
@@ -0,0 +1,70 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_3
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v2_2"
+	"github.com/flatcar/ignition/config/v2_3/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/coreos/go-semver/semver"
+)
+
+// Parse parses the raw config into a types.Config struct and generates a report of any
+// errors, warnings, info, and deprecations it encountered
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+
+	version, semverErr := semver.NewVersion(config.Ignition.Version)
+
+	if err != nil || semverErr != nil || version.LessThan(types.MaxVersion) {
+		// We can fail unmarshaling if it's an older config. Attempt to parse
+		// it as such.
+		config, rpt, err := v2_2.Parse(rawConfig)
+		if err != nil {
+			return types.Config{}, rpt, err
+		}
+		return Translate(config), rpt, err
+	}
+
+	if *version != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/translate.go b/vendor/github.com/flatcar/ignition/config/v2_3/translate.go
new file mode 100644
index 00000000..7ab66d7d
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/translate.go
@@ -0,0 +1,380 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_3
+
+import (
+	"github.com/flatcar/ignition/config/util"
+	v2_2 "github.com/flatcar/ignition/config/v2_2/types"
+	"github.com/flatcar/ignition/config/v2_3/types"
+)
+
+func Translate(old v2_2.Config) types.Config {
+	translateConfigReference := func(old *v2_2.ConfigReference) *types.ConfigReference {
+		if old == nil {
+			return nil
+		}
+		return &types.ConfigReference{
+			Source: old.Source,
+			Verification: types.Verification{
+				Hash: old.Verification.Hash,
+			},
+		}
+	}
+	translateConfigReferenceSlice := func(old []v2_2.ConfigReference) []types.ConfigReference {
+		var res []types.ConfigReference
+		for _, c := range old {
+			res = append(res, *translateConfigReference(&c))
+		}
+		return res
+	}
+	translateCertificateAuthoritySlice := func(old []v2_2.CaReference) []types.CaReference {
+		var res []types.CaReference
+		for _, x := range old {
+			res = append(res, types.CaReference{
+				Source: x.Source,
+				Verification: types.Verification{
+					Hash: x.Verification.Hash,
+				},
+			})
+		}
+		return res
+	}
+	translateNetworkdDropinSlice := func(old []v2_2.NetworkdDropin) []types.NetworkdDropin {
+		var res []types.NetworkdDropin
+		for _, x := range old {
+			res = append(res, types.NetworkdDropin{
+				Contents: x.Contents,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	translateNetworkdUnitSlice := func(old []v2_2.Networkdunit) []types.Networkdunit {
+		var res []types.Networkdunit
+		for _, u := range old {
+			res = append(res, types.Networkdunit{
+				Contents: u.Contents,
+				Name:     u.Name,
+				Dropins:  translateNetworkdDropinSlice(u.Dropins),
+			})
+		}
+		return res
+	}
+	translatePasswdGroupSlice := func(old []v2_2.PasswdGroup) []types.PasswdGroup {
+		var res []types.PasswdGroup
+		for _, g := range old {
+			res = append(res, types.PasswdGroup{
+				Gid:          g.Gid,
+				Name:         g.Name,
+				PasswordHash: g.PasswordHash,
+				System:       g.System,
+			})
+		}
+		return res
+	}
+	translatePasswdUsercreateGroupSlice := func(old []v2_2.UsercreateGroup) []types.UsercreateGroup {
+		var res []types.UsercreateGroup
+		for _, g := range old {
+			res = append(res, types.UsercreateGroup(g))
+		}
+		return res
+	}
+	translatePasswdUsercreate := func(old *v2_2.Usercreate) *types.Usercreate {
+		if old == nil {
+			return nil
+		}
+		return &types.Usercreate{
+			Gecos:        old.Gecos,
+			Groups:       translatePasswdUsercreateGroupSlice(old.Groups),
+			HomeDir:      old.HomeDir,
+			NoCreateHome: old.NoCreateHome,
+			NoLogInit:    old.NoLogInit,
+			NoUserGroup:  old.NoUserGroup,
+			PrimaryGroup: old.PrimaryGroup,
+			Shell:        old.Shell,
+			System:       old.System,
+			UID:          old.UID,
+		}
+	}
+	translatePasswdUserGroupSlice := func(old []v2_2.Group) []types.Group {
+		var res []types.Group
+		for _, g := range old {
+			res = append(res, types.Group(g))
+		}
+		return res
+	}
+	translatePasswdSSHAuthorizedKeySlice := func(old []v2_2.SSHAuthorizedKey) []types.SSHAuthorizedKey {
+		res := make([]types.SSHAuthorizedKey, len(old))
+		for i, k := range old {
+			res[i] = types.SSHAuthorizedKey(k)
+		}
+		return res
+	}
+	translatePasswdUserSlice := func(old []v2_2.PasswdUser) []types.PasswdUser {
+		var res []types.PasswdUser
+		for _, u := range old {
+			res = append(res, types.PasswdUser{
+				Create:            translatePasswdUsercreate(u.Create),
+				Gecos:             u.Gecos,
+				Groups:            translatePasswdUserGroupSlice(u.Groups),
+				HomeDir:           u.HomeDir,
+				Name:              u.Name,
+				NoCreateHome:      u.NoCreateHome,
+				NoLogInit:         u.NoLogInit,
+				NoUserGroup:       u.NoUserGroup,
+				PasswordHash:      u.PasswordHash,
+				PrimaryGroup:      u.PrimaryGroup,
+				SSHAuthorizedKeys: translatePasswdSSHAuthorizedKeySlice(u.SSHAuthorizedKeys),
+				Shell:             u.Shell,
+				System:            u.System,
+				UID:               u.UID,
+			})
+		}
+		return res
+	}
+	translateNodeGroup := func(old *v2_2.NodeGroup) *types.NodeGroup {
+		if old == nil {
+			return nil
+		}
+		return &types.NodeGroup{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNodeUser := func(old *v2_2.NodeUser) *types.NodeUser {
+		if old == nil {
+			return nil
+		}
+		return &types.NodeUser{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNode := func(old v2_2.Node) types.Node {
+		return types.Node{
+			Filesystem: old.Filesystem,
+			Group:      translateNodeGroup(old.Group),
+			Path:       old.Path,
+			User:       translateNodeUser(old.User),
+			Overwrite:  old.Overwrite,
+		}
+	}
+	translateDirectorySlice := func(old []v2_2.Directory) []types.Directory {
+		var res []types.Directory
+		for _, x := range old {
+			res = append(res, types.Directory{
+				Node: translateNode(x.Node),
+				DirectoryEmbedded1: types.DirectoryEmbedded1{
+					Mode: x.DirectoryEmbedded1.Mode,
+				},
+			})
+		}
+		return res
+	}
+	translatePartitionSlice := func(old []v2_2.Partition) []types.Partition {
+		var res []types.Partition
+		for _, x := range old {
+			res = append(res, types.Partition{
+				GUID:     x.GUID,
+				Label:    util.StrToPtrStrict(x.Label),
+				Number:   x.Number,
+				Size:     util.IntToPtr(x.Size),
+				Start:    util.IntToPtr(x.Start),
+				TypeGUID: x.TypeGUID,
+			})
+		}
+		return res
+	}
+	translateDiskSlice := func(old []v2_2.Disk) []types.Disk {
+		var res []types.Disk
+		for _, x := range old {
+			res = append(res, types.Disk{
+				Device:     x.Device,
+				Partitions: translatePartitionSlice(x.Partitions),
+				WipeTable:  x.WipeTable,
+			})
+		}
+		return res
+	}
+	translateFileSlice := func(old []v2_2.File) []types.File {
+		var res []types.File
+		for _, x := range old {
+			res = append(res, types.File{
+				Node: translateNode(x.Node),
+				FileEmbedded1: types.FileEmbedded1{
+					Contents: types.FileContents{
+						Compression: x.Contents.Compression,
+						Source:      x.Contents.Source,
+						Verification: types.Verification{
+							Hash: x.Contents.Verification.Hash,
+						},
+					},
+					Mode:   x.Mode,
+					Append: x.Append,
+				},
+			})
+		}
+		return res
+	}
+	translateMountCreateOptionSlice := func(old []v2_2.CreateOption) []types.CreateOption {
+		var res []types.CreateOption
+		for _, x := range old {
+			res = append(res, types.CreateOption(x))
+		}
+		return res
+	}
+	translateMountCreate := func(old *v2_2.Create) *types.Create {
+		if old == nil {
+			return nil
+		}
+		return &types.Create{
+			Force:   old.Force,
+			Options: translateMountCreateOptionSlice(old.Options),
+		}
+	}
+	translateMountOptionSlice := func(old []v2_2.MountOption) []types.MountOption {
+		var res []types.MountOption
+		for _, x := range old {
+			res = append(res, types.MountOption(x))
+		}
+		return res
+	}
+	translateMount := func(old *v2_2.Mount) *types.Mount {
+		if old == nil {
+			return nil
+		}
+		return &types.Mount{
+			Create:         translateMountCreate(old.Create),
+			Device:         old.Device,
+			Format:         old.Format,
+			Label:          old.Label,
+			Options:        translateMountOptionSlice(old.Options),
+			UUID:           old.UUID,
+			WipeFilesystem: old.WipeFilesystem,
+		}
+	}
+	translateFilesystemSlice := func(old []v2_2.Filesystem) []types.Filesystem {
+		var res []types.Filesystem
+		for _, x := range old {
+			res = append(res, types.Filesystem{
+				Mount: translateMount(x.Mount),
+				Name:  x.Name,
+				Path:  x.Path,
+			})
+		}
+		return res
+	}
+	translateLinkSlice := func(old []v2_2.Link) []types.Link {
+		var res []types.Link
+		for _, x := range old {
+			res = append(res, types.Link{
+				Node: translateNode(x.Node),
+				LinkEmbedded1: types.LinkEmbedded1{
+					Hard:   x.Hard,
+					Target: x.Target,
+				},
+			})
+		}
+		return res
+	}
+	translateDeviceSlice := func(old []v2_2.Device) []types.Device {
+		var res []types.Device
+		for _, x := range old {
+			res = append(res, types.Device(x))
+		}
+		return res
+	}
+	translateRaidOptionSlice := func(old []v2_2.RaidOption) []types.RaidOption {
+		var res []types.RaidOption
+		for _, x := range old {
+			res = append(res, types.RaidOption(x))
+		}
+		return res
+	}
+	translateRaidSlice := func(old []v2_2.Raid) []types.Raid {
+		var res []types.Raid
+		for _, x := range old {
+			res = append(res, types.Raid{
+				Devices: translateDeviceSlice(x.Devices),
+				Level:   x.Level,
+				Name:    x.Name,
+				Spares:  x.Spares,
+				Options: translateRaidOptionSlice(x.Options),
+			})
+		}
+		return res
+	}
+	translateSystemdDropinSlice := func(old []v2_2.SystemdDropin) []types.SystemdDropin {
+		var res []types.SystemdDropin
+		for _, x := range old {
+			res = append(res, types.SystemdDropin{
+				Contents: x.Contents,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	translateSystemdUnitSlice := func(old []v2_2.Unit) []types.Unit {
+		var res []types.Unit
+		for _, x := range old {
+			res = append(res, types.Unit{
+				Contents: x.Contents,
+				Dropins:  translateSystemdDropinSlice(x.Dropins),
+				Enable:   x.Enable,
+				Enabled:  x.Enabled,
+				Mask:     x.Mask,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	config := types.Config{
+		Ignition: types.Ignition{
+			Version: types.MaxVersion.String(),
+			Timeouts: types.Timeouts{
+				HTTPResponseHeaders: old.Ignition.Timeouts.HTTPResponseHeaders,
+				HTTPTotal:           old.Ignition.Timeouts.HTTPTotal,
+			},
+			Config: types.IgnitionConfig{
+				Replace: translateConfigReference(old.Ignition.Config.Replace),
+				Append:  translateConfigReferenceSlice(old.Ignition.Config.Append),
+			},
+			Security: types.Security{
+				TLS: types.TLS{
+					CertificateAuthorities: translateCertificateAuthoritySlice(old.Ignition.Security.TLS.CertificateAuthorities),
+				},
+			},
+		},
+		Networkd: types.Networkd{
+			Units: translateNetworkdUnitSlice(old.Networkd.Units),
+		},
+		Passwd: types.Passwd{
+			Groups: translatePasswdGroupSlice(old.Passwd.Groups),
+			Users:  translatePasswdUserSlice(old.Passwd.Users),
+		},
+		Storage: types.Storage{
+			Directories: translateDirectorySlice(old.Storage.Directories),
+			Disks:       translateDiskSlice(old.Storage.Disks),
+			Files:       translateFileSlice(old.Storage.Files),
+			Filesystems: translateFilesystemSlice(old.Storage.Filesystems),
+			Links:       translateLinkSlice(old.Storage.Links),
+			Raid:        translateRaidSlice(old.Storage.Raid),
+		},
+		Systemd: types.Systemd{
+			Units: translateSystemdUnitSlice(old.Systemd.Units),
+		},
+	}
+	return config
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/ca.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/ca.go
new file mode 100644
index 00000000..313b3ad5
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/ca.go
@@ -0,0 +1,27 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c CaReference) ValidateSource() report.Report {
+	err := validateURL(c.Source)
+	if err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/config.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/config.go
new file mode 100644
index 00000000..0247fcc3
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/config.go
@@ -0,0 +1,91 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 2,
+		Minor: 3,
+	}
+)
+
+func (c Config) Validate() report.Report {
+	r := report.Report{}
+	rules := []rule{
+		checkFilesFilesystems,
+		checkDuplicateFilesystems,
+	}
+
+	for _, rule := range rules {
+		rule(c, &r)
+	}
+	return r
+}
+
+type rule func(cfg Config, report *report.Report)
+
+func checkNodeFilesystems(node Node, filesystems map[string]struct{}, nodeType string) report.Report {
+	r := report.Report{}
+	if node.Filesystem == "" {
+		// Filesystem was not specified. This is an error, but its handled in types.File's Validate, not here
+		return r
+	}
+	_, ok := filesystems[node.Filesystem]
+	if !ok {
+		r.Add(report.Entry{
+			Kind: report.EntryWarning,
+			Message: fmt.Sprintf("%v %q references nonexistent filesystem %q. (This is ok if it is defined in a referenced config)",
+				nodeType, node.Path, node.Filesystem),
+		})
+	}
+	return r
+}
+
+func checkFilesFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		filesystems[filesystem.Name] = struct{}{}
+	}
+	for _, file := range cfg.Storage.Files {
+		r.Merge(checkNodeFilesystems(file.Node, filesystems, "File"))
+	}
+	for _, link := range cfg.Storage.Links {
+		r.Merge(checkNodeFilesystems(link.Node, filesystems, "Link"))
+	}
+	for _, dir := range cfg.Storage.Directories {
+		r.Merge(checkNodeFilesystems(dir.Node, filesystems, "Directory"))
+	}
+}
+
+func checkDuplicateFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		if _, ok := filesystems[filesystem.Name]; ok {
+			r.Add(report.Entry{
+				Kind:    report.EntryWarning,
+				Message: fmt.Sprintf("Filesystem %q shadows exising filesystem definition", filesystem.Name),
+			})
+		}
+		filesystems[filesystem.Name] = struct{}{}
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/directory.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/directory.go
new file mode 100644
index 00000000..50ded7dd
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/directory.go
@@ -0,0 +1,37 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (d Directory) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(d.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if d.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/disk.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/disk.go
new file mode 100644
index 00000000..9af1ca19
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/disk.go
@@ -0,0 +1,164 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Disk) Validate() report.Report {
+	return report.Report{}
+}
+
+func (n Disk) ValidateDevice() report.Report {
+	if len(n.Device) == 0 {
+		return report.ReportFromError(errors.ErrDiskDeviceRequired, report.EntryError)
+	}
+	if err := validatePath(string(n.Device)); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (n Disk) ValidatePartitions() report.Report {
+	r := report.Report{}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsOverlap.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsMisaligned.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMixZeroesAndNonexistence() {
+		r.Add(report.Entry{
+			Message: errors.ErrZeroesWithShouldNotExist.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsUnitsMismatch() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsUnitsMismatch.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	// Disks which have no errors at this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], p)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
+func (p Partition) end() int {
+	if *p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return *p.Start
+	}
+	return *p.Start + *p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == nil || p.Size == nil || *p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if o.Start == nil || o.Size == nil || p == o || *o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if *p.Start >= *o.Start && *p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= *o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if *p.Start < *o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if p.Start != nil && ((*p.Start & (2048 - 1)) != 0) {
+			return true
+		}
+	}
+	return false
+}
+
+func (n Disk) partitionsMixZeroesAndNonexistence() bool {
+	hasZero := false
+	hasShouldNotExist := false
+	for _, p := range n.Partitions {
+		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
+		hasZero = hasZero || (p.Number == 0)
+	}
+	return hasZero && hasShouldNotExist
+}
+
+func (n Disk) partitionsUnitsMismatch() bool {
+	partsInMb := false
+	partsNotInMb := false
+	for _, p := range n.Partitions {
+		if p.Size != nil || p.Start != nil {
+			partsNotInMb = true
+		}
+		if p.SizeMiB != nil || p.StartMiB != nil {
+			partsInMb = true
+		}
+	}
+	return partsInMb && partsNotInMb
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/file.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/file.go
new file mode 100644
index 00000000..b59d08c3
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/file.go
@@ -0,0 +1,71 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f File) Validate() report.Report {
+	if f.Overwrite != nil && *f.Overwrite && f.Append {
+		return report.ReportFromError(errors.ErrAppendAndOverwrite, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (f File) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(f.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateCompression() report.Report {
+	r := report.Report{}
+	switch fc.Compression {
+	case "", "gzip":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrCompressionInvalid.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(fc.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("invalid url %q: %v", fc.Source, err),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/filesystem.go
new file mode 100644
index 00000000..9226e373
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/filesystem.go
@@ -0,0 +1,146 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f Filesystem) Validate() report.Report {
+	r := report.Report{}
+	if f.Mount == nil && f.Path == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemNoMountPath.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mount != nil {
+		if f.Path != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrFilesystemMountAndPath.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if f.Mount.Create != nil {
+			if f.Mount.WipeFilesystem {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndWipeFilesystem.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			if len(f.Mount.Options) > 0 {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndMountOpts.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			r.Add(report.Entry{
+				Message: errors.ErrWarningCreateDeprecated.Error(),
+				Kind:    report.EntryWarning,
+			})
+		}
+	}
+	return r
+}
+
+func (f Filesystem) ValidatePath() report.Report {
+	r := report.Report{}
+	if f.Path != nil && validatePath(*f.Path) != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("filesystem %q: path not absolute", f.Name),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) Validate() report.Report {
+	r := report.Report{}
+	switch m.Format {
+	case "ext4", "btrfs", "xfs", "swap", "vfat":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemInvalidFormat.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateDevice() report.Report {
+	r := report.Report{}
+	if err := validatePath(m.Device); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateLabel() report.Report {
+	r := report.Report{}
+	if m.Label == nil {
+		return r
+	}
+	switch m.Format {
+	case "ext4":
+		if len(*m.Label) > 16 {
+			// source: man mkfs.ext4
+			r.Add(report.Entry{
+				Message: errors.ErrExt4LabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "btrfs":
+		if len(*m.Label) > 256 {
+			// source: man mkfs.btrfs
+			r.Add(report.Entry{
+				Message: errors.ErrBtrfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "xfs":
+		if len(*m.Label) > 12 {
+			// source: man mkfs.xfs
+			r.Add(report.Entry{
+				Message: errors.ErrXfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "swap":
+		// mkswap's man page does not state a limit on label size, but through
+		// experimentation it appears that mkswap will truncate long labels to
+		// 15 characters, so let's enforce that.
+		if len(*m.Label) > 15 {
+			r.Add(report.Entry{
+				Message: errors.ErrSwapLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "vfat":
+		if len(*m.Label) > 11 {
+			// source: man mkfs.fat
+			r.Add(report.Entry{
+				Message: errors.ErrVfatLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/ignition.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/ignition.go
new file mode 100644
index 00000000..e7a0d520
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/ignition.go
@@ -0,0 +1,52 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c ConfigReference) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (v Ignition) Semver() (*semver.Version, error) {
+	return semver.NewVersion(v.Version)
+}
+
+func (v Ignition) Validate() report.Report {
+	tv, err := v.Semver()
+	if err != nil {
+		return report.ReportFromError(errors.ErrInvalidVersion, report.EntryError)
+	}
+	if MaxVersion.Major > tv.Major {
+		return report.ReportFromError(errors.ErrOldVersion, report.EntryError)
+	}
+	if MaxVersion.LessThan(*tv) {
+		return report.ReportFromError(errors.ErrNewVersion, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/mode.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/mode.go
new file mode 100644
index 00000000..b746217c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/mode.go
@@ -0,0 +1,26 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateMode(m *int) error {
+	if m != nil && (*m < 0 || *m > 07777) {
+		return errors.ErrFileIllegalMode
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/node.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/node.go
new file mode 100644
index 00000000..dd0489c0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/node.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path/filepath"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Node) ValidateFilesystem() report.Report {
+	r := report.Report{}
+	if n.Filesystem == "" {
+		r.Add(report.Entry{
+			Message: errors.ErrNoFilesystem.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) ValidatePath() report.Report {
+	r := report.Report{}
+	if err := validatePath(n.Path); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) Depth() int {
+	count := 0
+	for p := filepath.Clean(string(n.Path)); p != "/"; count++ {
+		p = filepath.Dir(p)
+	}
+	return count
+}
+
+func (nu NodeUser) Validate() report.Report {
+	r := report.Report{}
+	if nu.ID != nil && nu.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+func (ng NodeGroup) Validate() report.Report {
+	r := report.Report{}
+	if ng.ID != nil && ng.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/partition.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/partition.go
new file mode 100644
index 00000000..99a993e9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/partition.go
@@ -0,0 +1,112 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+const (
+	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
+)
+
+func (p Partition) Validate() report.Report {
+	r := report.Report{}
+	if (p.Start != nil || p.Size != nil) && (p.StartMiB != nil || p.SizeMiB != nil) {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsUnitsMismatch.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if p.ShouldExist != nil && !*p.ShouldExist &&
+		(p.Label != nil || p.TypeGUID != "" || p.GUID != "" || p.Start != nil || p.Size != nil) {
+		r.Add(report.Entry{
+			Message: errors.ErrShouldNotExistWithOthers.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateSize() report.Report {
+	if p.Size != nil {
+		return report.ReportFromError(errors.ErrSizeDeprecated, report.EntryDeprecated)
+	}
+	return report.Report{}
+}
+
+func (p Partition) ValidateStart() report.Report {
+	if p.Start != nil {
+		return report.ReportFromError(errors.ErrStartDeprecated, report.EntryDeprecated)
+	}
+	return report.Report{}
+}
+
+func (p Partition) ValidateLabel() report.Report {
+	r := report.Report{}
+	if p.Label == nil {
+		return r
+	}
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(*p.Label) > 36 {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelTooLong.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
+	if strings.Contains(*p.Label, ":") {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelContainsColon.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateTypeGUID() report.Report {
+	return validateGUID(p.TypeGUID)
+}
+
+func (p Partition) ValidateGUID() report.Report {
+	return validateGUID(p.GUID)
+}
+
+func validateGUID(guid string) report.Report {
+	r := report.Report{}
+	ok, err := regexp.MatchString(guidRegexStr, guid)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("error matching guid regexp: %v", err),
+			Kind:    report.EntryError,
+		})
+	} else if !ok {
+		r.Add(report.Entry{
+			Message: errors.ErrDoesntMatchGUIDRegex.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/passwd.go
new file mode 100644
index 00000000..095ddc5e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/passwd.go
@@ -0,0 +1,67 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (p PasswdUser) Validate() report.Report {
+	r := report.Report{}
+	if p.Create != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPasswdCreateDeprecated.Error(),
+			Kind:    report.EntryWarning,
+		})
+		addErr := func(err error) {
+			r.Add(report.Entry{
+				Message: err.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if p.Gecos != "" {
+			addErr(errors.ErrPasswdCreateAndGecos)
+		}
+		if len(p.Groups) > 0 {
+			addErr(errors.ErrPasswdCreateAndGroups)
+		}
+		if p.HomeDir != "" {
+			addErr(errors.ErrPasswdCreateAndHomeDir)
+		}
+		if p.NoCreateHome {
+			addErr(errors.ErrPasswdCreateAndNoCreateHome)
+		}
+		if p.NoLogInit {
+			addErr(errors.ErrPasswdCreateAndNoLogInit)
+		}
+		if p.NoUserGroup {
+			addErr(errors.ErrPasswdCreateAndNoUserGroup)
+		}
+		if p.PrimaryGroup != "" {
+			addErr(errors.ErrPasswdCreateAndPrimaryGroup)
+		}
+		if p.Shell != "" {
+			addErr(errors.ErrPasswdCreateAndShell)
+		}
+		if p.System {
+			addErr(errors.ErrPasswdCreateAndSystem)
+		}
+		if p.UID != nil {
+			addErr(errors.ErrPasswdCreateAndUID)
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/path.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/path.go
new file mode 100644
index 00000000..f52ec956
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/path.go
@@ -0,0 +1,28 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validatePath(p string) error {
+	if !path.IsAbs(p) {
+		return errors.ErrPathRelative
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/raid.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/raid.go
new file mode 100644
index 00000000..87a10ee7
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/raid.go
@@ -0,0 +1,57 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Raid) ValidateLevel() report.Report {
+	r := report.Report{}
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			r.Add(report.Entry{
+				Message: errors.ErrSparesUnsupportedForLevel.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnrecognizedRaidLevel.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Raid) ValidateDevices() report.Report {
+	r := report.Report{}
+	for _, d := range n.Devices {
+		if err := validatePath(string(d)); err != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrPathRelative.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/schema.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/schema.go
new file mode 100644
index 00000000..5f91b71e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/schema.go
@@ -0,0 +1,250 @@
+package types
+
+// generated by "schematyper --package=types schema/ignition.json -o internal/config/types/schema.go --root-type=Config" -- DO NOT EDIT
+
+type CaReference struct {
+	Source       string       `json:"source"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Config struct {
+	Ignition Ignition `json:"ignition"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+}
+
+type ConfigReference struct {
+	Source       string       `json:"source"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Create struct {
+	Force   bool           `json:"force,omitempty"`
+	Options []CreateOption `json:"options,omitempty"`
+}
+
+type CreateOption string
+
+type Device string
+
+type Directory struct {
+	Node
+	DirectoryEmbedded1
+}
+
+type DirectoryEmbedded1 struct {
+	Mode *int `json:"mode,omitempty"`
+}
+
+type Disk struct {
+	Device     string      `json:"device"`
+	Partitions []Partition `json:"partitions,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+}
+
+type File struct {
+	Node
+	FileEmbedded1
+}
+
+type FileContents struct {
+	Compression  string       `json:"compression,omitempty"`
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type FileEmbedded1 struct {
+	Append   bool         `json:"append,omitempty"`
+	Contents FileContents `json:"contents,omitempty"`
+	Mode     *int         `json:"mode,omitempty"`
+}
+
+type Filesystem struct {
+	Mount *Mount  `json:"mount,omitempty"`
+	Name  string  `json:"name,omitempty"`
+	Path  *string `json:"path,omitempty"`
+}
+
+type Group string
+
+type Ignition struct {
+	Config   IgnitionConfig `json:"config,omitempty"`
+	Security Security       `json:"security,omitempty"`
+	Timeouts Timeouts       `json:"timeouts,omitempty"`
+	Version  string         `json:"version,omitempty"`
+}
+
+type IgnitionConfig struct {
+	Append  []ConfigReference `json:"append,omitempty"`
+	Replace *ConfigReference  `json:"replace,omitempty"`
+}
+
+type Link struct {
+	Node
+	LinkEmbedded1
+}
+
+type LinkEmbedded1 struct {
+	Hard   bool   `json:"hard,omitempty"`
+	Target string `json:"target"`
+}
+
+type Mount struct {
+	Create         *Create       `json:"create,omitempty"`
+	Device         string        `json:"device"`
+	Format         string        `json:"format"`
+	Label          *string       `json:"label,omitempty"`
+	Options        []MountOption `json:"options,omitempty"`
+	UUID           *string       `json:"uuid,omitempty"`
+	WipeFilesystem bool          `json:"wipeFilesystem,omitempty"`
+}
+
+type MountOption string
+
+type Networkd struct {
+	Units []Networkdunit `json:"units,omitempty"`
+}
+
+type NetworkdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name"`
+}
+
+type Networkdunit struct {
+	Contents string           `json:"contents,omitempty"`
+	Dropins  []NetworkdDropin `json:"dropins,omitempty"`
+	Name     string           `json:"name"`
+}
+
+type Node struct {
+	Filesystem string     `json:"filesystem"`
+	Group      *NodeGroup `json:"group,omitempty"`
+	Overwrite  *bool      `json:"overwrite,omitempty"`
+	Path       string     `json:"path"`
+	User       *NodeUser  `json:"user,omitempty"`
+}
+
+type NodeGroup struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type NodeUser struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type Partition struct {
+	GUID               string  `json:"guid,omitempty"`
+	Label              *string `json:"label,omitempty"`
+	Number             int     `json:"number,omitempty"`
+	ShouldExist        *bool   `json:"shouldExist,omitempty"`
+	Size               *int    `json:"size,omitempty"`
+	SizeMiB            *int    `json:"sizeMiB,omitempty"`
+	Start              *int    `json:"start,omitempty"`
+	StartMiB           *int    `json:"startMiB,omitempty"`
+	TypeGUID           string  `json:"typeGuid,omitempty"`
+	WipePartitionEntry bool    `json:"wipePartitionEntry,omitempty"`
+}
+
+type Passwd struct {
+	Groups []PasswdGroup `json:"groups,omitempty"`
+	Users  []PasswdUser  `json:"users,omitempty"`
+}
+
+type PasswdGroup struct {
+	Gid          *int   `json:"gid,omitempty"`
+	Name         string `json:"name"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
+
+type PasswdUser struct {
+	Create            *Usercreate        `json:"create,omitempty"`
+	Gecos             string             `json:"gecos,omitempty"`
+	Groups            []Group            `json:"groups,omitempty"`
+	HomeDir           string             `json:"homeDir,omitempty"`
+	Name              string             `json:"name"`
+	NoCreateHome      bool               `json:"noCreateHome,omitempty"`
+	NoLogInit         bool               `json:"noLogInit,omitempty"`
+	NoUserGroup       bool               `json:"noUserGroup,omitempty"`
+	PasswordHash      *string            `json:"passwordHash,omitempty"`
+	PrimaryGroup      string             `json:"primaryGroup,omitempty"`
+	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
+	Shell             string             `json:"shell,omitempty"`
+	System            bool               `json:"system,omitempty"`
+	UID               *int               `json:"uid,omitempty"`
+}
+
+type Raid struct {
+	Devices []Device     `json:"devices"`
+	Level   string       `json:"level"`
+	Name    string       `json:"name"`
+	Options []RaidOption `json:"options,omitempty"`
+	Spares  int          `json:"spares,omitempty"`
+}
+
+type RaidOption string
+
+type SSHAuthorizedKey string
+
+type Security struct {
+	TLS `json:"tls,omitempty"`
+}
+
+type Storage struct {
+	Directories []Directory  `json:"directories,omitempty"`
+	Disks       []Disk       `json:"disks,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Links       []Link       `json:"links,omitempty"`
+	Raid        []Raid       `json:"raid,omitempty"`
+}
+
+type Systemd struct {
+	Units []Unit `json:"units,omitempty"`
+}
+
+type SystemdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name"`
+}
+
+type TLS struct {
+	CertificateAuthorities []CaReference `json:"certificateAuthorities,omitempty"`
+}
+
+type Timeouts struct {
+	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
+	HTTPTotal           *int `json:"httpTotal,omitempty"`
+}
+
+type Unit struct {
+	Contents string          `json:"contents,omitempty"`
+	Dropins  []SystemdDropin `json:"dropins,omitempty"`
+	Enable   bool            `json:"enable,omitempty"`
+	Enabled  *bool           `json:"enabled,omitempty"`
+	Mask     bool            `json:"mask,omitempty"`
+	Name     string          `json:"name"`
+}
+
+type Usercreate struct {
+	Gecos        string            `json:"gecos,omitempty"`
+	Groups       []UsercreateGroup `json:"groups,omitempty"`
+	HomeDir      string            `json:"homeDir,omitempty"`
+	NoCreateHome bool              `json:"noCreateHome,omitempty"`
+	NoLogInit    bool              `json:"noLogInit,omitempty"`
+	NoUserGroup  bool              `json:"noUserGroup,omitempty"`
+	PrimaryGroup string            `json:"primaryGroup,omitempty"`
+	Shell        string            `json:"shell,omitempty"`
+	System       bool              `json:"system,omitempty"`
+	UID          *int              `json:"uid,omitempty"`
+}
+
+type UsercreateGroup string
+
+type Verification struct {
+	Hash *string `json:"hash,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/unit.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/unit.go
new file mode 100644
index 00000000..3d57428e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/unit.go
@@ -0,0 +1,131 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"path"
+	"strings"
+
+	"github.com/coreos/go-systemd/unit"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/shared/validations"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (u Unit) ValidateContents() report.Report {
+	r := report.Report{}
+	opts, err := validateUnitContent(u.Contents)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	isEnabled := u.Enable || (u.Enabled != nil && *u.Enabled)
+	r.Merge(validations.ValidateInstallSection(u.Name, isEnabled, u.Contents == "", opts))
+
+	return r
+}
+
+func (u Unit) ValidateName() report.Report {
+	r := report.Report{}
+	switch path.Ext(u.Name) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (d SystemdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (u Networkdunit) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(u.Name) {
+	case ".link", ".netdev", ".network":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (d NetworkdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func validateUnitContent(content string) ([]*unit.UnitOption, error) {
+	c := strings.NewReader(content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/url.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/url.go
new file mode 100644
index 00000000..aedd9a56
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/url.go
@@ -0,0 +1,53 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/vincent-petithory/dataurl"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateURL(s string) error {
+	// Empty url is valid, indicates an empty file
+	if s == "" {
+		return nil
+	}
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https", "oem", "tftp":
+		return nil
+	case "s3":
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "data":
+		if _, err := dataurl.DecodeString(s); err != nil {
+			return err
+		}
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_3/types/verification.go b/vendor/github.com/flatcar/ignition/config/v2_3/types/verification.go
new file mode 100644
index 00000000..cb06d76e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_3/types/verification.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+// HashParts will return the sum and function (in that order) of the hash stored
+// in this Verification, or an error if there is an issue during parsing.
+func (v Verification) HashParts() (string, string, error) {
+	if v.Hash == nil {
+		// The hash can be nil
+		return "", "", nil
+	}
+	parts := strings.SplitN(*v.Hash, "-", 2)
+	if len(parts) != 2 {
+		return "", "", errors.ErrHashMalformed
+	}
+
+	return parts[0], parts[1], nil
+}
+
+func (v Verification) Validate() report.Report {
+	r := report.Report{}
+
+	if v.Hash == nil {
+		// The hash can be nil
+		return r
+	}
+
+	function, sum, err := v.HashParts()
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+	var hash crypto.Hash
+	switch function {
+	case "sha512":
+		hash = crypto.SHA512
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrHashUnrecognized.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	if len(sum) != hex.EncodedLen(hash.Size()) {
+		r.Add(report.Entry{
+			Message: errors.ErrHashWrongSize.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/append.go b/vendor/github.com/flatcar/ignition/config/v2_4/append.go
new file mode 100644
index 00000000..8df08d42
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/append.go
@@ -0,0 +1,76 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_4
+
+import (
+	"reflect"
+
+	"github.com/flatcar/ignition/config/v2_4/types"
+)
+
+// Append appends newConfig to oldConfig and returns the result. Appending one
+// config to another is accomplished by iterating over every field in the
+// config structure, appending slices, recursively appending structs, and
+// overwriting old values with new values for all other types.
+func Append(oldConfig, newConfig types.Config) types.Config {
+	vOld := reflect.ValueOf(oldConfig)
+	vNew := reflect.ValueOf(newConfig)
+
+	vResult := appendStruct(vOld, vNew)
+
+	return vResult.Interface().(types.Config)
+}
+
+// appendStruct is an internal helper function to AppendConfig. Given two values
+// of structures (assumed to be the same type), recursively iterate over every
+// field in the struct, appending slices, recursively appending structs, and
+// overwriting old values with the new for all other types. Some individual
+// struct fields have alternate merge strategies, determined by the field name.
+// Currently these fields are "ignition.version", which uses the old value, and
+// "ignition.config" which uses the new value.
+func appendStruct(vOld, vNew reflect.Value) reflect.Value {
+	tOld := vOld.Type()
+	vRes := reflect.New(tOld)
+
+	for i := 0; i < tOld.NumField(); i++ {
+		vfOld := vOld.Field(i)
+		vfNew := vNew.Field(i)
+		vfRes := vRes.Elem().Field(i)
+
+		switch tOld.Field(i).Name {
+		case "Version":
+			vfRes.Set(vfOld)
+			continue
+		case "Config":
+			vfRes.Set(vfNew)
+			continue
+		}
+
+		switch vfOld.Type().Kind() {
+		case reflect.Struct:
+			vfRes.Set(appendStruct(vfOld, vfNew))
+		case reflect.Slice:
+			vfRes.Set(reflect.AppendSlice(vfOld, vfNew))
+		default:
+			if vfNew.Kind() == reflect.Ptr && vfNew.IsNil() {
+				vfRes.Set(vfOld)
+			} else {
+				vfRes.Set(vfNew)
+			}
+		}
+	}
+
+	return vRes.Elem()
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/cloudinit.go b/vendor/github.com/flatcar/ignition/config/v2_4/cloudinit.go
new file mode 100644
index 00000000..0c428e62
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/cloudinit.go
@@ -0,0 +1,53 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// These functions are copied from github.com/coreos/coreos-cloudinit/config.
+
+package v2_4
+
+import (
+	"bytes"
+	"compress/gzip"
+	"io/ioutil"
+	"strings"
+	"unicode"
+)
+
+func isCloudConfig(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+
+	// Trim trailing whitespaces
+	header = strings.TrimRightFunc(header, unicode.IsSpace)
+
+	return (header == "#cloud-config")
+}
+
+func isScript(userdata []byte) bool {
+	header := strings.SplitN(string(decompressIfGzipped(userdata)), "\n", 2)[0]
+	return strings.HasPrefix(header, "#!")
+}
+
+func decompressIfGzipped(data []byte) []byte {
+	if reader, err := gzip.NewReader(bytes.NewReader(data)); err == nil {
+		uncompressedData, err := ioutil.ReadAll(reader)
+		reader.Close()
+		if err == nil {
+			return uncompressedData
+		} else {
+			return data
+		}
+	} else {
+		return data
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/config.go b/vendor/github.com/flatcar/ignition/config/v2_4/config.go
new file mode 100644
index 00000000..e6120bda
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/config.go
@@ -0,0 +1,70 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_4
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/v2_3"
+	"github.com/flatcar/ignition/config/v2_4/types"
+	"github.com/flatcar/ignition/config/validate"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/coreos/go-semver/semver"
+)
+
+// Parse parses the raw config into a types.Config struct and generates a report of any
+// errors, warnings, info, and deprecations it encountered
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if isEmpty(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	} else if isCloudConfig(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrCloudConfig
+	} else if isScript(rawConfig) {
+		return types.Config{}, report.Report{}, errors.ErrScript
+	}
+
+	var err error
+	var config types.Config
+
+	err = json.Unmarshal(rawConfig, &config)
+
+	version, semverErr := semver.NewVersion(config.Ignition.Version)
+
+	if err != nil || semverErr != nil || version.LessThan(types.MaxVersion) {
+		// We can fail unmarshaling if it's an older config. Attempt to parse
+		// it as such.
+		config, rpt, err := v2_3.Parse(rawConfig)
+		if err != nil {
+			return types.Config{}, rpt, err
+		}
+		return Translate(config), rpt, err
+	}
+
+	if *version != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateConfig(rawConfig, config)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+func isEmpty(userdata []byte) bool {
+	return len(userdata) == 0
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/translate.go b/vendor/github.com/flatcar/ignition/config/v2_4/translate.go
new file mode 100644
index 00000000..357015a8
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/translate.go
@@ -0,0 +1,398 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v2_4
+
+import (
+	from "github.com/flatcar/ignition/config/v2_3/types"
+	"github.com/flatcar/ignition/config/v2_4/types"
+)
+
+func intToPtr(x int) *int {
+	return &x
+}
+
+func strToPtr(s string) *string {
+	if s == "" {
+		return nil
+	}
+	return &s
+}
+
+func boolToPtr(b bool) *bool {
+	return &b
+}
+
+func Translate(old from.Config) types.Config {
+	translateConfigReference := func(old *from.ConfigReference) *types.ConfigReference {
+		if old == nil {
+			return nil
+		}
+		return &types.ConfigReference{
+			Source: old.Source,
+			Verification: types.Verification{
+				Hash: old.Verification.Hash,
+			},
+		}
+	}
+	translateConfigReferenceSlice := func(old []from.ConfigReference) []types.ConfigReference {
+		var res []types.ConfigReference
+		for _, c := range old {
+			res = append(res, *translateConfigReference(&c))
+		}
+		return res
+	}
+	translateCertificateAuthoritySlice := func(old []from.CaReference) []types.CaReference {
+		var res []types.CaReference
+		for _, x := range old {
+			res = append(res, types.CaReference{
+				Source: x.Source,
+				Verification: types.Verification{
+					Hash: x.Verification.Hash,
+				},
+			})
+		}
+		return res
+	}
+	translateNetworkdDropinSlice := func(old []from.NetworkdDropin) []types.NetworkdDropin {
+		var res []types.NetworkdDropin
+		for _, x := range old {
+			res = append(res, types.NetworkdDropin{
+				Contents: x.Contents,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	translateNetworkdUnitSlice := func(old []from.Networkdunit) []types.Networkdunit {
+		var res []types.Networkdunit
+		for _, u := range old {
+			res = append(res, types.Networkdunit{
+				Contents: u.Contents,
+				Name:     u.Name,
+				Dropins:  translateNetworkdDropinSlice(u.Dropins),
+			})
+		}
+		return res
+	}
+	translatePasswdGroupSlice := func(old []from.PasswdGroup) []types.PasswdGroup {
+		var res []types.PasswdGroup
+		for _, g := range old {
+			res = append(res, types.PasswdGroup{
+				Gid:          g.Gid,
+				Name:         g.Name,
+				PasswordHash: g.PasswordHash,
+				System:       g.System,
+			})
+		}
+		return res
+	}
+	translatePasswdUsercreateGroupSlice := func(old []from.UsercreateGroup) []types.UsercreateGroup {
+		var res []types.UsercreateGroup
+		for _, g := range old {
+			res = append(res, types.UsercreateGroup(g))
+		}
+		return res
+	}
+	translatePasswdUsercreate := func(old *from.Usercreate) *types.Usercreate {
+		if old == nil {
+			return nil
+		}
+		return &types.Usercreate{
+			Gecos:        old.Gecos,
+			Groups:       translatePasswdUsercreateGroupSlice(old.Groups),
+			HomeDir:      old.HomeDir,
+			NoCreateHome: old.NoCreateHome,
+			NoLogInit:    old.NoLogInit,
+			NoUserGroup:  old.NoUserGroup,
+			PrimaryGroup: old.PrimaryGroup,
+			Shell:        old.Shell,
+			System:       old.System,
+			UID:          old.UID,
+		}
+	}
+	translatePasswdUserGroupSlice := func(old []from.Group) []types.Group {
+		var res []types.Group
+		for _, g := range old {
+			res = append(res, types.Group(g))
+		}
+		return res
+	}
+	translatePasswdSSHAuthorizedKeySlice := func(old []from.SSHAuthorizedKey) []types.SSHAuthorizedKey {
+		res := make([]types.SSHAuthorizedKey, len(old))
+		for i, k := range old {
+			res[i] = types.SSHAuthorizedKey(k)
+		}
+		return res
+	}
+	translatePasswdUserSlice := func(old []from.PasswdUser) []types.PasswdUser {
+		var res []types.PasswdUser
+		for _, u := range old {
+			res = append(res, types.PasswdUser{
+				Create:            translatePasswdUsercreate(u.Create),
+				Gecos:             u.Gecos,
+				Groups:            translatePasswdUserGroupSlice(u.Groups),
+				HomeDir:           u.HomeDir,
+				Name:              u.Name,
+				NoCreateHome:      u.NoCreateHome,
+				NoLogInit:         u.NoLogInit,
+				NoUserGroup:       u.NoUserGroup,
+				PasswordHash:      u.PasswordHash,
+				PrimaryGroup:      u.PrimaryGroup,
+				SSHAuthorizedKeys: translatePasswdSSHAuthorizedKeySlice(u.SSHAuthorizedKeys),
+				Shell:             u.Shell,
+				System:            u.System,
+				UID:               u.UID,
+			})
+		}
+		return res
+	}
+	translateNodeGroup := func(old *from.NodeGroup) *types.NodeGroup {
+		if old == nil {
+			return nil
+		}
+		return &types.NodeGroup{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNodeUser := func(old *from.NodeUser) *types.NodeUser {
+		if old == nil {
+			return nil
+		}
+		return &types.NodeUser{
+			ID:   old.ID,
+			Name: old.Name,
+		}
+	}
+	translateNode := func(old from.Node) types.Node {
+		return types.Node{
+			Filesystem: old.Filesystem,
+			Group:      translateNodeGroup(old.Group),
+			Path:       old.Path,
+			User:       translateNodeUser(old.User),
+			Overwrite:  old.Overwrite,
+		}
+	}
+	translateDirectorySlice := func(old []from.Directory) []types.Directory {
+		var res []types.Directory
+		for _, x := range old {
+			res = append(res, types.Directory{
+				Node: translateNode(x.Node),
+				DirectoryEmbedded1: types.DirectoryEmbedded1{
+					Mode: x.DirectoryEmbedded1.Mode,
+				},
+			})
+		}
+		return res
+	}
+	translatePartitionSlice := func(old []from.Partition) []types.Partition {
+		var res []types.Partition
+		for _, x := range old {
+			res = append(res, types.Partition{
+				GUID:               x.GUID,
+				Label:              x.Label,
+				Number:             x.Number,
+				Size:               x.Size,
+				SizeMiB:            x.SizeMiB,
+				Start:              x.Start,
+				StartMiB:           x.StartMiB,
+				TypeGUID:           x.TypeGUID,
+				ShouldExist:        x.ShouldExist,
+				WipePartitionEntry: x.WipePartitionEntry,
+			})
+		}
+		return res
+	}
+	translateDiskSlice := func(old []from.Disk) []types.Disk {
+		var res []types.Disk
+		for _, x := range old {
+			res = append(res, types.Disk{
+				Device:     x.Device,
+				Partitions: translatePartitionSlice(x.Partitions),
+				WipeTable:  x.WipeTable,
+			})
+		}
+		return res
+	}
+	translateFileSlice := func(old []from.File) []types.File {
+		var res []types.File
+		for _, x := range old {
+			res = append(res, types.File{
+				Node: translateNode(x.Node),
+				FileEmbedded1: types.FileEmbedded1{
+					Contents: types.FileContents{
+						Compression: x.Contents.Compression,
+						Source:      x.Contents.Source,
+						Verification: types.Verification{
+							Hash: x.Contents.Verification.Hash,
+						},
+					},
+					Mode:   x.Mode,
+					Append: x.Append,
+				},
+			})
+		}
+		return res
+	}
+	translateMountCreateOptionSlice := func(old []from.CreateOption) []types.CreateOption {
+		var res []types.CreateOption
+		for _, x := range old {
+			res = append(res, types.CreateOption(x))
+		}
+		return res
+	}
+	translateMountCreate := func(old *from.Create) *types.Create {
+		if old == nil {
+			return nil
+		}
+		return &types.Create{
+			Force:   old.Force,
+			Options: translateMountCreateOptionSlice(old.Options),
+		}
+	}
+	translateMountOptionSlice := func(old []from.MountOption) []types.MountOption {
+		var res []types.MountOption
+		for _, x := range old {
+			res = append(res, types.MountOption(x))
+		}
+		return res
+	}
+	translateMount := func(old *from.Mount) *types.Mount {
+		if old == nil {
+			return nil
+		}
+		return &types.Mount{
+			Create:         translateMountCreate(old.Create),
+			Device:         old.Device,
+			Format:         old.Format,
+			Label:          old.Label,
+			Options:        translateMountOptionSlice(old.Options),
+			UUID:           old.UUID,
+			WipeFilesystem: old.WipeFilesystem,
+		}
+	}
+	translateFilesystemSlice := func(old []from.Filesystem) []types.Filesystem {
+		var res []types.Filesystem
+		for _, x := range old {
+			res = append(res, types.Filesystem{
+				Mount: translateMount(x.Mount),
+				Name:  x.Name,
+				Path:  x.Path,
+			})
+		}
+		return res
+	}
+	translateLinkSlice := func(old []from.Link) []types.Link {
+		var res []types.Link
+		for _, x := range old {
+			res = append(res, types.Link{
+				Node: translateNode(x.Node),
+				LinkEmbedded1: types.LinkEmbedded1{
+					Hard:   x.Hard,
+					Target: x.Target,
+				},
+			})
+		}
+		return res
+	}
+	translateDeviceSlice := func(old []from.Device) []types.Device {
+		var res []types.Device
+		for _, x := range old {
+			res = append(res, types.Device(x))
+		}
+		return res
+	}
+	translateRaidOptionSlice := func(old []from.RaidOption) []types.RaidOption {
+		var res []types.RaidOption
+		for _, x := range old {
+			res = append(res, types.RaidOption(x))
+		}
+		return res
+	}
+	translateRaidSlice := func(old []from.Raid) []types.Raid {
+		var res []types.Raid
+		for _, x := range old {
+			res = append(res, types.Raid{
+				Devices: translateDeviceSlice(x.Devices),
+				Level:   x.Level,
+				Name:    x.Name,
+				Spares:  x.Spares,
+				Options: translateRaidOptionSlice(x.Options),
+			})
+		}
+		return res
+	}
+	translateSystemdDropinSlice := func(old []from.SystemdDropin) []types.SystemdDropin {
+		var res []types.SystemdDropin
+		for _, x := range old {
+			res = append(res, types.SystemdDropin{
+				Contents: x.Contents,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	translateSystemdUnitSlice := func(old []from.Unit) []types.Unit {
+		var res []types.Unit
+		for _, x := range old {
+			res = append(res, types.Unit{
+				Contents: x.Contents,
+				Dropins:  translateSystemdDropinSlice(x.Dropins),
+				Enable:   x.Enable,
+				Enabled:  x.Enabled,
+				Mask:     x.Mask,
+				Name:     x.Name,
+			})
+		}
+		return res
+	}
+	config := types.Config{
+		Ignition: types.Ignition{
+			Version: types.MaxVersion.String(),
+			Timeouts: types.Timeouts{
+				HTTPResponseHeaders: old.Ignition.Timeouts.HTTPResponseHeaders,
+				HTTPTotal:           old.Ignition.Timeouts.HTTPTotal,
+			},
+			Config: types.IgnitionConfig{
+				Replace: translateConfigReference(old.Ignition.Config.Replace),
+				Append:  translateConfigReferenceSlice(old.Ignition.Config.Append),
+			},
+			Security: types.Security{
+				TLS: types.TLS{
+					CertificateAuthorities: translateCertificateAuthoritySlice(old.Ignition.Security.TLS.CertificateAuthorities),
+				},
+			},
+		},
+		Networkd: types.Networkd{
+			Units: translateNetworkdUnitSlice(old.Networkd.Units),
+		},
+		Passwd: types.Passwd{
+			Groups: translatePasswdGroupSlice(old.Passwd.Groups),
+			Users:  translatePasswdUserSlice(old.Passwd.Users),
+		},
+		Storage: types.Storage{
+			Directories: translateDirectorySlice(old.Storage.Directories),
+			Disks:       translateDiskSlice(old.Storage.Disks),
+			Files:       translateFileSlice(old.Storage.Files),
+			Filesystems: translateFilesystemSlice(old.Storage.Filesystems),
+			Links:       translateLinkSlice(old.Storage.Links),
+			Raid:        translateRaidSlice(old.Storage.Raid),
+		},
+		Systemd: types.Systemd{
+			Units: translateSystemdUnitSlice(old.Systemd.Units),
+		},
+	}
+	return config
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/ca.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/ca.go
new file mode 100644
index 00000000..5b39e7a9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/ca.go
@@ -0,0 +1,58 @@
+// Copyright 2018 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c CaReference) ValidateSource() report.Report {
+	err := validateURL(c.Source)
+	if err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (c CaReference) ValidateHTTPHeaders() report.Report {
+	r := report.Report{}
+
+	if len(c.HTTPHeaders) < 1 {
+		return r
+	}
+
+	u, err := url.Parse(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidUrl.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	switch u.Scheme {
+	case "http", "https":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnsupportedSchemeForHTTPHeaders.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/config.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/config.go
new file mode 100644
index 00000000..0d2fa7fa
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/config.go
@@ -0,0 +1,91 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 2,
+		Minor: 4,
+	}
+)
+
+func (c Config) Validate() report.Report {
+	r := report.Report{}
+	rules := []rule{
+		checkFilesFilesystems,
+		checkDuplicateFilesystems,
+	}
+
+	for _, rule := range rules {
+		rule(c, &r)
+	}
+	return r
+}
+
+type rule func(cfg Config, report *report.Report)
+
+func checkNodeFilesystems(node Node, filesystems map[string]struct{}, nodeType string) report.Report {
+	r := report.Report{}
+	if node.Filesystem == "" {
+		// Filesystem was not specified. This is an error, but its handled in types.File's Validate, not here
+		return r
+	}
+	_, ok := filesystems[node.Filesystem]
+	if !ok {
+		r.Add(report.Entry{
+			Kind: report.EntryWarning,
+			Message: fmt.Sprintf("%v %q references nonexistent filesystem %q. (This is ok if it is defined in a referenced config)",
+				nodeType, node.Path, node.Filesystem),
+		})
+	}
+	return r
+}
+
+func checkFilesFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		filesystems[filesystem.Name] = struct{}{}
+	}
+	for _, file := range cfg.Storage.Files {
+		r.Merge(checkNodeFilesystems(file.Node, filesystems, "File"))
+	}
+	for _, link := range cfg.Storage.Links {
+		r.Merge(checkNodeFilesystems(link.Node, filesystems, "Link"))
+	}
+	for _, dir := range cfg.Storage.Directories {
+		r.Merge(checkNodeFilesystems(dir.Node, filesystems, "Directory"))
+	}
+}
+
+func checkDuplicateFilesystems(cfg Config, r *report.Report) {
+	filesystems := map[string]struct{}{"root": {}}
+	for _, filesystem := range cfg.Storage.Filesystems {
+		if _, ok := filesystems[filesystem.Name]; ok {
+			r.Add(report.Entry{
+				Kind:    report.EntryWarning,
+				Message: fmt.Sprintf("Filesystem %q shadows exising filesystem definition", filesystem.Name),
+			})
+		}
+		filesystems[filesystem.Name] = struct{}{}
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/directory.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/directory.go
new file mode 100644
index 00000000..50ded7dd
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/directory.go
@@ -0,0 +1,37 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (d Directory) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(d.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if d.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/disk.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/disk.go
new file mode 100644
index 00000000..9af1ca19
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/disk.go
@@ -0,0 +1,164 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Disk) Validate() report.Report {
+	return report.Report{}
+}
+
+func (n Disk) ValidateDevice() report.Report {
+	if len(n.Device) == 0 {
+		return report.ReportFromError(errors.ErrDiskDeviceRequired, report.EntryError)
+	}
+	if err := validatePath(string(n.Device)); err != nil {
+		return report.ReportFromError(err, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (n Disk) ValidatePartitions() report.Report {
+	r := report.Report{}
+	if n.partitionNumbersCollide() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionNumbersCollide.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsOverlap() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsOverlap.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMisaligned() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsMisaligned.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsMixZeroesAndNonexistence() {
+		r.Add(report.Entry{
+			Message: errors.ErrZeroesWithShouldNotExist.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if n.partitionsUnitsMismatch() {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsUnitsMismatch.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	// Disks which have no errors at this point will likely succeed in sgdisk
+	return r
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique.
+func (n Disk) partitionNumbersCollide() bool {
+	m := map[int][]Partition{}
+	for _, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], p)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true
+		}
+	}
+	return false
+}
+
+// end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
+func (p Partition) end() int {
+	if *p.Size == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return *p.Start
+	}
+	return *p.Start + *p.Size - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap
+func (n Disk) partitionsOverlap() bool {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.Start == nil || p.Size == nil || *p.Start == 0 {
+			continue
+		}
+
+		for _, o := range n.Partitions {
+			if o.Start == nil || o.Size == nil || p == o || *o.Start == 0 {
+				continue
+			}
+
+			// is p.Start within o?
+			if *p.Start >= *o.Start && *p.Start <= o.end() {
+				return true
+			}
+
+			// is p.end() within o?
+			if p.end() >= *o.Start && p.end() <= o.end() {
+				return true
+			}
+
+			// do p.Start and p.end() straddle o?
+			if *p.Start < *o.Start && p.end() > o.end() {
+				return true
+			}
+		}
+	}
+	return false
+}
+
+// partitionsMisaligned returns true if any of the partitions don't start on a 2048-sector (1MiB) boundary.
+func (n Disk) partitionsMisaligned() bool {
+	for _, p := range n.Partitions {
+		if p.Start != nil && ((*p.Start & (2048 - 1)) != 0) {
+			return true
+		}
+	}
+	return false
+}
+
+func (n Disk) partitionsMixZeroesAndNonexistence() bool {
+	hasZero := false
+	hasShouldNotExist := false
+	for _, p := range n.Partitions {
+		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
+		hasZero = hasZero || (p.Number == 0)
+	}
+	return hasZero && hasShouldNotExist
+}
+
+func (n Disk) partitionsUnitsMismatch() bool {
+	partsInMb := false
+	partsNotInMb := false
+	for _, p := range n.Partitions {
+		if p.Size != nil || p.Start != nil {
+			partsNotInMb = true
+		}
+		if p.SizeMiB != nil || p.StartMiB != nil {
+			partsInMb = true
+		}
+	}
+	return partsInMb && partsNotInMb
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/file.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/file.go
new file mode 100644
index 00000000..45b06739
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/file.go
@@ -0,0 +1,100 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"net/url"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f File) Validate() report.Report {
+	if f.Overwrite != nil && *f.Overwrite && f.Append {
+		return report.ReportFromError(errors.ErrAppendAndOverwrite, report.EntryError)
+	}
+	return report.Report{}
+}
+
+func (f File) ValidateMode() report.Report {
+	r := report.Report{}
+	if err := validateMode(f.Mode); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mode == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPermissionsUnset.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateCompression() report.Report {
+	r := report.Report{}
+	switch fc.Compression {
+	case "", "gzip":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrCompressionInvalid.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(fc.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("invalid url %q: %v", fc.Source, err),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (fc FileContents) ValidateHTTPHeaders() report.Report {
+	r := report.Report{}
+
+	if len(fc.HTTPHeaders) < 1 {
+		return r
+	}
+
+	u, err := url.Parse(fc.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidUrl.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	switch u.Scheme {
+	case "http", "https":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnsupportedSchemeForHTTPHeaders.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/filesystem.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/filesystem.go
new file mode 100644
index 00000000..9226e373
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/filesystem.go
@@ -0,0 +1,146 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (f Filesystem) Validate() report.Report {
+	r := report.Report{}
+	if f.Mount == nil && f.Path == nil {
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemNoMountPath.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if f.Mount != nil {
+		if f.Path != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrFilesystemMountAndPath.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if f.Mount.Create != nil {
+			if f.Mount.WipeFilesystem {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndWipeFilesystem.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			if len(f.Mount.Options) > 0 {
+				r.Add(report.Entry{
+					Message: errors.ErrUsedCreateAndMountOpts.Error(),
+					Kind:    report.EntryError,
+				})
+			}
+			r.Add(report.Entry{
+				Message: errors.ErrWarningCreateDeprecated.Error(),
+				Kind:    report.EntryWarning,
+			})
+		}
+	}
+	return r
+}
+
+func (f Filesystem) ValidatePath() report.Report {
+	r := report.Report{}
+	if f.Path != nil && validatePath(*f.Path) != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("filesystem %q: path not absolute", f.Name),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) Validate() report.Report {
+	r := report.Report{}
+	switch m.Format {
+	case "ext4", "btrfs", "xfs", "swap", "vfat":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrFilesystemInvalidFormat.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateDevice() report.Report {
+	r := report.Report{}
+	if err := validatePath(m.Device); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (m Mount) ValidateLabel() report.Report {
+	r := report.Report{}
+	if m.Label == nil {
+		return r
+	}
+	switch m.Format {
+	case "ext4":
+		if len(*m.Label) > 16 {
+			// source: man mkfs.ext4
+			r.Add(report.Entry{
+				Message: errors.ErrExt4LabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "btrfs":
+		if len(*m.Label) > 256 {
+			// source: man mkfs.btrfs
+			r.Add(report.Entry{
+				Message: errors.ErrBtrfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "xfs":
+		if len(*m.Label) > 12 {
+			// source: man mkfs.xfs
+			r.Add(report.Entry{
+				Message: errors.ErrXfsLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "swap":
+		// mkswap's man page does not state a limit on label size, but through
+		// experimentation it appears that mkswap will truncate long labels to
+		// 15 characters, so let's enforce that.
+		if len(*m.Label) > 15 {
+			r.Add(report.Entry{
+				Message: errors.ErrSwapLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "vfat":
+		if len(*m.Label) > 11 {
+			// source: man mkfs.fat
+			r.Add(report.Entry{
+				Message: errors.ErrVfatLabelTooLong.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/headers.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/headers.go
new file mode 100644
index 00000000..2b3e2373
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/headers.go
@@ -0,0 +1,47 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+
+	"fmt"
+)
+
+func (h HTTPHeaders) Validate() report.Report {
+	r := report.Report{}
+	found := make(map[string]struct{})
+	for _, header := range h {
+		// Header name can't be empty
+		if header.Name == "" {
+			r.Add(report.Entry{
+				Message: errors.ErrEmptyHTTPHeaderName.Error(),
+				Kind:    report.EntryError,
+			})
+			continue
+		}
+		// Header names must be unique
+		if _, ok := found[header.Name]; ok {
+			r.Add(report.Entry{
+				Message: fmt.Sprintf("Found duplicate HTTP header: %q", header.Name),
+				Kind:    report.EntryError,
+			})
+			continue
+		}
+		found[header.Name] = struct{}{}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/ignition.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/ignition.go
new file mode 100644
index 00000000..aafacdbe
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/ignition.go
@@ -0,0 +1,82 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (c ConfigReference) ValidateSource() report.Report {
+	r := report.Report{}
+	err := validateURL(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (c ConfigReference) ValidateHTTPHeaders() report.Report {
+	r := report.Report{}
+
+	if len(c.HTTPHeaders) < 1 {
+		return r
+	}
+
+	u, err := url.Parse(c.Source)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidUrl.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	switch u.Scheme {
+	case "http", "https":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnsupportedSchemeForHTTPHeaders.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (v Ignition) Semver() (*semver.Version, error) {
+	return semver.NewVersion(v.Version)
+}
+
+func (v Ignition) Validate() report.Report {
+	tv, err := v.Semver()
+	if err != nil {
+		return report.ReportFromError(errors.ErrInvalidVersion, report.EntryError)
+	}
+	if MaxVersion.Major > tv.Major {
+		return report.ReportFromError(errors.ErrOldVersion, report.EntryError)
+	}
+	if MaxVersion.LessThan(*tv) {
+		return report.ReportFromError(errors.ErrNewVersion, report.EntryError)
+	}
+	return report.Report{}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/mode.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/mode.go
new file mode 100644
index 00000000..b746217c
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/mode.go
@@ -0,0 +1,26 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateMode(m *int) error {
+	if m != nil && (*m < 0 || *m > 07777) {
+		return errors.ErrFileIllegalMode
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/node.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/node.go
new file mode 100644
index 00000000..dd0489c0
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/node.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path/filepath"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Node) ValidateFilesystem() report.Report {
+	r := report.Report{}
+	if n.Filesystem == "" {
+		r.Add(report.Entry{
+			Message: errors.ErrNoFilesystem.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) ValidatePath() report.Report {
+	r := report.Report{}
+	if err := validatePath(n.Path); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Node) Depth() int {
+	count := 0
+	for p := filepath.Clean(string(n.Path)); p != "/"; count++ {
+		p = filepath.Dir(p)
+	}
+	return count
+}
+
+func (nu NodeUser) Validate() report.Report {
+	r := report.Report{}
+	if nu.ID != nil && nu.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+func (ng NodeGroup) Validate() report.Report {
+	r := report.Report{}
+	if ng.ID != nil && ng.Name != "" {
+		r.Add(report.Entry{
+			Message: errors.ErrBothIDAndNameSet.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/partition.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/partition.go
new file mode 100644
index 00000000..99a993e9
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/partition.go
@@ -0,0 +1,112 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+const (
+	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
+)
+
+func (p Partition) Validate() report.Report {
+	r := report.Report{}
+	if (p.Start != nil || p.Size != nil) && (p.StartMiB != nil || p.SizeMiB != nil) {
+		r.Add(report.Entry{
+			Message: errors.ErrPartitionsUnitsMismatch.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	if p.ShouldExist != nil && !*p.ShouldExist &&
+		(p.Label != nil || p.TypeGUID != "" || p.GUID != "" || p.Start != nil || p.Size != nil) {
+		r.Add(report.Entry{
+			Message: errors.ErrShouldNotExistWithOthers.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateSize() report.Report {
+	if p.Size != nil {
+		return report.ReportFromError(errors.ErrSizeDeprecated, report.EntryDeprecated)
+	}
+	return report.Report{}
+}
+
+func (p Partition) ValidateStart() report.Report {
+	if p.Start != nil {
+		return report.ReportFromError(errors.ErrStartDeprecated, report.EntryDeprecated)
+	}
+	return report.Report{}
+}
+
+func (p Partition) ValidateLabel() report.Report {
+	r := report.Report{}
+	if p.Label == nil {
+		return r
+	}
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(*p.Label) > 36 {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelTooLong.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
+	if strings.Contains(*p.Label, ":") {
+		r.Add(report.Entry{
+			Message: errors.ErrLabelContainsColon.Error(),
+			Kind:    report.EntryWarning,
+		})
+	}
+	return r
+}
+
+func (p Partition) ValidateTypeGUID() report.Report {
+	return validateGUID(p.TypeGUID)
+}
+
+func (p Partition) ValidateGUID() report.Report {
+	return validateGUID(p.GUID)
+}
+
+func validateGUID(guid string) report.Report {
+	r := report.Report{}
+	ok, err := regexp.MatchString(guidRegexStr, guid)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: fmt.Sprintf("error matching guid regexp: %v", err),
+			Kind:    report.EntryError,
+		})
+	} else if !ok {
+		r.Add(report.Entry{
+			Message: errors.ErrDoesntMatchGUIDRegex.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/passwd.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/passwd.go
new file mode 100644
index 00000000..095ddc5e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/passwd.go
@@ -0,0 +1,67 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (p PasswdUser) Validate() report.Report {
+	r := report.Report{}
+	if p.Create != nil {
+		r.Add(report.Entry{
+			Message: errors.ErrPasswdCreateDeprecated.Error(),
+			Kind:    report.EntryWarning,
+		})
+		addErr := func(err error) {
+			r.Add(report.Entry{
+				Message: err.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+		if p.Gecos != "" {
+			addErr(errors.ErrPasswdCreateAndGecos)
+		}
+		if len(p.Groups) > 0 {
+			addErr(errors.ErrPasswdCreateAndGroups)
+		}
+		if p.HomeDir != "" {
+			addErr(errors.ErrPasswdCreateAndHomeDir)
+		}
+		if p.NoCreateHome {
+			addErr(errors.ErrPasswdCreateAndNoCreateHome)
+		}
+		if p.NoLogInit {
+			addErr(errors.ErrPasswdCreateAndNoLogInit)
+		}
+		if p.NoUserGroup {
+			addErr(errors.ErrPasswdCreateAndNoUserGroup)
+		}
+		if p.PrimaryGroup != "" {
+			addErr(errors.ErrPasswdCreateAndPrimaryGroup)
+		}
+		if p.Shell != "" {
+			addErr(errors.ErrPasswdCreateAndShell)
+		}
+		if p.System {
+			addErr(errors.ErrPasswdCreateAndSystem)
+		}
+		if p.UID != nil {
+			addErr(errors.ErrPasswdCreateAndUID)
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/path.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/path.go
new file mode 100644
index 00000000..f52ec956
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/path.go
@@ -0,0 +1,28 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validatePath(p string) error {
+	if !path.IsAbs(p) {
+		return errors.ErrPathRelative
+	}
+	return nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/raid.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/raid.go
new file mode 100644
index 00000000..87a10ee7
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/raid.go
@@ -0,0 +1,57 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (n Raid) ValidateLevel() report.Report {
+	r := report.Report{}
+	switch n.Level {
+	case "linear", "raid0", "0", "stripe":
+		if n.Spares != 0 {
+			r.Add(report.Entry{
+				Message: errors.ErrSparesUnsupportedForLevel.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrUnrecognizedRaidLevel.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (n Raid) ValidateDevices() report.Report {
+	r := report.Report{}
+	for _, d := range n.Devices {
+		if err := validatePath(string(d)); err != nil {
+			r.Add(report.Entry{
+				Message: errors.ErrPathRelative.Error(),
+				Kind:    report.EntryError,
+			})
+		}
+	}
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/schema.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/schema.go
new file mode 100644
index 00000000..4bf7ec84
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/schema.go
@@ -0,0 +1,269 @@
+package types
+
+// generated by "schematyper --package=types schema/ignition.json -o internal/config/types/schema.go --root-type=Config" -- DO NOT EDIT
+
+type CaReference struct {
+	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
+	Source       string       `json:"source"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Config struct {
+	Ignition Ignition `json:"ignition"`
+	Networkd Networkd `json:"networkd,omitempty"`
+	Passwd   Passwd   `json:"passwd,omitempty"`
+	Storage  Storage  `json:"storage,omitempty"`
+	Systemd  Systemd  `json:"systemd,omitempty"`
+}
+
+type ConfigReference struct {
+	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
+	Source       string       `json:"source"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type Create struct {
+	Force   bool           `json:"force,omitempty"`
+	Options []CreateOption `json:"options,omitempty"`
+}
+
+type CreateOption string
+
+type Device string
+
+type Directory struct {
+	Node
+	DirectoryEmbedded1
+}
+
+type DirectoryEmbedded1 struct {
+	Mode *int `json:"mode,omitempty"`
+}
+
+type Disk struct {
+	Device     string      `json:"device"`
+	Partitions []Partition `json:"partitions,omitempty"`
+	WipeTable  bool        `json:"wipeTable,omitempty"`
+}
+
+type File struct {
+	Node
+	FileEmbedded1
+}
+
+type FileContents struct {
+	Compression  string       `json:"compression,omitempty"`
+	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
+	Source       string       `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type FileEmbedded1 struct {
+	Append   bool         `json:"append,omitempty"`
+	Contents FileContents `json:"contents,omitempty"`
+	Mode     *int         `json:"mode,omitempty"`
+}
+
+type Filesystem struct {
+	Mount *Mount  `json:"mount,omitempty"`
+	Name  string  `json:"name,omitempty"`
+	Path  *string `json:"path,omitempty"`
+}
+
+type Group string
+
+type HTTPHeader struct {
+	Name  string `json:"name"`
+	Value string `json:"value"`
+}
+
+type HTTPHeaders []HTTPHeader
+
+type Ignition struct {
+	Config   IgnitionConfig `json:"config,omitempty"`
+	Proxy    Proxy          `json:"proxy,omitempty"`
+	Security Security       `json:"security,omitempty"`
+	Timeouts Timeouts       `json:"timeouts,omitempty"`
+	Version  string         `json:"version,omitempty"`
+}
+
+type IgnitionConfig struct {
+	Append  []ConfigReference `json:"append,omitempty"`
+	Replace *ConfigReference  `json:"replace,omitempty"`
+}
+
+type Link struct {
+	Node
+	LinkEmbedded1
+}
+
+type LinkEmbedded1 struct {
+	Hard   bool   `json:"hard,omitempty"`
+	Target string `json:"target"`
+}
+
+type Mount struct {
+	Create         *Create       `json:"create,omitempty"`
+	Device         string        `json:"device"`
+	Format         string        `json:"format"`
+	Label          *string       `json:"label,omitempty"`
+	Options        []MountOption `json:"options,omitempty"`
+	UUID           *string       `json:"uuid,omitempty"`
+	WipeFilesystem bool          `json:"wipeFilesystem,omitempty"`
+}
+
+type MountOption string
+
+type Networkd struct {
+	Units []Networkdunit `json:"units,omitempty"`
+}
+
+type NetworkdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name"`
+}
+
+type Networkdunit struct {
+	Contents string           `json:"contents,omitempty"`
+	Dropins  []NetworkdDropin `json:"dropins,omitempty"`
+	Name     string           `json:"name"`
+}
+
+type NoProxyItem string
+
+type Node struct {
+	Filesystem string     `json:"filesystem"`
+	Group      *NodeGroup `json:"group,omitempty"`
+	Overwrite  *bool      `json:"overwrite,omitempty"`
+	Path       string     `json:"path"`
+	User       *NodeUser  `json:"user,omitempty"`
+}
+
+type NodeGroup struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type NodeUser struct {
+	ID   *int   `json:"id,omitempty"`
+	Name string `json:"name,omitempty"`
+}
+
+type Partition struct {
+	GUID               string  `json:"guid,omitempty"`
+	Label              *string `json:"label,omitempty"`
+	Number             int     `json:"number,omitempty"`
+	ShouldExist        *bool   `json:"shouldExist,omitempty"`
+	Size               *int    `json:"size,omitempty"`
+	SizeMiB            *int    `json:"sizeMiB,omitempty"`
+	Start              *int    `json:"start,omitempty"`
+	StartMiB           *int    `json:"startMiB,omitempty"`
+	TypeGUID           string  `json:"typeGuid,omitempty"`
+	WipePartitionEntry bool    `json:"wipePartitionEntry,omitempty"`
+}
+
+type Passwd struct {
+	Groups []PasswdGroup `json:"groups,omitempty"`
+	Users  []PasswdUser  `json:"users,omitempty"`
+}
+
+type PasswdGroup struct {
+	Gid          *int   `json:"gid,omitempty"`
+	Name         string `json:"name"`
+	PasswordHash string `json:"passwordHash,omitempty"`
+	System       bool   `json:"system,omitempty"`
+}
+
+type PasswdUser struct {
+	Create            *Usercreate        `json:"create,omitempty"`
+	Gecos             string             `json:"gecos,omitempty"`
+	Groups            []Group            `json:"groups,omitempty"`
+	HomeDir           string             `json:"homeDir,omitempty"`
+	Name              string             `json:"name"`
+	NoCreateHome      bool               `json:"noCreateHome,omitempty"`
+	NoLogInit         bool               `json:"noLogInit,omitempty"`
+	NoUserGroup       bool               `json:"noUserGroup,omitempty"`
+	PasswordHash      *string            `json:"passwordHash,omitempty"`
+	PrimaryGroup      string             `json:"primaryGroup,omitempty"`
+	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
+	Shell             string             `json:"shell,omitempty"`
+	System            bool               `json:"system,omitempty"`
+	UID               *int               `json:"uid,omitempty"`
+}
+
+type Proxy struct {
+	HTTPProxy  string        `json:"httpProxy,omitempty"`
+	HTTPSProxy string        `json:"httpsProxy,omitempty"`
+	NoProxy    []NoProxyItem `json:"noProxy,omitempty"`
+}
+
+type Raid struct {
+	Devices []Device     `json:"devices"`
+	Level   string       `json:"level"`
+	Name    string       `json:"name"`
+	Options []RaidOption `json:"options,omitempty"`
+	Spares  int          `json:"spares,omitempty"`
+}
+
+type RaidOption string
+
+type SSHAuthorizedKey string
+
+type Security struct {
+	TLS TLS `json:"tls,omitempty"`
+}
+
+type Storage struct {
+	Directories []Directory  `json:"directories,omitempty"`
+	Disks       []Disk       `json:"disks,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Links       []Link       `json:"links,omitempty"`
+	Raid        []Raid       `json:"raid,omitempty"`
+}
+
+type Systemd struct {
+	Units []Unit `json:"units,omitempty"`
+}
+
+type SystemdDropin struct {
+	Contents string `json:"contents,omitempty"`
+	Name     string `json:"name"`
+}
+
+type TLS struct {
+	CertificateAuthorities []CaReference `json:"certificateAuthorities,omitempty"`
+}
+
+type Timeouts struct {
+	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
+	HTTPTotal           *int `json:"httpTotal,omitempty"`
+}
+
+type Unit struct {
+	Contents string          `json:"contents,omitempty"`
+	Dropins  []SystemdDropin `json:"dropins,omitempty"`
+	Enable   bool            `json:"enable,omitempty"`
+	Enabled  *bool           `json:"enabled,omitempty"`
+	Mask     bool            `json:"mask,omitempty"`
+	Name     string          `json:"name"`
+}
+
+type Usercreate struct {
+	Gecos        string            `json:"gecos,omitempty"`
+	Groups       []UsercreateGroup `json:"groups,omitempty"`
+	HomeDir      string            `json:"homeDir,omitempty"`
+	NoCreateHome bool              `json:"noCreateHome,omitempty"`
+	NoLogInit    bool              `json:"noLogInit,omitempty"`
+	NoUserGroup  bool              `json:"noUserGroup,omitempty"`
+	PrimaryGroup string            `json:"primaryGroup,omitempty"`
+	Shell        string            `json:"shell,omitempty"`
+	System       bool              `json:"system,omitempty"`
+	UID          *int              `json:"uid,omitempty"`
+}
+
+type UsercreateGroup string
+
+type Verification struct {
+	Hash *string `json:"hash,omitempty"`
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/unit.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/unit.go
new file mode 100644
index 00000000..3d57428e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/unit.go
@@ -0,0 +1,131 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"path"
+	"strings"
+
+	"github.com/coreos/go-systemd/unit"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/shared/validations"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+func (u Unit) ValidateContents() report.Report {
+	r := report.Report{}
+	opts, err := validateUnitContent(u.Contents)
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	isEnabled := u.Enable || (u.Enabled != nil && *u.Enabled)
+	r.Merge(validations.ValidateInstallSection(u.Name, isEnabled, u.Contents == "", opts))
+
+	return r
+}
+
+func (u Unit) ValidateName() report.Report {
+	r := report.Report{}
+	switch path.Ext(u.Name) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+	return r
+}
+
+func (d SystemdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidSystemdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (u Networkdunit) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(u.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(u.Name) {
+	case ".link", ".netdev", ".network":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func (d NetworkdDropin) Validate() report.Report {
+	r := report.Report{}
+
+	if _, err := validateUnitContent(d.Contents); err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrInvalidNetworkdDropinExt.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
+
+func validateUnitContent(content string) ([]*unit.UnitOption, error) {
+	c := strings.NewReader(content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/url.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/url.go
new file mode 100644
index 00000000..aedd9a56
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/url.go
@@ -0,0 +1,53 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/vincent-petithory/dataurl"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+)
+
+func validateURL(s string) error {
+	// Empty url is valid, indicates an empty file
+	if s == "" {
+		return nil
+	}
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https", "oem", "tftp":
+		return nil
+	case "s3":
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "data":
+		if _, err := dataurl.DecodeString(s); err != nil {
+			return err
+		}
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
diff --git a/vendor/github.com/flatcar/ignition/config/v2_4/types/verification.go b/vendor/github.com/flatcar/ignition/config/v2_4/types/verification.go
new file mode 100644
index 00000000..cb06d76e
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/v2_4/types/verification.go
@@ -0,0 +1,77 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"strings"
+
+	"github.com/flatcar/ignition/config/shared/errors"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+// HashParts will return the sum and function (in that order) of the hash stored
+// in this Verification, or an error if there is an issue during parsing.
+func (v Verification) HashParts() (string, string, error) {
+	if v.Hash == nil {
+		// The hash can be nil
+		return "", "", nil
+	}
+	parts := strings.SplitN(*v.Hash, "-", 2)
+	if len(parts) != 2 {
+		return "", "", errors.ErrHashMalformed
+	}
+
+	return parts[0], parts[1], nil
+}
+
+func (v Verification) Validate() report.Report {
+	r := report.Report{}
+
+	if v.Hash == nil {
+		// The hash can be nil
+		return r
+	}
+
+	function, sum, err := v.HashParts()
+	if err != nil {
+		r.Add(report.Entry{
+			Message: err.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+	var hash crypto.Hash
+	switch function {
+	case "sha512":
+		hash = crypto.SHA512
+	default:
+		r.Add(report.Entry{
+			Message: errors.ErrHashUnrecognized.Error(),
+			Kind:    report.EntryError,
+		})
+		return r
+	}
+
+	if len(sum) != hex.EncodedLen(hash.Size()) {
+		r.Add(report.Entry{
+			Message: errors.ErrHashWrongSize.Error(),
+			Kind:    report.EntryError,
+		})
+	}
+
+	return r
+}
diff --git a/vendor/github.com/flatcar/ignition/config/validate/astjson/node.go b/vendor/github.com/flatcar/ignition/config/validate/astjson/node.go
new file mode 100644
index 00000000..9875cfde
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/validate/astjson/node.go
@@ -0,0 +1,73 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package astjson
+
+import (
+	"io"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/flatcar/ignition/config/validate/astnode"
+	"go4.org/errorutil"
+)
+
+type JsonNode json.Node
+
+func FromJsonRoot(n json.Node) JsonNode {
+	return JsonNode(n)
+}
+
+func (n JsonNode) ValueLineCol(source io.ReadSeeker) (int, int, string) {
+	return posFromOffset(n.End, source)
+}
+
+func (n JsonNode) KeyLineCol(source io.ReadSeeker) (int, int, string) {
+	return posFromOffset(n.KeyEnd, source)
+}
+
+func (n JsonNode) LiteralValue() interface{} {
+	return n.Value
+}
+
+func (n JsonNode) SliceChild(index int) (astnode.AstNode, bool) {
+	if slice, ok := n.Value.([]json.Node); ok {
+		return JsonNode(slice[index]), true
+	}
+	return JsonNode{}, false
+}
+
+func (n JsonNode) KeyValueMap() (map[string]astnode.AstNode, bool) {
+	if kvmap, ok := n.Value.(map[string]json.Node); ok {
+		newKvmap := map[string]astnode.AstNode{}
+		for k, v := range kvmap {
+			newKvmap[k] = JsonNode(v)
+		}
+		return newKvmap, true
+	}
+	return nil, false
+}
+
+func (n JsonNode) Tag() string {
+	return "json"
+}
+
+// wrapper for errorutil that handles missing sources sanely and resets the reader afterwards
+func posFromOffset(offset int, source io.ReadSeeker) (int, int, string) {
+	if source == nil {
+		return 0, 0, ""
+	}
+	line, col, highlight := errorutil.HighlightBytePosition(source, int64(offset))
+	source.Seek(0, 0) // Reset the reader to the start so the next call isn't relative to this position
+	return line, col, highlight
+}
diff --git a/vendor/github.com/flatcar/ignition/config/validate/astnode/astnode.go b/vendor/github.com/flatcar/ignition/config/validate/astnode/astnode.go
new file mode 100644
index 00000000..d1c1d9c2
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/validate/astnode/astnode.go
@@ -0,0 +1,45 @@
+// Copyright 2017 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package astnode
+
+import (
+	"io"
+)
+
+// AstNode abstracts the differences between yaml and json nodes, providing a
+// common interface
+type AstNode interface {
+	// ValueLineCol returns the line, column, and highlight string of the value of
+	// this node in the source.
+	ValueLineCol(source io.ReadSeeker) (int, int, string)
+
+	// KeyLineCol returns the line, column, and highlight string of the key for the
+	// value of this node in the source.
+	KeyLineCol(source io.ReadSeeker) (int, int, string)
+
+	// LiteralValue returns the value of this node.
+	LiteralValue() interface{}
+
+	// SliceChild returns the child node at the index specified. If this node is not
+	// a slice node, an empty AstNode and false is returned.
+	SliceChild(index int) (AstNode, bool)
+
+	// KeyValueMap returns a map of keys and values. If this node is not a mapping
+	// node, nil and false are returned.
+	KeyValueMap() (map[string]AstNode, bool)
+
+	// Tag returns the struct tag used in the config structure used to unmarshal.
+	Tag() string
+}
diff --git a/vendor/github.com/flatcar/ignition/config/validate/report/report.go b/vendor/github.com/flatcar/ignition/config/validate/report/report.go
new file mode 100644
index 00000000..e0d4fed8
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/validate/report/report.go
@@ -0,0 +1,158 @@
+// Copyright 2016 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package report
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"sort"
+)
+
+type Report struct {
+	Entries []Entry
+}
+
+func (into *Report) Merge(from Report) {
+	into.Entries = append(into.Entries, from.Entries...)
+}
+
+func ReportFromError(err error, severity entryKind) Report {
+	if err == nil {
+		return Report{}
+	}
+	return Report{
+		Entries: []Entry{
+			{
+				Kind:    severity,
+				Message: err.Error(),
+			},
+		},
+	}
+}
+
+// Sort sorts the entries by line number, then column number
+func (r *Report) Sort() {
+	sort.Sort(entries(r.Entries))
+}
+
+type entries []Entry
+
+func (e entries) Len() int {
+	return len(e)
+}
+
+func (e entries) Swap(i, j int) {
+	e[i], e[j] = e[j], e[i]
+}
+
+func (e entries) Less(i, j int) bool {
+	if e[i].Line != e[j].Line {
+		return e[i].Line < e[j].Line
+	}
+	return e[i].Column < e[j].Column
+}
+
+const (
+	EntryError entryKind = iota
+	EntryWarning
+	EntryInfo
+	EntryDeprecated
+)
+
+// AddPosition updates all the entries with Line equal to 0 and sets the Line/Column fields to line/column. This is useful for
+// when a type has a custom unmarshaller and thus can't determine an exact offset of the error with the type. In this case
+// the offset for the entire chunk of json that got unmarshalled to the type can be used instead, which is still pretty good.
+func (r *Report) AddPosition(line, col int, highlight string) {
+	for i, e := range r.Entries {
+		if e.Line == 0 {
+			r.Entries[i].Line = line
+			r.Entries[i].Column = col
+			r.Entries[i].Highlight = highlight
+		}
+	}
+}
+
+func (r *Report) Add(e Entry) {
+	r.Entries = append(r.Entries, e)
+}
+
+func (r Report) String() string {
+	var errs bytes.Buffer
+	for i, entry := range r.Entries {
+		if i != 0 {
+			// Only add line breaks on multiline reports
+			errs.WriteString("\n")
+		}
+		errs.WriteString(entry.String())
+	}
+	return errs.String()
+}
+
+// IsFatal returns if there were any errors that make the config invalid
+func (r Report) IsFatal() bool {
+	for _, entry := range r.Entries {
+		if entry.Kind == EntryError {
+			return true
+		}
+	}
+	return false
+}
+
+// IsDeprecated returns if the report has deprecations
+func (r Report) IsDeprecated() bool {
+	for _, entry := range r.Entries {
+		if entry.Kind == EntryDeprecated {
+			return true
+		}
+	}
+	return false
+}
+
+type Entry struct {
+	Kind      entryKind `json:"kind"`
+	Message   string    `json:"message"`
+	Line      int       `json:"line,omitempty"`
+	Column    int       `json:"column,omitempty"`
+	Highlight string    `json:"-"`
+}
+
+func (e Entry) String() string {
+	if e.Line != 0 {
+		return fmt.Sprintf("%s at line %d, column %d\n%s%v", e.Kind.String(), e.Line, e.Column, e.Highlight, e.Message)
+	}
+	return fmt.Sprintf("%s: %v", e.Kind.String(), e.Message)
+}
+
+type entryKind int
+
+func (e entryKind) String() string {
+	switch e {
+	case EntryError:
+		return "error"
+	case EntryWarning:
+		return "warning"
+	case EntryInfo:
+		return "info"
+	case EntryDeprecated:
+		return "deprecated"
+	default:
+		return "unknown error"
+	}
+}
+
+func (e entryKind) MarshalJSON() ([]byte, error) {
+	return json.Marshal(e.String())
+}
diff --git a/vendor/github.com/flatcar/ignition/config/validate/validate.go b/vendor/github.com/flatcar/ignition/config/validate/validate.go
new file mode 100644
index 00000000..3363f8db
--- /dev/null
+++ b/vendor/github.com/flatcar/ignition/config/validate/validate.go
@@ -0,0 +1,242 @@
+// Copyright 2015 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package validate
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"reflect"
+	"strings"
+
+	json "github.com/ajeddeloh/go-json"
+	"github.com/flatcar/ignition/config/validate/astjson"
+	"github.com/flatcar/ignition/config/validate/astnode"
+	"github.com/flatcar/ignition/config/validate/report"
+)
+
+type validator interface {
+	Validate() report.Report
+}
+
+// ValidateConfig validates a raw config object into a given config version
+func ValidateConfig(rawConfig []byte, config interface{}) report.Report {
+	// Unmarshal again to a json.Node to get offset information for building a report
+	var ast json.Node
+	var r report.Report
+	configValue := reflect.ValueOf(config)
+	if err := json.Unmarshal(rawConfig, &ast); err != nil {
+		r.Add(report.Entry{
+			Kind:    report.EntryWarning,
+			Message: "Ignition could not unmarshal your config for reporting line numbers. This should never happen. Please file a bug.",
+		})
+		r.Merge(ValidateWithoutSource(configValue))
+	} else {
+		r.Merge(Validate(configValue, astjson.FromJsonRoot(ast), bytes.NewReader(rawConfig), true))
+	}
+	return r
+}
+
+// Validate walks down a struct tree calling Validate on every node that implements it, building
+// A report of all the errors, warnings, info, and deprecations it encounters. If checkUnusedKeys
+// is true, Validate will generate warnings for unused keys in the ast, otherwise it will not.
+func Validate(vObj reflect.Value, ast astnode.AstNode, source io.ReadSeeker, checkUnusedKeys bool) (r report.Report) {
+	if !vObj.IsValid() {
+		return
+	}
+
+	line, col, highlight := 0, 0, ""
+	if ast != nil {
+		line, col, highlight = ast.ValueLineCol(source)
+	}
+
+	// See if we A) can call Validate on vObj, and B) should call Validate. Validate should NOT be called
+	// when vObj is nil, as it will panic or when vObj is a pointer to a value with Validate implemented with a
+	// value receiver. This is to prevent Validate being called twice, as otherwise it would be called on the
+	// pointer version (due to go's automatic deferencing) and once when the pointer is deferenced below. The only
+	// time Validate should be called on a pointer is when the function is implemented with a pointer reciever.
+	if obj, ok := vObj.Interface().(validator); ok &&
+		((vObj.Kind() != reflect.Ptr) ||
+			(!vObj.IsNil() && !vObj.Elem().Type().Implements(reflect.TypeOf((*validator)(nil)).Elem()))) {
+		sub_r := obj.Validate()
+		sub_r.AddPosition(line, col, highlight)
+		r.Merge(sub_r)
+
+		// Dont recurse on invalid inner nodes, it mostly leads to bogus messages
+		if sub_r.IsFatal() {
+			return
+		}
+	}
+
+	switch vObj.Kind() {
+	case reflect.Ptr:
+		sub_report := Validate(vObj.Elem(), ast, source, checkUnusedKeys)
+		sub_report.AddPosition(line, col, "")
+		r.Merge(sub_report)
+	case reflect.Struct:
+		sub_report := validateStruct(vObj, ast, source, checkUnusedKeys)
+		sub_report.AddPosition(line, col, "")
+		r.Merge(sub_report)
+	case reflect.Slice:
+		for i := 0; i < vObj.Len(); i++ {
+			sub_node := ast
+			if ast != nil {
+				if n, ok := ast.SliceChild(i); ok {
+					sub_node = n
+				}
+			}
+			sub_report := Validate(vObj.Index(i), sub_node, source, checkUnusedKeys)
+			sub_report.AddPosition(line, col, "")
+			r.Merge(sub_report)
+		}
+	}
+	return
+}
+
+func ValidateWithoutSource(cfg reflect.Value) (report report.Report) {
+	return Validate(cfg, nil, nil, false)
+}
+
+type field struct {
+	Type  reflect.StructField
+	Value reflect.Value
+}
+
+// getFields returns a field of all the fields in the struct, including the fields of
+// embedded structs and structs inside interface{}'s
+func getFields(vObj reflect.Value) []field {
+	if vObj.Kind() != reflect.Struct {
+		return nil
+	}
+	ret := []field{}
+	for i := 0; i < vObj.Type().NumField(); i++ {
+		if vObj.Type().Field(i).Anonymous {
+			// in the case of an embedded type that is an alias to interface, extract the
+			// real type contained by the interface
+			realObj := reflect.ValueOf(vObj.Field(i).Interface())
+			ret = append(ret, getFields(realObj)...)
+		} else {
+			ret = append(ret, field{Type: vObj.Type().Field(i), Value: vObj.Field(i)})
+		}
+	}
+	return ret
+}
+
+func validateStruct(vObj reflect.Value, ast astnode.AstNode, source io.ReadSeeker, checkUnusedKeys bool) report.Report {
+	r := report.Report{}
+
+	// isFromObject will be true if this struct was unmarshalled from a JSON object.
+	keys, isFromObject := map[string]astnode.AstNode{}, false
+	if ast != nil {
+		keys, isFromObject = ast.KeyValueMap()
+	}
+
+	// Maintain a set of key's that have been used.
+	usedKeys := map[string]struct{}{}
+
+	// Maintain a list of all the tags in the struct for fuzzy matching later.
+	tags := []string{}
+
+	for _, f := range getFields(vObj) {
+		// Default to nil astnode.AstNode if the field's corrosponding node cannot be found.
+		var sub_node astnode.AstNode
+		// Default to passing a nil source if the field's corrosponding node cannot be found.
+		// This ensures the line numbers reported from all sub-structs are 0 and will be changed by AddPosition
+		var src io.ReadSeeker
+
+		// Try to determine the json.Node that corrosponds with the struct field
+		if isFromObject {
+			tag := strings.SplitN(f.Type.Tag.Get(ast.Tag()), ",", 2)[0]
+			// Save the tag so we have a list of all the tags in the struct
+			tags = append(tags, tag)
+			// mark that this key was used
+			usedKeys[tag] = struct{}{}
+
+			if sub, ok := keys[tag]; ok {
+				// Found it
+				sub_node = sub
+				src = source
+			}
+		}
+
+		// Default to deepest node if the node's type isn't an object,
+		// such as when a json string actually unmarshal to structs (like with version)
+		line, col := 0, 0
+		highlight := ""
+		if ast != nil {
+			line, col, highlight = ast.ValueLineCol(src)
+		}
+
+		// If there's a Validate<Name> func for the given field, call it
+		funct := vObj.MethodByName("Validate" + f.Type.Name)
+		if funct.IsValid() {
+			if sub_node != nil {
+				// if sub_node is non-nil, we can get better line/col info
+				line, col, highlight = sub_node.ValueLineCol(src)
+			}
+			res := funct.Call(nil)
+			sub_report := res[0].Interface().(report.Report)
+			sub_report.AddPosition(line, col, highlight)
+			r.Merge(sub_report)
+		}
+
+		sub_report := Validate(f.Value, sub_node, src, checkUnusedKeys)
+		sub_report.AddPosition(line, col, highlight)
+		r.Merge(sub_report)
+	}
+	if !isFromObject || !checkUnusedKeys {
+		// If this struct was not unmarshalled from a JSON object, there cannot be unused keys.
+		return r
+	}
+
+	for k, v := range keys {
+		if _, hasKey := usedKeys[k]; hasKey {
+			continue
+		}
+		line, col, highlight := v.KeyLineCol(source)
+		typo := similar(k, tags)
+
+		r.Add(report.Entry{
+			Kind:      report.EntryWarning,
+			Message:   fmt.Sprintf("Config has unrecognized key: %s", k),
+			Line:      line,
+			Column:    col,
+			Highlight: highlight,
+		})
+
+		if typo != "" {
+			r.Add(report.Entry{
+				Kind:      report.EntryInfo,
+				Message:   fmt.Sprintf("Did you mean %s instead of %s", typo, k),
+				Line:      line,
+				Column:    col,
+				Highlight: highlight,
+			})
+		}
+	}
+
+	return r
+}
+
+// similar returns a string in candidates that is similar to str. Currently it just does case
+// insensitive comparison, but it should be updated to use levenstein distances to catch typos
+func similar(str string, candidates []string) string {
+	for _, candidate := range candidates {
+		if strings.EqualFold(str, candidate) {
+			return candidate
+		}
+	}
+	return ""
+}
diff --git a/vendor/go4.org/AUTHORS b/vendor/go4.org/AUTHORS
new file mode 100644
index 00000000..d1ad485f
--- /dev/null
+++ b/vendor/go4.org/AUTHORS
@@ -0,0 +1,8 @@
+# This is the official list of go4 authors for copyright purposes.
+# This is distinct from the CONTRIBUTORS file, which is the list of
+# people who have contributed, even if they don't own the copyright on
+# their work.
+
+Mathieu Lonjaret <mathieu.lonjaret@gmail.com>
+Daniel Theophanes <kardianos@gmail.com>
+Google
diff --git a/vendor/go4.org/LICENSE b/vendor/go4.org/LICENSE
new file mode 100644
index 00000000..8f71f43f
--- /dev/null
+++ b/vendor/go4.org/LICENSE
@@ -0,0 +1,202 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
diff --git a/vendor/go4.org/errorutil/highlight.go b/vendor/go4.org/errorutil/highlight.go
new file mode 100644
index 00000000..1b1efb0f
--- /dev/null
+++ b/vendor/go4.org/errorutil/highlight.go
@@ -0,0 +1,58 @@
+/*
+Copyright 2011 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package errorutil helps make better error messages.
+package errorutil // import "go4.org/errorutil"
+
+import (
+	"bufio"
+	"bytes"
+	"fmt"
+	"io"
+	"strings"
+)
+
+// HighlightBytePosition takes a reader and the location in bytes of a parse
+// error (for instance, from json.SyntaxError.Offset) and returns the line, column,
+// and pretty-printed context around the error with an arrow indicating the exact
+// position of the syntax error.
+func HighlightBytePosition(f io.Reader, pos int64) (line, col int, highlight string) {
+	line = 1
+	br := bufio.NewReader(f)
+	lastLine := ""
+	thisLine := new(bytes.Buffer)
+	for n := int64(0); n < pos; n++ {
+		b, err := br.ReadByte()
+		if err != nil {
+			break
+		}
+		if b == '\n' {
+			lastLine = thisLine.String()
+			thisLine.Reset()
+			line++
+			col = 1
+		} else {
+			col++
+			thisLine.WriteByte(b)
+		}
+	}
+	if line > 1 {
+		highlight += fmt.Sprintf("%5d: %s\n", line-1, lastLine)
+	}
+	highlight += fmt.Sprintf("%5d: %s\n", line, thisLine.String())
+	highlight += fmt.Sprintf("%s^\n", strings.Repeat(" ", col+5))
+	return
+}
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 765c8cb6..d1184cea 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -36,6 +36,9 @@ cloud.google.com/go/storage
 cloud.google.com/go/storage/internal
 cloud.google.com/go/storage/internal/apiv2
 cloud.google.com/go/storage/internal/apiv2/storagepb
+# github.com/ajeddeloh/go-json v0.0.0-20160803184958-73d058cf8437
+## explicit
+github.com/ajeddeloh/go-json
 # github.com/aws/aws-sdk-go v1.53.5
 ## explicit; go 1.19
 github.com/aws/aws-sdk-go/aws
@@ -103,6 +106,9 @@ github.com/coreos/go-json
 # github.com/coreos/go-semver v0.3.1
 ## explicit; go 1.8
 github.com/coreos/go-semver/semver
+# github.com/coreos/go-systemd v0.0.0-20181031085051-9002847aa142
+## explicit
+github.com/coreos/go-systemd/unit
 # github.com/coreos/go-systemd/v22 v22.5.0
 ## explicit; go 1.12
 github.com/coreos/go-systemd/v22/dbus
@@ -121,6 +127,27 @@ github.com/davecgh/go-spew/spew
 # github.com/felixge/httpsnoop v1.0.4
 ## explicit; go 1.13
 github.com/felixge/httpsnoop
+# github.com/flatcar/ignition v0.36.2
+## explicit; go 1.16
+github.com/flatcar/ignition/config/shared/errors
+github.com/flatcar/ignition/config/shared/validations
+github.com/flatcar/ignition/config/util
+github.com/flatcar/ignition/config/v1
+github.com/flatcar/ignition/config/v1/types
+github.com/flatcar/ignition/config/v2_0
+github.com/flatcar/ignition/config/v2_0/types
+github.com/flatcar/ignition/config/v2_1
+github.com/flatcar/ignition/config/v2_1/types
+github.com/flatcar/ignition/config/v2_2
+github.com/flatcar/ignition/config/v2_2/types
+github.com/flatcar/ignition/config/v2_3
+github.com/flatcar/ignition/config/v2_3/types
+github.com/flatcar/ignition/config/v2_4
+github.com/flatcar/ignition/config/v2_4/types
+github.com/flatcar/ignition/config/validate
+github.com/flatcar/ignition/config/validate/astjson
+github.com/flatcar/ignition/config/validate/astnode
+github.com/flatcar/ignition/config/validate/report
 # github.com/go-logr/logr v1.4.1
 ## explicit; go 1.18
 github.com/go-logr/logr
@@ -264,6 +291,9 @@ go.opentelemetry.io/otel/metric/noop
 ## explicit; go 1.20
 go.opentelemetry.io/otel/trace
 go.opentelemetry.io/otel/trace/embedded
+# go4.org v0.0.0-20160314031811-03efcb870d84
+## explicit
+go4.org/errorutil
 # golang.org/x/crypto v0.23.0
 ## explicit; go 1.18
 golang.org/x/crypto/chacha20
-- 
2.43.2

