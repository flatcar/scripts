From 026cab86883e256607f6df30375bfda4468ae71e Mon Sep 17 00:00:00 2001
From: Sayan Chowdhury <schowdhury@microsoft.com>
Date: Thu, 24 Aug 2023 00:00:00 +0530
Subject: [PATCH] gpt: Add patch to implement the custom GPT module

This module is a new implementation for reading GUID Partition Tables
which is much stricter than the existing part_gpt module and exports GPT
data directly instead of the generic grub_partition structure. It will
be the basis for modules that need to read/write/update GPT data.

This patch also includes the supporting functions like gptprio,
gptrepair, search commands.

The patch is prepared using the coreos/grub PRs, picking the only
required ones, and dropping the others. The README.md file in this
directory contains more contexual information along with the commits
used to create the patch.

Authored-by: Michael Marineau <michael.marineau@coreos.com>
Signed-off-by: Sayan Chowdhury <schowdhury@microsoft.com>
---

diff -Naur a/Makefile.util.def b/Makefile.util.def
--- a/Makefile.util.def	2024-09-05 16:04:35.405205341 -0000
+++ b/Makefile.util.def	2024-09-05 16:05:42.308358821 -0000
@@ -1334,6 +1334,18 @@
   common = tests/test_asn1.in;
 };
 
+script = {
+  testcase = native;
+  name = gptrepair_test;
+  common = tests/gptrepair_test.in;
+};
+
+script = {
+  testcase = native;
+  name = gptprio_test;
+  common = tests/gptprio_test.in;
+};
+
 program = {
   testcase = native;
   name = example_unit_test;
@@ -1411,6 +1423,24 @@
   ldadd = '$(LIBDEVMAPPER) $(LIBZFS) $(LIBNVPAIR) $(LIBGEOM)';
 };
 
+program = {
+  testcase = native;
+  name = gpt_unit_test;
+  common = tests/gpt_unit_test.c;
+  common = tests/lib/unit_test.c;
+  common = grub-core/commands/search_part_label.c;
+  common = grub-core/commands/search_part_uuid.c;
+  common = grub-core/disk/host.c;
+  common = grub-core/kern/emu/hostfs.c;
+  common = grub-core/lib/gpt.c;
+  common = grub-core/tests/lib/test.c;
+  ldadd = libgrubmods.a;
+  ldadd = libgrubgcry.a;
+  ldadd = libgrubkern.a;
+  ldadd = grub-core/gnulib/libgnu.a;
+  ldadd = '$(LIBDEVMAPPER) $(LIBZFS) $(LIBNVPAIR) $(LIBGEOM)';
+};
+
 program = {
   name = grub-menulst2cfg;
   mansection = 1;
diff -Naur a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
--- a/grub-core/Makefile.core.def	2024-09-05 16:04:35.460205469 -0000
+++ b/grub-core/Makefile.core.def	2024-09-05 16:05:42.309358823 -0000
@@ -968,6 +968,21 @@
 };
 
 module = {
+  name = gptrepair;
+  common = commands/gptrepair.c;
+};
+
+module = {
+  name = gptprio;
+  common = commands/gptprio.c;
+};
+
+module = {
+  name = gpt;
+  common = lib/gpt.c;
+};
+
+module = {
   name = halt;
   nopc = commands/halt.c;
   i386_pc = commands/i386/pc/halt.c;
@@ -1157,6 +1172,16 @@
 };
 
 module = {
+  name = search_part_uuid;
+  common = commands/search_part_uuid.c;
+};
+
+module = {
+  name = search_part_label;
+  common = commands/search_part_label.c;
+};
+
+module = {
   name = setpci;
   common = commands/setpci.c;
   enable = pci;
diff -Naur a/grub-core/commands/gptprio.c b/grub-core/commands/gptprio.c
--- a/grub-core/commands/gptprio.c	1970-01-01 00:00:00.000000000 -0000
+++ b/grub-core/commands/gptprio.c	2024-09-05 16:37:53.072065206 -0000
@@ -0,0 +1,223 @@
+/* gptprio.c - manage priority based partition selection.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2014  CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/device.h>
+#include <grub/env.h>
+#include <grub/err.h>
+#include <grub/extcmd.h>
+#include <grub/gpt_partition.h>
+#include <grub/i18n.h>
+#include <grub/misc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static const struct grub_arg_option options_next[] = {
+  {"set-device", 'd', 0,
+   N_("Set a variable to the name of selected partition."),
+   N_("VARNAME"), ARG_TYPE_STRING},
+  {"set-uuid", 'u', 0,
+   N_("Set a variable to the GPT UUID of selected partition."),
+   N_("VARNAME"), ARG_TYPE_STRING},
+  {0, 0, 0, 0, 0, 0}
+};
+
+enum options_next
+{
+  NEXT_SET_DEVICE,
+  NEXT_SET_UUID,
+};
+
+static unsigned int
+grub_gptprio_priority (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_PRIORITY, 4);
+}
+
+static unsigned int
+grub_gptprio_tries_left (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT, 4);
+}
+
+static void
+grub_gptprio_set_tries_left (struct grub_gpt_partentry *entry,
+			     unsigned int tries_left)
+{
+  grub_gpt_entry_set_attribute
+    (entry, tries_left, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT, 4);
+}
+
+static unsigned int
+grub_gptprio_successful (struct grub_gpt_partentry *entry)
+{
+  return (unsigned int) grub_gpt_entry_attribute
+    (entry, GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_SUCCESSFUL, 1);
+}
+
+static grub_err_t
+grub_find_next (const char *disk_name,
+		const grub_packed_guid_t *part_type,
+		char **part_name, char **part_guid)
+{
+  struct grub_gpt_partentry *part, *part_found = NULL;
+  grub_device_t dev = NULL;
+  grub_gpt_t gpt = NULL;
+  grub_uint32_t i, part_index;
+
+  dev = grub_device_open (disk_name);
+  if (!dev)
+    goto done;
+
+  gpt = grub_gpt_read (dev->disk);
+  if (!gpt)
+    goto done;
+
+  if (grub_gpt_repair (dev->disk, gpt))
+    goto done;
+
+  for (i = 0; (part = grub_gpt_get_partentry (gpt, i)) != NULL; i++)
+    {
+      if (grub_memcmp (part_type, &part->type, sizeof (*part_type)) == 0)
+	{
+	  unsigned int priority, tries_left, successful, old_priority = 0;
+
+	  priority = grub_gptprio_priority (part);
+	  tries_left = grub_gptprio_tries_left (part);
+	  successful = grub_gptprio_successful (part);
+
+	  if (part_found)
+	    old_priority = grub_gptprio_priority (part_found);
+
+	  if ((tries_left || successful) && priority > old_priority)
+	    {
+	      part_index = i;
+	      part_found = part;
+	    }
+	}
+    }
+
+  if (!part_found)
+    {
+      grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("no such partition"));
+      goto done;
+    }
+
+  if (grub_gptprio_tries_left (part_found))
+    {
+      unsigned int tries_left = grub_gptprio_tries_left (part_found);
+
+      grub_gptprio_set_tries_left (part_found, tries_left - 1);
+
+      if (grub_gpt_update (gpt))
+	goto done;
+
+      if (grub_gpt_write (dev->disk, gpt))
+	goto done;
+    }
+
+  *part_name = grub_xasprintf ("%s,gpt%u", disk_name, part_index + 1);
+  if (!*part_name)
+    goto done;
+
+  *part_guid = grub_gpt_guid_to_str (&part_found->guid);
+  if (!*part_guid)
+    goto done;
+
+  grub_errno = GRUB_ERR_NONE;
+
+done:
+  grub_gpt_free (gpt);
+
+  if (dev)
+    grub_device_close (dev);
+
+  return grub_errno;
+}
+
+
+
+static grub_err_t
+grub_cmd_next (grub_extcmd_context_t ctxt, int argc, char **args)
+{
+  struct grub_arg_list *state = ctxt->state;
+  char *p, *root = NULL, *part_name = NULL, *part_guid = NULL;
+
+  /* TODO: Add a uuid parser and a command line flag for providing type.  */
+  grub_packed_guid_t part_type = GRUB_GPT_PARTITION_TYPE_USR_X86_64;
+
+  if (!state[NEXT_SET_DEVICE].set || !state[NEXT_SET_UUID].set)
+    {
+      grub_error (GRUB_ERR_INVALID_COMMAND, N_("-d and -u are required"));
+      goto done;
+    }
+
+  if (argc == 0)
+    root = grub_strdup (grub_env_get ("root"));
+  else if (argc == 1)
+    root = grub_strdup (args[0]);
+  else
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("unexpected arguments"));
+      goto done;
+    }
+
+  if (!root)
+    goto done;
+
+  /* To make using $root practical strip off the partition name.  */
+  p = grub_strchr (root, ',');
+  if (p)
+    *p = '\0';
+
+  if (grub_find_next (root, &part_type, &part_name, &part_guid))
+    goto done;
+
+  if (grub_env_set (state[NEXT_SET_DEVICE].arg, part_name))
+    goto done;
+
+  if (grub_env_set (state[NEXT_SET_UUID].arg, part_guid))
+    goto done;
+
+  grub_errno = GRUB_ERR_NONE;
+
+done:
+  grub_free (root);
+  grub_free (part_name);
+  grub_free (part_guid);
+
+  return grub_errno;
+}
+
+static grub_extcmd_t cmd_next;
+
+GRUB_MOD_INIT(gptprio)
+{
+  cmd_next = grub_register_extcmd ("gptprio.next", grub_cmd_next, 0,
+				   N_("-d VARNAME -u VARNAME [DEVICE]"),
+				   N_("Select next partition to boot."),
+				   options_next);
+}
+
+GRUB_MOD_FINI(gptprio)
+{
+  grub_unregister_extcmd (cmd_next);
+}
diff -Naur a/grub-core/commands/gptrepair.c b/grub-core/commands/gptrepair.c
--- a/grub-core/commands/gptrepair.c	1970-01-01 00:00:00.000000000 -0000
+++ b/grub-core/commands/gptrepair.c	2024-09-05 16:05:42.309358823 -0000
@@ -0,0 +1,110 @@
+/* gptrepair.c - verify and restore GPT info from alternate location.  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2014  CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/device.h>
+#include <grub/err.h>
+#include <grub/gpt_partition.h>
+#include <grub/i18n.h>
+#include <grub/misc.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static char *
+trim_dev_name (char *name)
+{
+  grub_size_t len = grub_strlen (name);
+  if (len && name[0] == '(' && name[len - 1] == ')')
+    {
+      name[len - 1] = '\0';
+      name = name + 1;
+    }
+  return name;
+}
+
+static grub_err_t
+grub_cmd_gptrepair (grub_command_t cmd __attribute__ ((unused)),
+		    int argc, char **args)
+{
+  grub_device_t dev = NULL;
+  grub_gpt_t gpt = NULL;
+  char *dev_name;
+
+  if (argc != 1 || !grub_strlen(args[0]))
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "device name required");
+
+  dev_name = trim_dev_name (args[0]);
+  dev = grub_device_open (dev_name);
+  if (!dev)
+    goto done;
+
+  if (!dev->disk)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, "not a disk");
+      goto done;
+    }
+
+  gpt = grub_gpt_read (dev->disk);
+  if (!gpt)
+    goto done;
+
+  if (grub_gpt_both_valid (gpt))
+    {
+      grub_printf_ (N_("GPT already valid, %s unmodified.\n"), dev_name);
+      goto done;
+    }
+
+  if (!grub_gpt_primary_valid (gpt))
+    grub_printf_ (N_("Found invalid primary GPT on %s\n"), dev_name);
+
+  if (!grub_gpt_backup_valid (gpt))
+    grub_printf_ (N_("Found invalid backup GPT on %s\n"), dev_name);
+
+  if (grub_gpt_repair (dev->disk, gpt))
+    goto done;
+
+  if (grub_gpt_write (dev->disk, gpt))
+    goto done;
+
+  grub_printf_ (N_("Repaired GPT on %s\n"), dev_name);
+
+done:
+  if (gpt)
+    grub_gpt_free (gpt);
+
+  if (dev)
+    grub_device_close (dev);
+
+  return grub_errno;
+}
+
+static grub_command_t cmd;
+
+GRUB_MOD_INIT(gptrepair)
+{
+  cmd = grub_register_command ("gptrepair", grub_cmd_gptrepair,
+			       N_("DEVICE"),
+			       N_("Verify and repair GPT on drive DEVICE."));
+}
+
+GRUB_MOD_FINI(gptrepair)
+{
+  grub_unregister_command (cmd);
+}
diff -Naur a/grub-core/commands/search.c b/grub-core/commands/search.c
--- a/grub-core/commands/search.c	2024-09-05 16:04:35.464205478 -0000
+++ b/grub-core/commands/search.c	2024-09-05 16:14:56.337547508 -0000
@@ -33,6 +33,10 @@
 #include <grub/efi/api.h>
 #include <grub/time.h>
 
+#if defined(DO_SEARCH_PART_UUID) || defined(DO_SEARCH_PART_LABEL)
+#include <grub/gpt_partition.h>
+#endif
+
 GRUB_MOD_LICENSE ("GPLv3+");
 
 struct cache_entry
@@ -264,6 +268,44 @@
 	}
       grub_free (buf);
     }
+#elif defined(DO_SEARCH_PART_UUID)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev)
+	{
+	  if (grub_gpt_part_uuid (dev, &quid) == GRUB_ERR_NONE)
+	    {
+	      if (grub_strcasecmp (quid, ctx->key) == 0)
+		    found = 1;
+
+	      grub_free (quid);
+	    }
+
+	  grub_device_close (dev);
+	}
+    }
+#elif defined(DO_SEARCH_PART_LABEL)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev)
+	{
+	  if (grub_gpt_part_label (dev, &quid) == GRUB_ERR_NONE)
+	    {
+	      if (grub_strcmp (quid, ctx->key) == 0)
+		    found = 1;
+
+	      grub_free (quid);
+	    }
+
+	  grub_device_close (dev);
+	}
+    }
 #else
     {
       /* SEARCH_FS_UUID or SEARCH_LABEL */
@@ -487,6 +529,10 @@
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_INIT(search_fs_file)
+#elif defined(DO_SEARCH_PART_UUID)
+GRUB_MOD_INIT(search_part_uuid)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_INIT(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_INIT(search_fs_uuid)
 #else
@@ -501,6 +547,10 @@
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_FINI(search_fs_file)
+#elif defined(DO_SEARCH_PART_UUID)
+GRUB_MOD_FINI(search_part_uuid)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_FINI(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_FINI(search_fs_uuid)
 #else
diff -Naur a/grub-core/commands/search_part_label.c b/grub-core/commands/search_part_label.c
--- a/grub-core/commands/search_part_label.c	1970-01-01 00:00:00.000000000 -0000
+++ b/grub-core/commands/search_part_label.c	2024-09-05 16:05:42.310358826 -0000
@@ -0,0 +1,5 @@
+#define DO_SEARCH_PART_LABEL 1
+#define FUNC_NAME grub_search_part_label
+#define COMMAND_NAME "search.part_label"
+#define HELP_MESSAGE N_("Search devices by partition label. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff -Naur a/grub-core/commands/search_part_uuid.c b/grub-core/commands/search_part_uuid.c
--- a/grub-core/commands/search_part_uuid.c	1970-01-01 00:00:00.000000000 -0000
+++ b/grub-core/commands/search_part_uuid.c	2024-09-05 16:05:42.310358826 -0000
@@ -0,0 +1,5 @@
+#define DO_SEARCH_PART_UUID 1
+#define FUNC_NAME grub_search_part_uuid
+#define COMMAND_NAME "search.part_uuid"
+#define HELP_MESSAGE N_("Search devices by partition UUID. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff -Naur a/grub-core/commands/search_wrap.c b/grub-core/commands/search_wrap.c
--- a/grub-core/commands/search_wrap.c	2024-09-05 16:04:35.438205418 -0000
+++ b/grub-core/commands/search_wrap.c	2024-09-05 16:12:58.537303529 -0000
@@ -36,6 +36,10 @@
      0, 0},
     {"fs-uuid",		'u', 0, N_("Search devices by a filesystem UUID."),
      0, 0},
+    {"part-label",	'L', 0, N_("Search devices by a partition label."),
+     0, 0},
+    {"part-uuid",	'U', 0, N_("Search devices by a partition UUID."),
+     0, 0},
     {"set",		's', GRUB_ARG_OPTION_OPTIONAL,
      N_("Set a variable to the first device found."), N_("VARNAME"),
      ARG_TYPE_STRING},
@@ -73,6 +77,8 @@
     SEARCH_FILE,
     SEARCH_LABEL,
     SEARCH_FS_UUID,
+    SEARCH_PART_LABEL,
+    SEARCH_PART_UUID,
     SEARCH_SET,
     SEARCH_NO_FLOPPY,
     SEARCH_EFIDISK_ONLY,
@@ -198,6 +204,10 @@
     grub_search_label (id, var, flags, hints, nhints);
   else if (state[SEARCH_FS_UUID].set)
     grub_search_fs_uuid (id, var, flags, hints, nhints);
+  else if (state[SEARCH_PART_LABEL].set)
+    grub_search_part_label (id, var, flags, hints, nhints);
+  else if (state[SEARCH_PART_UUID].set)
+    grub_search_part_uuid (id, var, flags, hints, nhints);
   else if (state[SEARCH_FILE].set)
     grub_search_fs_file (id, var, flags, hints, nhints);
   else
diff -Naur a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
--- a/grub-core/lib/gpt.c	1970-01-01 00:00:00.000000000 -0000
+++ b/grub-core/lib/gpt.c	2024-09-05 16:43:30.533499724 -0000
@@ -0,0 +1,757 @@
+/* gpt.c - Read/Verify/Write GUID Partition Tables (GPT).  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2005,2006,2007,2008  Free Software Foundation, Inc.
+ *  Copyright (C) 2014 CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/charset.h>
+#include <grub/crypto.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/dl.h>
+#include <grub/msdos_partition.h>
+#include <grub/gpt_partition.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
+
+static grub_err_t
+grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
+		       struct grub_gpt_header *header,
+		       void **ret_entries,
+		       grub_size_t *ret_entries_size);
+
+char *
+grub_gpt_guid_to_str (grub_packed_guid_t *guid)
+{
+  return grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+			 grub_le_to_cpu32 (guid->data1),
+			 grub_le_to_cpu16 (guid->data2),
+			 grub_le_to_cpu16 (guid->data3),
+			 guid->data4[0], guid->data4[1],
+			 guid->data4[2], guid->data4[3],
+			 guid->data4[4], guid->data4[5],
+			 guid->data4[6], guid->data4[7]);
+}
+
+static grub_err_t
+grub_gpt_device_partentry (grub_device_t device,
+			   struct grub_gpt_partentry *entry)
+{
+  grub_disk_t disk = device->disk;
+  grub_partition_t p;
+  grub_err_t err;
+
+  if (!disk || !disk->partition)
+    return grub_error (GRUB_ERR_BUG, "not a partition");
+
+  if (grub_strcmp (disk->partition->partmap->name, "gpt"))
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "not a GPT partition");
+
+  p = disk->partition;
+  disk->partition = p->parent;
+  err = grub_disk_read (disk, p->offset, p->index, sizeof (*entry), entry);
+  disk->partition = p;
+
+  return err;
+}
+
+grub_err_t
+grub_gpt_part_label (grub_device_t device, char **label)
+{
+  struct grub_gpt_partentry entry;
+  const grub_size_t name_len = ARRAY_SIZE (entry.name);
+  const grub_size_t label_len = name_len * GRUB_MAX_UTF8_PER_UTF16 + 1;
+  grub_size_t i;
+  grub_uint8_t *end;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *label = grub_malloc (label_len);
+  if (!*label)
+    return grub_errno;
+
+  for (i = 0; i < name_len; i++)
+    entry.name[i] = grub_le_to_cpu16 (entry.name[i]);
+
+  end = grub_utf16_to_utf8 ((grub_uint8_t *) *label, entry.name, name_len);
+  *end = '\0';
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_part_uuid (grub_device_t device, char **uuid)
+{
+  struct grub_gpt_partentry entry;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *uuid = grub_gpt_guid_to_str (&entry.guid);
+  if (!*uuid)
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+static struct grub_gpt_header *
+grub_gpt_get_header (grub_gpt_t gpt)
+{
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    return &gpt->primary;
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    return &gpt->backup;
+
+  grub_error (GRUB_ERR_BUG, "No valid GPT header");
+  return NULL;
+}
+
+static grub_uint64_t
+grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
+{
+  unsigned int sector_size;
+  grub_uint64_t sectors;
+
+  sector_size = 1U << gpt->log_sector_size;
+  sectors = size / sector_size;
+  if (size % sector_size)
+    sectors++;
+
+  return sectors;
+}
+
+/* Copied from grub-core/kern/disk_common.c grub_disk_adjust_range so we can
+ * avoid attempting to use disk->total_sectors when GRUB won't let us.
+ * TODO: Why is disk->total_sectors not set to GRUB_DISK_SIZE_UNKNOWN?  */
+static int
+grub_gpt_disk_size_valid (grub_disk_t disk)
+{
+  grub_disk_addr_t total_sectors;
+
+  /* Transform total_sectors to number of 512B blocks.  */
+  total_sectors = disk->total_sectors << (disk->log_sector_size - GRUB_DISK_SECTOR_BITS);
+
+  /* Some drivers have problems with disks above reasonable.
+     Treat unknown as 1EiB disk. While on it, clamp the size to 1EiB.
+     Just one condition is enough since GRUB_DISK_UNKNOWN_SIZE << ls is always
+     above 9EiB.
+  */
+  if (total_sectors > (1ULL << 51))
+    return 0;
+
+  return 1;
+}
+
+static void
+grub_gpt_lecrc32 (grub_uint32_t *crc, const void *data, grub_size_t len)
+{
+  grub_uint32_t crc32_val;
+
+  grub_crypto_hash (GRUB_MD_CRC32, &crc32_val, data, len);
+
+  /* GRUB_MD_CRC32 always uses big endian, gpt is always little.  */
+  *crc = grub_swap_bytes32 (crc32_val);
+}
+
+static void
+grub_gpt_header_lecrc32 (grub_uint32_t *crc, struct grub_gpt_header *header)
+{
+  grub_uint32_t old, new;
+
+  /* crc32 must be computed with the field cleared.  */
+  old = header->crc32;
+  header->crc32 = 0;
+  grub_gpt_lecrc32 (&new, header, sizeof (*header));
+  header->crc32 = old;
+
+  *crc = new;
+}
+
+/* Make sure the MBR is a protective MBR and not a normal MBR.  */
+grub_err_t
+grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
+{
+  unsigned int i;
+
+  if (mbr->signature !=
+      grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid MBR signature");
+
+  for (i = 0; i < sizeof (mbr->entries); i++)
+    if (mbr->entries[i].type == GRUB_PC_PARTITION_TYPE_GPT_DISK)
+      return GRUB_ERR_NONE;
+
+  return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid protective MBR");
+}
+
+static grub_uint64_t
+grub_gpt_entries_size (struct grub_gpt_header *gpt)
+{
+  return (grub_uint64_t) grub_le_to_cpu32 (gpt->maxpart) *
+         (grub_uint64_t) grub_le_to_cpu32 (gpt->partentry_size);
+}
+
+static grub_uint64_t
+grub_gpt_entries_sectors (struct grub_gpt_header *gpt,
+			  unsigned int log_sector_size)
+{
+  grub_uint64_t sector_bytes, entries_bytes;
+
+  sector_bytes = 1ULL << log_sector_size;
+  entries_bytes = grub_gpt_entries_size (gpt);
+  return grub_divmod64(entries_bytes + sector_bytes - 1, sector_bytes, NULL);
+}
+
+static int
+is_pow2 (grub_uint32_t n)
+{
+  return (n & (n - 1)) == 0;
+}
+
+grub_err_t
+grub_gpt_header_check (struct grub_gpt_header *gpt,
+		       unsigned int log_sector_size)
+{
+  grub_uint32_t crc = 0, size;
+  grub_uint64_t start, end;
+
+  if (grub_memcmp (gpt->magic, grub_gpt_magic, sizeof (grub_gpt_magic)) != 0)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT signature");
+
+  if (gpt->version != GRUB_GPT_HEADER_VERSION)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "unknown GPT version");
+
+  grub_gpt_header_lecrc32 (&crc, gpt);
+  if (gpt->crc32 != crc)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header crc32");
+
+  /* The header size "must be greater than or equal to 92 and must be less
+   * than or equal to the logical block size."  */
+  size = grub_le_to_cpu32 (gpt->headersize);
+  if (size < 92U || size > (1U << log_sector_size))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header size");
+
+  /* The partition entry size must be "a value of 128*(2^n) where n is an
+   * integer greater than or equal to zero (e.g., 128, 256, 512, etc.)."  */
+  size = grub_le_to_cpu32 (gpt->partentry_size);
+  if (size < 128U || size % 128U || !is_pow2 (size / 128U))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry size");
+
+  /* The minimum entries table size is specified in terms of bytes,
+   * regardless of how large the individual entry size is.  */
+  if (grub_gpt_entries_size (gpt) < GRUB_GPT_DEFAULT_ENTRIES_SIZE)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry table size");
+
+  /* And of course there better be some space for partitions!  */
+  start = grub_le_to_cpu64 (gpt->start);
+  end = grub_le_to_cpu64 (gpt->end);
+  if (start > end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid usable sectors");
+
+  return GRUB_ERR_NONE;
+}
+
+static int
+grub_gpt_headers_equal (grub_gpt_t gpt)
+{
+  /* Assume headers passed grub_gpt_header_check so skip magic and version.
+   * Individual fields must be checked instead of just using memcmp because
+   * crc32, header, alternate, and partitions will all normally differ.  */
+
+  if (gpt->primary.headersize != gpt->backup.headersize ||
+      gpt->primary.header_lba != gpt->backup.alternate_lba ||
+      gpt->primary.alternate_lba != gpt->backup.header_lba ||
+      gpt->primary.start != gpt->backup.start ||
+      gpt->primary.end != gpt->backup.end ||
+      gpt->primary.maxpart != gpt->backup.maxpart ||
+      gpt->primary.partentry_size != gpt->backup.partentry_size ||
+      gpt->primary.partentry_crc32 != gpt->backup.partentry_crc32)
+    return 0;
+
+  return grub_memcmp(&gpt->primary.guid, &gpt->backup.guid,
+                     sizeof(grub_packed_guid_t)) == 0;
+}
+
+static grub_err_t
+grub_gpt_check_primary (grub_gpt_t gpt)
+{
+  grub_uint64_t backup, primary, entries, entries_len, start, end;
+
+  primary = grub_le_to_cpu64 (gpt->primary.header_lba);
+  backup = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+  entries = grub_le_to_cpu64 (gpt->primary.partitions);
+  entries_len = grub_gpt_entries_sectors(&gpt->primary, gpt->log_sector_size);
+  start = grub_le_to_cpu64 (gpt->primary.start);
+  end = grub_le_to_cpu64 (gpt->primary.end);
+
+  grub_dprintf ("gpt", "Primary GPT layout:\n"
+		"primary header = 0x%llx backup header = 0x%llx\n"
+		"entries location = 0x%llx length = 0x%llx\n"
+		"first usable = 0x%llx last usable = 0x%llx\n",
+		(unsigned long long) primary,
+		(unsigned long long) backup,
+		(unsigned long long) entries,
+		(unsigned long long) entries_len,
+		(unsigned long long) start,
+		(unsigned long long) end);
+
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_errno;
+  if (primary != 1)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid primary GPT LBA");
+  if (entries <= 1 || entries+entries_len > start)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid entries location");
+  if (backup <= end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_check_backup (grub_gpt_t gpt)
+{
+  grub_uint64_t backup, primary, entries, entries_len, start, end;
+
+  backup = grub_le_to_cpu64 (gpt->backup.header_lba);
+  primary = grub_le_to_cpu64 (gpt->backup.alternate_lba);
+  entries = grub_le_to_cpu64 (gpt->backup.partitions);
+  entries_len = grub_gpt_entries_sectors(&gpt->backup, gpt->log_sector_size);
+  start = grub_le_to_cpu64 (gpt->backup.start);
+  end = grub_le_to_cpu64 (gpt->backup.end);
+
+  grub_dprintf ("gpt", "Backup GPT layout:\n"
+		"primary header = 0x%llx backup header = 0x%llx\n"
+		"entries location = 0x%llx length = 0x%llx\n"
+		"first usable = 0x%llx last usable = 0x%llx\n",
+		(unsigned long long) primary,
+		(unsigned long long) backup,
+		(unsigned long long) entries,
+		(unsigned long long) entries_len,
+		(unsigned long long) start,
+		(unsigned long long) end);
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_errno;
+  if (primary != 1)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid primary GPT LBA");
+  if (entries <= end || entries+entries_len > backup)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid entries location");
+  if (backup <= end)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
+
+  /* If both primary and backup are valid but differ prefer the primary.  */
+  if ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
+      !grub_gpt_headers_equal (gpt))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT out of sync");
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_disk_addr_t addr;
+
+  /* TODO: The gpt partmap module searches for the primary header instead
+   * of relying on the disk's sector size. For now trust the disk driver
+   * but eventually this code should match the existing behavior.  */
+  gpt->log_sector_size = disk->log_sector_size;
+
+  grub_dprintf ("gpt", "reading primary GPT from sector 0x1\n");
+
+  addr = grub_gpt_sector_to_addr (gpt, 1);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->primary), &gpt->primary))
+    return grub_errno;
+
+  if (grub_gpt_check_primary (gpt))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_PRIMARY_HEADER_VALID;
+
+  if (grub_gpt_read_entries (disk, gpt, &gpt->primary,
+			     &gpt->entries, &gpt->entries_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
+{
+  void *entries = NULL;
+  grub_size_t entries_size;
+  grub_uint64_t sector;
+  grub_disk_addr_t addr;
+
+  /* Assumes gpt->log_sector_size == disk->log_sector_size  */
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    {
+      sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      if (grub_gpt_disk_size_valid (disk) && sector >= disk->total_sectors)
+	return grub_error (GRUB_ERR_OUT_OF_RANGE,
+			   "backup GPT located at 0x%llx, "
+			   "beyond last disk sector at 0x%llx",
+			   (unsigned long long) sector,
+			   (unsigned long long) disk->total_sectors - 1);
+    }
+  else if (grub_gpt_disk_size_valid (disk))
+    sector = disk->total_sectors - 1;
+  else
+    return grub_error (GRUB_ERR_OUT_OF_RANGE,
+		       "size of disk unknown, cannot locate backup GPT");
+
+  grub_dprintf ("gpt", "reading backup GPT from sector 0x%llx\n",
+		(unsigned long long) sector);
+
+  addr = grub_gpt_sector_to_addr (gpt, sector);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->backup), &gpt->backup))
+    return grub_errno;
+
+  if (grub_gpt_check_backup (gpt))
+    return grub_errno;
+
+  /* Ensure the backup header thinks it is located where we found it.  */
+  if (grub_le_to_cpu64 (gpt->backup.header_lba) != sector)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid backup GPT LBA");
+
+  gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
+
+  if (grub_gpt_read_entries (disk, gpt, &gpt->backup,
+			     &entries, &entries_size))
+    return grub_errno;
+
+  if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID)
+    {
+      if (entries_size != gpt->entries_size ||
+	  grub_memcmp (entries, gpt->entries, entries_size) != 0)
+	return grub_error (GRUB_ERR_BAD_PART_TABLE, "backup GPT out of sync");
+
+      grub_free (entries);
+    }
+  else
+    {
+      gpt->entries = entries;
+      gpt->entries_size = entries_size;
+    }
+
+  gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
+		       struct grub_gpt_header *header,
+		       void **ret_entries,
+		       grub_size_t *ret_entries_size)
+{
+  void *entries = NULL;
+  grub_uint32_t count, size, crc;
+  grub_uint64_t sector;
+  grub_disk_addr_t addr;
+  grub_size_t entries_size;
+
+  /* Grub doesn't include calloc, hence the manual overflow check.  */
+  count = grub_le_to_cpu32 (header->maxpart);
+  size = grub_le_to_cpu32 (header->partentry_size);
+  entries_size = count *size;
+  if (size && entries_size / size != count)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+      goto fail;
+    }
+
+  /* Double check that the header was validated properly.  */
+  if (entries_size < GRUB_GPT_DEFAULT_ENTRIES_SIZE)
+    return grub_error (GRUB_ERR_BUG, "invalid GPT entries table size");
+
+  entries = grub_malloc (entries_size);
+  if (!entries)
+    goto fail;
+
+  sector = grub_le_to_cpu64 (header->partitions);
+  grub_dprintf ("gpt", "reading GPT %lu entries from sector 0x%llx\n",
+		(unsigned long) count,
+		(unsigned long long) sector);
+
+  addr = grub_gpt_sector_to_addr (gpt, sector);
+  if (grub_disk_read (disk, addr, 0, entries_size, entries))
+    goto fail;
+
+  grub_gpt_lecrc32 (&crc, entries, entries_size);
+  if (crc != header->partentry_crc32)
+    {
+      grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry crc32");
+      goto fail;
+    }
+
+  *ret_entries = entries;
+  *ret_entries_size = entries_size;
+  return GRUB_ERR_NONE;
+
+fail:
+  grub_free (entries);
+  return grub_errno;
+}
+
+grub_gpt_t
+grub_gpt_read (grub_disk_t disk)
+{
+  grub_gpt_t gpt;
+
+  grub_dprintf ("gpt", "reading GPT from %s\n", disk->name);
+
+  gpt = grub_zalloc (sizeof (*gpt));
+  if (!gpt)
+    goto fail;
+
+  if (grub_disk_read (disk, 0, 0, sizeof (gpt->mbr), &gpt->mbr))
+    goto fail;
+
+  /* Check the MBR but errors aren't reported beyond the status bit.  */
+  if (grub_gpt_pmbr_check (&gpt->mbr))
+    grub_errno = GRUB_ERR_NONE;
+  else
+    gpt->status |= GRUB_GPT_PROTECTIVE_MBR;
+
+  /* If both the primary and backup fail report the primary's error.  */
+  if (grub_gpt_read_primary (disk, gpt))
+    {
+      grub_error_push ();
+      grub_gpt_read_backup (disk, gpt);
+      grub_error_pop ();
+    }
+  else
+    grub_gpt_read_backup (disk, gpt);
+
+  /* If either succeeded clear any possible error from the other.  */
+  if (grub_gpt_primary_valid (gpt) || grub_gpt_backup_valid (gpt))
+    grub_errno = GRUB_ERR_NONE;
+  else
+    goto fail;
+
+  return gpt;
+
+fail:
+  grub_gpt_free (gpt);
+  return NULL;
+}
+
+struct grub_gpt_partentry *
+grub_gpt_get_partentry (grub_gpt_t gpt, grub_uint32_t n)
+{
+  struct grub_gpt_header *header;
+  grub_size_t offset;
+
+  header = grub_gpt_get_header (gpt);
+  if (!header)
+    return NULL;
+
+  if (n >= grub_le_to_cpu32 (header->maxpart))
+    return NULL;
+
+  offset = (grub_size_t) grub_le_to_cpu32 (header->partentry_size) * n;
+  return (struct grub_gpt_partentry *) ((char *) gpt->entries + offset);
+}
+
+grub_err_t
+grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
+{
+  /* Skip if there is nothing to do.  */
+  if (grub_gpt_both_valid (gpt))
+    return GRUB_ERR_NONE;
+
+  grub_dprintf ("gpt", "repairing GPT for %s\n", disk->name);
+
+  if (disk->log_sector_size != gpt->log_sector_size)
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "GPT sector size must match disk sector size");
+
+  if (grub_gpt_primary_valid (gpt))
+    {
+      grub_uint64_t backup_header;
+
+      grub_dprintf ("gpt", "primary GPT is valid\n");
+
+      /* Relocate backup to end if disk if the disk has grown.  */
+      backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      if (grub_gpt_disk_size_valid (disk) &&
+	  disk->total_sectors - 1 > backup_header)
+	{
+	  backup_header = disk->total_sectors - 1;
+	  grub_dprintf ("gpt", "backup GPT header relocated to 0x%llx\n",
+			(unsigned long long) backup_header);
+
+	  gpt->primary.alternate_lba = grub_cpu_to_le64 (backup_header);
+	}
+
+      grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
+      gpt->backup.header_lba = gpt->primary.alternate_lba;
+      gpt->backup.alternate_lba = gpt->primary.header_lba;
+      gpt->backup.partitions = grub_cpu_to_le64 (backup_header -
+	  grub_gpt_size_to_sectors (gpt, gpt->entries_size));
+    }
+  else if (grub_gpt_backup_valid (gpt))
+    {
+      grub_dprintf ("gpt", "backup GPT is valid\n");
+
+      grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
+      gpt->primary.header_lba = gpt->backup.alternate_lba;
+      gpt->primary.alternate_lba = gpt->backup.header_lba;
+      gpt->primary.partitions = grub_cpu_to_le64_compile_time (2);
+    }
+  else
+    return grub_error (GRUB_ERR_BUG, "No valid GPT");
+
+  if (grub_gpt_update (gpt))
+    return grub_errno;
+
+  grub_dprintf ("gpt", "repairing GPT for %s successful\n", disk->name);
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_update (grub_gpt_t gpt)
+{
+  grub_uint32_t crc;
+
+  /* Clear status bits, require revalidation of everything.  */
+  gpt->status &= ~(GRUB_GPT_PRIMARY_HEADER_VALID |
+		   GRUB_GPT_PRIMARY_ENTRIES_VALID |
+		   GRUB_GPT_BACKUP_HEADER_VALID |
+		   GRUB_GPT_BACKUP_ENTRIES_VALID);
+
+  /* Writing headers larger than our header structure are unsupported.  */
+  gpt->primary.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->primary));
+  gpt->backup.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->backup));
+
+  grub_gpt_lecrc32 (&crc, gpt->entries, gpt->entries_size);
+  gpt->primary.partentry_crc32 = crc;
+  gpt->backup.partentry_crc32 = crc;
+
+  grub_gpt_header_lecrc32 (&gpt->primary.crc32, &gpt->primary);
+  grub_gpt_header_lecrc32 (&gpt->backup.crc32, &gpt->backup);
+
+  if (grub_gpt_check_primary (gpt))
+    {
+      grub_error_push ();
+      return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+    }
+
+  gpt->status |= (GRUB_GPT_PRIMARY_HEADER_VALID |
+		  GRUB_GPT_PRIMARY_ENTRIES_VALID);
+
+  if (grub_gpt_check_backup (gpt))
+    {
+      grub_error_push ();
+      return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+    }
+
+  gpt->status |= (GRUB_GPT_BACKUP_HEADER_VALID |
+		  GRUB_GPT_BACKUP_ENTRIES_VALID);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_write_table (grub_disk_t disk, grub_gpt_t gpt,
+		      struct grub_gpt_header *header)
+{
+  grub_disk_addr_t addr;
+
+  if (grub_le_to_cpu32 (header->headersize) != sizeof (*header))
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "Header size is %u, must be %zu",
+		       grub_le_to_cpu32 (header->headersize),
+		       sizeof (*header));
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->header_lba));
+  if (addr == 0)
+    return grub_error (GRUB_ERR_BUG,
+		       "Refusing to write GPT header to address 0x0");
+  if (grub_disk_write (disk, addr, 0, sizeof (*header), header))
+    return grub_errno;
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (addr < 2)
+    return grub_error (GRUB_ERR_BUG,
+		       "Refusing to write GPT entries to address 0x%llx",
+		       (unsigned long long) addr);
+  if (grub_disk_write (disk, addr, 0, gpt->entries_size, gpt->entries))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_uint64_t backup_header;
+
+  /* TODO: update/repair protective MBRs too.  */
+
+  if (!grub_gpt_both_valid (gpt))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
+
+  /* Write the backup GPT first so if writing fails the update is aborted
+   * and the primary is left intact.  However if the backup location is
+   * inaccessible we have to just skip and hope for the best, the backup
+   * will need to be repaired in the OS.  */
+  backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
+  if (grub_gpt_disk_size_valid (disk) &&
+      backup_header >= disk->total_sectors)
+    {
+      grub_printf ("warning: backup GPT located at 0x%llx, "
+		   "beyond last disk sector at 0x%llx\n",
+		   (unsigned long long) backup_header,
+		   (unsigned long long) disk->total_sectors - 1);
+      grub_printf ("warning: only writing primary GPT, "
+	           "the backup GPT must be repaired from the OS\n");
+    }
+  else
+    {
+      grub_dprintf ("gpt", "writing backup GPT to %s\n", disk->name);
+      if (grub_gpt_write_table (disk, gpt, &gpt->backup))
+	return grub_errno;
+    }
+
+  grub_dprintf ("gpt", "writing primary GPT to %s\n", disk->name);
+  if (grub_gpt_write_table (disk, gpt, &gpt->primary))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+void
+grub_gpt_free (grub_gpt_t gpt)
+{
+  if (!gpt)
+    return;
+
+  grub_free (gpt->entries);
+  grub_free (gpt);
+}
diff -Naur a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
--- a/include/grub/gpt_partition.h	2023-11-22 17:52:44.000000000 -0000
+++ b/include/grub/gpt_partition.h	2024-09-05 16:43:04.107463044 -0000
@@ -21,25 +21,45 @@
 
 #include <grub/types.h>
 #include <grub/partition.h>
+#include <grub/msdos_partition.h>
 
-#define GRUB_GPT_PARTITION_TYPE_EMPTY \
-  { 0x0, 0x0, 0x0, \
-    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } \
+/* Format the raw little-endian GUID as a newly allocated string.  */
+char * grub_gpt_guid_to_str (grub_packed_guid_t *guid);
+
+
+#define GRUB_GPT_GUID_INIT(a, b, c, d1, d2, d3, d4, d5, d6, d7, d8)  \
+  {					\
+    grub_cpu_to_le32_compile_time (a),	\
+    grub_cpu_to_le16_compile_time (b),	\
+    grub_cpu_to_le16_compile_time (c),	\
+    { d1, d2, d3, d4, d5, d6, d7, d8 }	\
   }
 
+#define GRUB_GPT_PARTITION_TYPE_EMPTY \
+  GRUB_GPT_GUID_INIT (0x0, 0x0, 0x0,  \
+      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
+
+#define GRUB_GPT_PARTITION_TYPE_EFI_SYSTEM \
+  GRUB_GPT_GUID_INIT (0xc12a7328, 0xf81f, 0x11d2, \
+      0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b)
+
 #define GRUB_GPT_PARTITION_TYPE_BIOS_BOOT \
-  { grub_cpu_to_le32_compile_time (0x21686148), \
-      grub_cpu_to_le16_compile_time (0x6449), \
-      grub_cpu_to_le16_compile_time (0x6e6f),	       \
-    { 0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 } \
-  }
+  GRUB_GPT_GUID_INIT (0x21686148, 0x6449, 0x6e6f, \
+      0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
 
 #define GRUB_GPT_PARTITION_TYPE_LDM \
-  { grub_cpu_to_le32_compile_time (0x5808C8AAU),\
-      grub_cpu_to_le16_compile_time (0x7E8F), \
-      grub_cpu_to_le16_compile_time (0x42E0),	       \
-	{ 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3 }	\
-  }
+  GRUB_GPT_GUID_INIT (0x5808c8aa, 0x7e8f, 0x42e0, \
+      0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3)
+
+#define GRUB_GPT_PARTITION_TYPE_USR_X86_64 \
+  GRUB_GPT_GUID_INIT (0x5dfbf5f4, 0x2848, 0x4bac, \
+      0xaa, 0x5e, 0x0d, 0x9a, 0x20, 0xb7, 0x45, 0xa6)
+
+#define GRUB_GPT_HEADER_MAGIC \
+  { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
+
+#define GRUB_GPT_HEADER_VERSION	\
+  grub_cpu_to_le32_compile_time (0x00010000U)
 
 struct grub_gpt_header
 {
@@ -48,11 +68,11 @@
   grub_uint32_t headersize;
   grub_uint32_t crc32;
   grub_uint32_t unused1;
-  grub_uint64_t primary;
-  grub_uint64_t backup;
+  grub_uint64_t header_lba;
+  grub_uint64_t alternate_lba;
   grub_uint64_t start;
   grub_uint64_t end;
-  grub_uint8_t guid[16];
+  grub_packed_guid_t guid;
   grub_uint64_t partitions;
   grub_uint32_t maxpart;
   grub_uint32_t partentry_size;
@@ -66,13 +86,168 @@
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint64_t attrib;
-  char name[72];
+  grub_uint16_t name[36];
 };
 
+enum grub_gpt_part_attr_offset
+{
+  /* Standard partition attribute bits defined by UEFI.  */
+  GRUB_GPT_PART_ATTR_OFFSET_REQUIRED			= 0,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_BLOCK_IO_PROTOCOL	= 1,
+  GRUB_GPT_PART_ATTR_OFFSET_LEGACY_BIOS_BOOTABLE	= 2,
+
+  /* De facto standard attribute bits defined by Microsoft and reused by
+   * http://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec */
+  GRUB_GPT_PART_ATTR_OFFSET_READ_ONLY			= 60,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_AUTO			= 63,
+
+  /* Partition attributes for priority based selection,
+   * Currently only valid for PARTITION_TYPE_USR_X86_64.
+   * TRIES_LEFT and PRIORITY are 4 bit wide fields.  */
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_PRIORITY		= 48,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT		= 52,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_SUCCESSFUL		= 56,
+};
+
+/* Helpers for reading/writing partition attributes.  */
+static inline grub_uint64_t
+grub_gpt_entry_attribute (struct grub_gpt_partentry *entry,
+			  enum grub_gpt_part_attr_offset offset,
+			  unsigned int bits)
+{
+  grub_uint64_t attrib = grub_le_to_cpu64 (entry->attrib);
+
+  return (attrib >> offset) & ((1ULL << bits) - 1);
+}
+
+static inline void
+grub_gpt_entry_set_attribute (struct grub_gpt_partentry *entry,
+			      grub_uint64_t value,
+			      enum grub_gpt_part_attr_offset offset,
+			      unsigned int bits)
+{
+  grub_uint64_t attrib, mask;
+
+  mask = (((1ULL << bits) - 1) << offset);
+  attrib = grub_le_to_cpu64 (entry->attrib) & ~mask;
+  attrib |= ((value << offset) & mask);
+  entry->attrib = grub_cpu_to_le64 (attrib);
+}
+
+/* Basic GPT partmap module.  */
 grub_err_t
 grub_gpt_partition_map_iterate (grub_disk_t disk,
 				grub_partition_iterate_hook_t hook,
 				void *hook_data);
 
+/* Advanced GPT library.  */
+
+/* Status bits for the grub_gpt.status field.  */
+#define GRUB_GPT_PROTECTIVE_MBR		0x01
+#define GRUB_GPT_HYBRID_MBR		0x02
+#define GRUB_GPT_PRIMARY_HEADER_VALID	0x04
+#define GRUB_GPT_PRIMARY_ENTRIES_VALID	0x08
+#define GRUB_GPT_BACKUP_HEADER_VALID	0x10
+#define GRUB_GPT_BACKUP_ENTRIES_VALID	0x20
+
+/* UEFI requires the entries table to be at least 16384 bytes for a
+ * total of 128 entries given the standard 128 byte entry size.  */
+#define GRUB_GPT_DEFAULT_ENTRIES_SIZE	16384
+#define GRUB_GPT_DEFAULT_ENTRIES_LENGTH	\
+  (GRUB_GPT_DEFAULT_ENTRIES_SIZE / sizeof (struct grub_gpt_partentry))
+
+struct grub_gpt
+{
+  /* Bit field indicating which structures on disk are valid.  */
+  unsigned status;
+
+  /* Protective or hybrid MBR.  */
+  struct grub_msdos_partition_mbr mbr;
+
+  /* Each of the two GPT headers.  */
+  struct grub_gpt_header primary;
+  struct grub_gpt_header backup;
+
+  /* Only need one entries table, on disk both copies are identical.
+   * The on disk entry size may be larger than our partentry struct so
+   * the table cannot be indexed directly.  */
+  void *entries;
+  grub_size_t entries_size;
+
+  /* Logarithm of sector size, in case GPT and disk driver disagree.  */
+  unsigned int log_sector_size;
+};
+typedef struct grub_gpt *grub_gpt_t;
+
+/* Helpers for checking the gpt status field.  */
+static inline int
+grub_gpt_mbr_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_PROTECTIVE_MBR) ||
+	  (gpt->status & GRUB_GPT_HYBRID_MBR));
+}
+
+static inline int
+grub_gpt_primary_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) &&
+	  (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID));
+}
+
+static inline int
+grub_gpt_backup_valid (grub_gpt_t gpt)
+{
+  return ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) &&
+	  (gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID));
+}
+
+static inline int
+grub_gpt_both_valid (grub_gpt_t gpt)
+{
+  return grub_gpt_primary_valid (gpt) && grub_gpt_backup_valid (gpt);
+}
+
+/* Translate GPT sectors to GRUB's 512 byte block addresses.  */
+static inline grub_disk_addr_t
+grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
+{
+  return (sector << (gpt->log_sector_size - GRUB_DISK_SECTOR_BITS));
+}
+
+/* Allocates and fills new grub_gpt structure, free with grub_gpt_free.  */
+grub_gpt_t grub_gpt_read (grub_disk_t disk);
+
+/* Helper for indexing into the entries table.
+ * Returns NULL when the end of the table has been reached.  */
+struct grub_gpt_partentry * grub_gpt_get_partentry (grub_gpt_t gpt,
+						    grub_uint32_t n);
+
+/* Sync and update primary and backup headers if either are invalid.  */
+grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
+
+/* Recompute checksums and revalidate everything, must be called after
+ * modifying any GPT data.  */
+grub_err_t grub_gpt_update (grub_gpt_t gpt);
+
+/* Write headers and entry tables back to disk.  */
+grub_err_t grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt);
+
+void grub_gpt_free (grub_gpt_t gpt);
+
+grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
+grub_err_t grub_gpt_header_check (struct grub_gpt_header *gpt,
+				  unsigned int log_sector_size);
+
+
+/* Utilities for simple partition data lookups, usage is intended to
+ * be similar to fs->label and fs->uuid functions.  */
+
+/* Return the partition label of the device DEVICE in LABEL.
+ * The label is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_label (grub_device_t device, char **label);
+
+/* Return the partition uuid of the device DEVICE in UUID.
+ * The uuid is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_uuid (grub_device_t device, char **uuid);

 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff -Naur a/include/grub/search.h b/include/grub/search.h
--- a/include/grub/search.h	2024-09-05 16:04:35.439205420 -0000
+++ b/include/grub/search.h	2024-09-05 16:05:42.312358830 -0000
@@ -36,5 +36,11 @@
 void grub_search_label (const char *key, const char *var,
 			enum search_flags flags,
 			char **hints, unsigned nhints);
+void grub_search_part_uuid (const char *key, const char *var,
+ 			enum search_flags flags,
+ 			char **hints, unsigned nhints);
+void grub_search_part_label (const char *key, const char *var,
+ 			enum search_flags flags,
+ 			char **hints, unsigned nhints);

 #endif
diff -Naur a/tests/gpt_unit_test.c b/tests/gpt_unit_test.c
--- a/tests/gpt_unit_test.c	1970-01-01 00:00:00.000000000 -0000
+++ b/tests/gpt_unit_test.c	2024-09-05 16:05:42.313358833 -0000
@@ -0,0 +1,807 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2014 CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/emu/hostdisk.h>
+#include <grub/emu/misc.h>
+#include <grub/env.h>
+#include <grub/err.h>
+#include <grub/gpt_partition.h>
+#include <grub/msdos_partition.h>
+#include <grub/lib/hexdump.h>
+#include <grub/search.h>
+#include <grub/test.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+/* from gnulib */
+#include <verify.h>
+
+/* Confirm that the GPT structures conform to the sizes in the spec:
+ * The header size "must be greater than or equal to 92 and must be less
+ * than or equal to the logical block size."
+ * The partition entry size must be "a value of 128*(2^n) where n is an
+ * integer greater than or equal to zero (e.g., 128, 256, 512, etc.)."  */
+verify (sizeof (struct grub_gpt_header) == 92);
+verify (sizeof (struct grub_gpt_partentry) == 128);
+
+/* GPT section sizes.  */
+#define HEADER_SIZE   (sizeof (struct grub_gpt_header))
+#define HEADER_PAD    (GRUB_DISK_SECTOR_SIZE - HEADER_SIZE)
+#define ENTRY_SIZE    (sizeof (struct grub_gpt_partentry))
+#define TABLE_ENTRIES 0x80
+#define TABLE_SIZE    (TABLE_ENTRIES * ENTRY_SIZE)
+#define TABLE_SECTORS (TABLE_SIZE / GRUB_DISK_SECTOR_SIZE)
+
+/* Double check that the table size calculation was valid.  */
+verify (TABLE_SECTORS * GRUB_DISK_SECTOR_SIZE == TABLE_SIZE);
+
+/* GPT section locations for a 1MiB disk.  */
+#define DISK_SECTORS	      0x800
+#define DISK_SIZE	      (GRUB_DISK_SECTOR_SIZE * DISK_SECTORS)
+#define PRIMARY_HEADER_SECTOR 0x1
+#define PRIMARY_TABLE_SECTOR  0x2
+#define BACKUP_HEADER_SECTOR  (DISK_SECTORS - 0x1)
+#define BACKUP_TABLE_SECTOR   (BACKUP_HEADER_SECTOR - TABLE_SECTORS)
+
+#define DATA_START_SECTOR     (PRIMARY_TABLE_SECTOR + TABLE_SECTORS)
+#define DATA_END_SECTOR	      (BACKUP_TABLE_SECTOR - 0x1)
+#define DATA_SECTORS	      (BACKUP_TABLE_SECTOR - DATA_START_SECTOR)
+#define DATA_SIZE	      (GRUB_DISK_SECTOR_SIZE * DATA_SECTORS)
+
+struct test_disk
+{
+  struct grub_msdos_partition_mbr mbr;
+
+  struct grub_gpt_header primary_header;
+  grub_uint8_t primary_header_pad[HEADER_PAD];
+  struct grub_gpt_partentry primary_entries[TABLE_ENTRIES];
+
+  grub_uint8_t data[DATA_SIZE];
+
+  struct grub_gpt_partentry backup_entries[TABLE_ENTRIES];
+  struct grub_gpt_header backup_header;
+  grub_uint8_t backup_header_pad[HEADER_PAD];
+} GRUB_PACKED;
+
+/* Sanity check that all the above ugly math was correct.  */
+verify (sizeof (struct test_disk) == DISK_SIZE);
+
+struct test_data
+{
+  int fd;
+  grub_device_t dev;
+  struct test_disk *raw;
+};
+
+
+/* Sample primary GPT header for a 1MB disk.  */
+static const struct grub_gpt_header example_primary = {
+  .magic = GRUB_GPT_HEADER_MAGIC,
+  .version = GRUB_GPT_HEADER_VERSION,
+  .headersize = sizeof (struct grub_gpt_header),
+  .crc32 = grub_cpu_to_le32_compile_time (0xb985abe0),
+  .header_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+  .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+  .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			     0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
+  .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
+  .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+  .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
+};
+
+static const struct grub_gpt_partentry example_entries[TABLE_ENTRIES] = {
+  {
+    .type = GRUB_GPT_PARTITION_TYPE_EFI_SYSTEM,
+    .guid = GRUB_GPT_GUID_INIT (0xa0f1792e, 0xb4ce, 0x4136, 0xbc, 0xf2,
+				0x1a, 0xfc, 0x13, 0x3c, 0x28, 0x28),
+    .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+    .end = grub_cpu_to_le64_compile_time (0x3f),
+    .attrib = 0x0,
+    .name = {
+      grub_cpu_to_le16_compile_time ('E'),
+      grub_cpu_to_le16_compile_time ('F'),
+      grub_cpu_to_le16_compile_time ('I'),
+      grub_cpu_to_le16_compile_time (' '),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time ('Y'),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time ('T'),
+      grub_cpu_to_le16_compile_time ('E'),
+      grub_cpu_to_le16_compile_time ('M'),
+      0x0,
+    }
+  },
+  {
+    .type = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT,
+    .guid = GRUB_GPT_GUID_INIT (0x876c898d, 0x1b40, 0x4727, 0xa1, 0x61,
+				0xed, 0xf9, 0xb5, 0x48, 0x66, 0x74),
+    .start = grub_cpu_to_le64_compile_time (0x40),
+    .end = grub_cpu_to_le64_compile_time (0x7f),
+    .attrib = grub_cpu_to_le64_compile_time (
+	1ULL << GRUB_GPT_PART_ATTR_OFFSET_LEGACY_BIOS_BOOTABLE),
+    .name = {
+      grub_cpu_to_le16_compile_time ('B'),
+      grub_cpu_to_le16_compile_time ('I'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('S'),
+      grub_cpu_to_le16_compile_time (' '),
+      grub_cpu_to_le16_compile_time ('B'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('O'),
+      grub_cpu_to_le16_compile_time ('T'),
+      0x0,
+    }
+  },
+};
+
+/* And the backup header.  */
+static const struct grub_gpt_header example_backup = {
+  .magic = GRUB_GPT_HEADER_MAGIC,
+  .version = GRUB_GPT_HEADER_VERSION,
+  .headersize = sizeof (struct grub_gpt_header),
+  .crc32 = grub_cpu_to_le32_compile_time (0x0af785eb),
+  .header_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+  .alternate_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+  .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+  .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+  .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			     0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
+  .partitions = grub_cpu_to_le64_compile_time (BACKUP_TABLE_SECTOR),
+  .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+  .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE),
+  .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
+};
+
+/* Sample protective MBR for the same 1MB disk. Note, this matches
+ * parted and fdisk behavior. The UEFI spec uses different values.  */
+static const struct grub_msdos_partition_mbr example_pmbr = {
+  .entries = {{.flag = 0x00,
+	       .start_head = 0x00,
+	       .start_sector = 0x01,
+	       .start_cylinder = 0x00,
+	       .type = 0xee,
+	       .end_head = 0xfe,
+	       .end_sector = 0xff,
+	       .end_cylinder = 0xff,
+	       .start = grub_cpu_to_le32_compile_time (0x1),
+	       .length = grub_cpu_to_le32_compile_time (DISK_SECTORS - 0x1),
+	       }},
+  .signature = grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE),
+};
+
+/* If errors are left in grub's error stack things can get confused.  */
+static void
+assert_error_stack_empty (void)
+{
+  do
+    {
+      grub_test_assert (grub_errno == GRUB_ERR_NONE,
+			"error on stack: %s", grub_errmsg);
+    }
+  while (grub_error_pop ());
+}
+
+static grub_err_t
+execute_command2 (const char *name, const char *arg1, const char *arg2)
+{
+  grub_command_t cmd;
+  grub_err_t err;
+  char *argv[2];
+
+  cmd = grub_command_find (name);
+  if (!cmd)
+    grub_fatal ("can't find command %s", name);
+
+  argv[0] = strdup (arg1);
+  argv[1] = strdup (arg2);
+  err = (cmd->func) (cmd, 2, argv);
+  free (argv[0]);
+  free (argv[1]);
+
+  return err;
+}
+
+static void
+sync_disk (struct test_data *data)
+{
+  if (msync (data->raw, DISK_SIZE, MS_SYNC | MS_INVALIDATE) < 0)
+    grub_fatal ("Syncing disk failed: %s", strerror (errno));
+
+  grub_disk_cache_invalidate_all ();
+}
+
+static void
+reset_disk (struct test_data *data)
+{
+  memset (data->raw, 0, DISK_SIZE);
+
+  /* Initialize image with valid example tables.  */
+  memcpy (&data->raw->mbr, &example_pmbr, sizeof (data->raw->mbr));
+  memcpy (&data->raw->primary_header, &example_primary,
+	  sizeof (data->raw->primary_header));
+  memcpy (&data->raw->primary_entries, &example_entries,
+	  sizeof (data->raw->primary_entries));
+  memcpy (&data->raw->backup_entries, &example_entries,
+	  sizeof (data->raw->backup_entries));
+  memcpy (&data->raw->backup_header, &example_backup,
+	  sizeof (data->raw->backup_header));
+
+  sync_disk (data);
+}
+
+static void
+open_disk (struct test_data *data)
+{
+  const char *loop = "loop0";
+  char template[] = "/tmp/grub_gpt_test.XXXXXX";
+  char host[sizeof ("(host)") + sizeof (template)];
+
+  data->fd = mkstemp (template);
+  if (data->fd < 0)
+    grub_fatal ("Creating %s failed: %s", template, strerror (errno));
+
+  if (ftruncate (data->fd, DISK_SIZE) < 0)
+    {
+      int err = errno;
+      unlink (template);
+      grub_fatal ("Resizing %s failed: %s", template, strerror (err));
+    }
+
+  data->raw = mmap (NULL, DISK_SIZE, PROT_READ | PROT_WRITE,
+		    MAP_SHARED, data->fd, 0);
+  if (data->raw == MAP_FAILED)
+    {
+      int err = errno;
+      unlink (template);
+      grub_fatal ("Maping %s failed: %s", template, strerror (err));
+    }
+
+  snprintf (host, sizeof (host), "(host)%s", template);
+  if (execute_command2 ("loopback", loop, host) != GRUB_ERR_NONE)
+    {
+      unlink (template);
+      grub_fatal ("loopback %s %s failed: %s", loop, host, grub_errmsg);
+    }
+
+  if (unlink (template) < 0)
+    grub_fatal ("Unlinking %s failed: %s", template, strerror (errno));
+
+  reset_disk (data);
+
+  data->dev = grub_device_open (loop);
+  if (!data->dev)
+    grub_fatal ("Opening %s failed: %s", loop, grub_errmsg);
+}
+
+static void
+close_disk (struct test_data *data)
+{
+  char *loop;
+
+  assert_error_stack_empty ();
+
+  if (munmap (data->raw, DISK_SIZE) || close (data->fd))
+    grub_fatal ("Closing disk image failed: %s", strerror (errno));
+
+  loop = strdup (data->dev->disk->name);
+  grub_test_assert (grub_device_close (data->dev) == GRUB_ERR_NONE,
+		    "Closing disk device failed: %s", grub_errmsg);
+
+  grub_test_assert (execute_command2 ("loopback", "-d", loop) ==
+		    GRUB_ERR_NONE, "loopback -d %s failed: %s", loop,
+		    grub_errmsg);
+
+  free (loop);
+}
+
+static grub_gpt_t
+read_disk (struct test_data *data)
+{
+  grub_gpt_t gpt;
+
+  gpt = grub_gpt_read (data->dev->disk);
+  if (gpt == NULL)
+    grub_fatal ("grub_gpt_read failed: %s", grub_errmsg);
+
+  return gpt;
+}
+
+static void
+pmbr_test (void)
+{
+  struct grub_msdos_partition_mbr mbr;
+
+  memset (&mbr, 0, sizeof (mbr));
+
+  /* Empty is invalid.  */
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* A table without a protective partition is invalid.  */
+  mbr.signature = grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE);
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* A table with a protective type is ok.  */
+  memcpy (&mbr, &example_pmbr, sizeof (mbr));
+  grub_gpt_pmbr_check (&mbr);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
+static void
+header_test (void)
+{
+  struct grub_gpt_header primary, backup;
+
+  /* Example headers should be valid.  */
+  memcpy (&primary, &example_primary, sizeof (primary));
+  grub_gpt_header_check (&primary, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  memcpy (&backup, &example_backup, sizeof (backup));
+  grub_gpt_header_check (&backup, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  /* Twiddle the GUID to invalidate the CRC. */
+  primary.guid.data1 = 0;
+  grub_gpt_header_check (&primary, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  backup.guid.data1 = 0;
+  grub_gpt_header_check (&backup, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
+static void
+read_valid_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert (gpt->status == (GRUB_GPT_PROTECTIVE_MBR |
+				    GRUB_GPT_PRIMARY_HEADER_VALID |
+				    GRUB_GPT_PRIMARY_ENTRIES_VALID |
+				    GRUB_GPT_BACKUP_HEADER_VALID |
+				    GRUB_GPT_BACKUP_ENTRIES_VALID),
+		    "unexpected status: 0x%02x", gpt->status);
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
+static void
+read_invalid_entries_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Corrupt the first entry in both tables.  */
+  memset (&data.raw->primary_entries[0], 0x55,
+	  sizeof (data.raw->primary_entries[0]));
+  memset (&data.raw->backup_entries[0], 0x55,
+	  sizeof (data.raw->backup_entries[0]));
+  sync_disk (&data);
+
+  gpt = grub_gpt_read (data.dev->disk);
+  grub_test_assert (gpt == NULL, "no error reported for corrupt entries");
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+static void
+read_fallback_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Corrupt the primary header.  */
+  memset (&data.raw->primary_header.guid, 0x55,
+	  sizeof (data.raw->primary_header.guid));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID) == 0,
+		    "unreported corrupt primary header");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the backup header.  */
+  memset (&data.raw->backup_header.guid, 0x55,
+	  sizeof (data.raw->backup_header.guid));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) == 0,
+		    "unreported corrupt backup header");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the primary entry table.  */
+  memset (&data.raw->primary_entries[0], 0x55,
+	  sizeof (data.raw->primary_entries[0]));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID) == 0,
+		    "unreported corrupt primary entries table");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Corrupt the backup entry table.  */
+  memset (&data.raw->backup_entries[0], 0x55,
+	  sizeof (data.raw->backup_entries[0]));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID) == 0,
+		    "unreported corrupt backup entries table");
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* If primary is corrupt and disk size is unknown fallback fails.  */
+  memset (&data.raw->primary_header.guid, 0x55,
+	  sizeof (data.raw->primary_header.guid));
+  sync_disk (&data);
+  data.dev->disk->total_sectors = GRUB_DISK_SIZE_UNKNOWN;
+  gpt = grub_gpt_read (data.dev->disk);
+  grub_test_assert (gpt == NULL, "no error reported");
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+static void
+repair_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Erase/Repair primary.  */
+  memset (&data.raw->primary_header, 0, sizeof (data.raw->primary_header));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  if (memcmp (&gpt->primary, &example_primary, sizeof (gpt->primary)))
+    {
+      printf ("Invalid restored primary header:\n");
+      hexdump (16, (char*)&gpt->primary, sizeof (gpt->primary));
+      printf ("Expected primary header:\n");
+      hexdump (16, (char*)&example_primary, sizeof (example_primary));
+      grub_test_assert (0, "repair did not restore primary header");
+    }
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  /* Erase/Repair backup.  */
+  memset (&data.raw->backup_header, 0, sizeof (data.raw->backup_header));
+  sync_disk (&data);
+  gpt = read_disk (&data);
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  if (memcmp (&gpt->backup, &example_backup, sizeof (gpt->backup)))
+    {
+      printf ("Invalid restored backup header:\n");
+      hexdump (16, (char*)&gpt->backup, sizeof (gpt->backup));
+      printf ("Expected backup header:\n");
+      hexdump (16, (char*)&example_backup, sizeof (example_backup));
+      grub_test_assert (0, "repair did not restore backup header");
+    }
+  grub_gpt_free (gpt);
+  reset_disk (&data);
+
+  close_disk (&data);
+}
+
+/* Finding/reading/writing the backup GPT may be difficult if the OS and
+ * BIOS report different sizes for the same disk.  We need to gracefully
+ * recognize this and avoid causing trouble for the OS.  */
+static void
+weird_disk_size_test (void)
+{
+  struct test_data data;
+  grub_gpt_t gpt;
+
+  open_disk (&data);
+
+  /* Chop off 65536 bytes (128 512B sectors) which may happen when the
+   * BIOS thinks you are using a software RAID system that reserves that
+   * area for metadata when in fact you are not and using the bare disk.  */
+  grub_test_assert(data.dev->disk->total_sectors == DISK_SECTORS,
+		   "unexpected disk size: 0x%llx",
+		   (unsigned long long) data.dev->disk->total_sectors);
+  data.dev->disk->total_sectors -= 128;
+
+  gpt = read_disk (&data);
+  assert_error_stack_empty ();
+  /* Reading the alternate_lba should have been blocked and reading
+   * the (new) end of disk should have found no useful data.  */
+  grub_test_assert ((gpt->status & GRUB_GPT_BACKUP_HEADER_VALID) == 0,
+		    "unreported missing backup header");
+
+  /* We should be able to reconstruct the backup header and the location
+   * of the backup should remain unchanged, trusting the GPT data over
+   * what the BIOS is telling us.  Further changes are left to the OS.  */
+  grub_gpt_repair (data.dev->disk, gpt);
+  grub_test_assert (grub_errno == GRUB_ERR_NONE,
+		    "repair failed: %s", grub_errmsg);
+  grub_test_assert (memcmp (&gpt->primary, &example_primary,
+	                    sizeof (gpt->primary)) == 0,
+		    "repair corrupted primary header");
+
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
+static void
+iterate_partitions_test (void)
+{
+  struct test_data data;
+  struct grub_gpt_partentry *p;
+  grub_gpt_t gpt;
+  grub_uint32_t n;
+
+  open_disk (&data);
+  gpt = read_disk (&data);
+
+  for (n = 0; (p = grub_gpt_get_partentry (gpt, n)) != NULL; n++)
+    grub_test_assert (memcmp (p, &example_entries[n], sizeof (*p)) == 0,
+		      "unexpected partition %d data", n);
+
+  grub_test_assert (n == TABLE_ENTRIES, "unexpected partition limit: %d", n);
+
+  grub_gpt_free (gpt);
+  close_disk (&data);
+}
+
+static void
+large_partitions_test (void)
+{
+  struct test_data data;
+  struct grub_gpt_partentry *p;
+  grub_gpt_t gpt;
+  grub_uint32_t n;
+
+  open_disk (&data);
+
+  /* Double the entry size, cut the number of entries in half.  */
+  data.raw->primary_header.maxpart =
+    data.raw->backup_header.maxpart =
+    grub_cpu_to_le32_compile_time (TABLE_ENTRIES/2);
+  data.raw->primary_header.partentry_size =
+    data.raw->backup_header.partentry_size =
+    grub_cpu_to_le32_compile_time (ENTRY_SIZE*2);
+  data.raw->primary_header.partentry_crc32 =
+    data.raw->backup_header.partentry_crc32 =
+    grub_cpu_to_le32_compile_time (0xf2c45af8);
+  data.raw->primary_header.crc32 = grub_cpu_to_le32_compile_time (0xde00cc8f);
+  data.raw->backup_header.crc32 = grub_cpu_to_le32_compile_time (0x6d72e284);
+
+  memset (&data.raw->primary_entries, 0,
+	  sizeof (data.raw->primary_entries));
+  for (n = 0; n < TABLE_ENTRIES/2; n++)
+    memcpy (&data.raw->primary_entries[n*2], &example_entries[n],
+	    sizeof (data.raw->primary_entries[0]));
+  memcpy (&data.raw->backup_entries, &data.raw->primary_entries,
+	  sizeof (data.raw->backup_entries));
+
+  sync_disk(&data);
+  gpt = read_disk (&data);
+
+  for (n = 0; (p = grub_gpt_get_partentry (gpt, n)) != NULL; n++)
+    grub_test_assert (memcmp (p, &example_entries[n], sizeof (*p)) == 0,
+		      "unexpected partition %d data", n);
+
+  grub_test_assert (n == TABLE_ENTRIES/2, "unexpected partition limit: %d", n);
+
+  grub_gpt_free (gpt);
+
+  /* Editing memory beyond the entry structure should still change the crc.  */
+  data.raw->primary_entries[1].attrib = 0xff;
+
+  sync_disk(&data);
+  gpt = read_disk (&data);
+  grub_test_assert (gpt->status == (GRUB_GPT_PROTECTIVE_MBR |
+				    GRUB_GPT_PRIMARY_HEADER_VALID |
+				    GRUB_GPT_BACKUP_HEADER_VALID |
+				    GRUB_GPT_BACKUP_ENTRIES_VALID),
+		    "unexpected status: 0x%02x", gpt->status);
+  grub_gpt_free (gpt);
+
+  close_disk (&data);
+}
+
+static void
+invalid_partsize_test (void)
+{
+  struct grub_gpt_header header = {
+    .magic = GRUB_GPT_HEADER_MAGIC,
+    .version = GRUB_GPT_HEADER_VERSION,
+    .headersize = sizeof (struct grub_gpt_header),
+    .crc32 = grub_cpu_to_le32_compile_time (0x1ff2a054),
+    .header_lba = grub_cpu_to_le64_compile_time (PRIMARY_HEADER_SECTOR),
+    .alternate_lba = grub_cpu_to_le64_compile_time (BACKUP_HEADER_SECTOR),
+    .start = grub_cpu_to_le64_compile_time (DATA_START_SECTOR),
+    .end = grub_cpu_to_le64_compile_time (DATA_END_SECTOR),
+    .guid = GRUB_GPT_GUID_INIT(0x69c131ad, 0x67d6, 0x46c6,
+			       0x93, 0xc4, 0x12, 0x4c, 0x75, 0x52, 0x56, 0xac),
+    .partitions = grub_cpu_to_le64_compile_time (PRIMARY_TABLE_SECTOR),
+    .maxpart = grub_cpu_to_le32_compile_time (TABLE_ENTRIES),
+    /* Triple the entry size, which is not valid.  */
+    .partentry_size = grub_cpu_to_le32_compile_time (ENTRY_SIZE*3),
+    .partentry_crc32 = grub_cpu_to_le32_compile_time (0x074e052c),
+  };
+
+  grub_gpt_header_check(&header, GRUB_DISK_SECTOR_BITS);
+  grub_test_assert (grub_errno == GRUB_ERR_BAD_PART_TABLE,
+		    "unexpected error: %s", grub_errmsg);
+  grub_test_assert (strcmp(grub_errmsg, "invalid GPT entry size") == 0,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+}
+
+static void
+search_part_label_test (void)
+{
+  struct test_data data;
+  const char *test_result;
+  char *expected_result;
+
+  open_disk (&data);
+
+  expected_result = grub_xasprintf ("%s,gpt1", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_label ("EFI SYSTEM", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  expected_result = grub_xasprintf ("%s,gpt2", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_label ("BIOS BOOT", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  grub_env_unset ("test_result");
+  grub_search_part_label ("bogus name", "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result == NULL,
+		    "unexpected device: %s", test_result);
+  grub_test_assert (grub_errno == GRUB_ERR_FILE_NOT_FOUND,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+static void
+search_part_uuid_test (void)
+{
+  struct test_data data;
+  const char gpt1_uuid[] = "A0F1792E-B4CE-4136-BCF2-1AFC133C2828";
+  const char gpt2_uuid[] = "876c898d-1b40-4727-a161-edf9b5486674";
+  const char bogus_uuid[] = "1534c928-c50e-4866-9daf-6a9fd7918a76";
+  const char *test_result;
+  char *expected_result;
+
+  open_disk (&data);
+
+  expected_result = grub_xasprintf ("%s,gpt1", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (gpt1_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  expected_result = grub_xasprintf ("%s,gpt2", data.dev->disk->name);
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (gpt2_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result && strcmp (test_result, expected_result) == 0,
+		    "wrong device: %s (%s)", test_result, expected_result);
+  grub_free (expected_result);
+
+  grub_env_unset ("test_result");
+  grub_search_part_uuid (bogus_uuid, "test_result", 0, NULL, 0);
+  test_result = grub_env_get ("test_result");
+  grub_test_assert (test_result == NULL,
+		    "unexpected device: %s", test_result);
+  grub_test_assert (grub_errno == GRUB_ERR_FILE_NOT_FOUND,
+		    "unexpected error: %s", grub_errmsg);
+  grub_errno = GRUB_ERR_NONE;
+
+  close_disk (&data);
+}
+
+void
+grub_unit_test_init (void)
+{
+  grub_init_all ();
+  grub_hostfs_init ();
+  grub_host_init ();
+  grub_test_register ("gpt_pmbr_test", pmbr_test);
+  grub_test_register ("gpt_header_test", header_test);
+  grub_test_register ("gpt_read_valid_test", read_valid_test);
+  grub_test_register ("gpt_read_invalid_test", read_invalid_entries_test);
+  grub_test_register ("gpt_read_fallback_test", read_fallback_test);
+  grub_test_register ("gpt_repair_test", repair_test);
+  grub_test_register ("gpt_iterate_partitions_test", iterate_partitions_test);
+  grub_test_register ("gpt_large_partitions_test", large_partitions_test);
+  grub_test_register ("gpt_invalid_partsize_test", invalid_partsize_test);
+  grub_test_register ("gpt_weird_disk_size_test", weird_disk_size_test);
+  grub_test_register ("gpt_search_part_label_test", search_part_label_test);
+  grub_test_register ("gpt_search_uuid_test", search_part_uuid_test);
+}
+
+void
+grub_unit_test_fini (void)
+{
+  grub_test_unregister ("gpt_pmbr_test");
+  grub_test_unregister ("gpt_header_test");
+  grub_test_unregister ("gpt_read_valid_test");
+  grub_test_unregister ("gpt_read_invalid_test");
+  grub_test_unregister ("gpt_read_fallback_test");
+  grub_test_unregister ("gpt_repair_test");
+  grub_test_unregister ("gpt_iterate_partitions_test");
+  grub_test_unregister ("gpt_large_partitions_test");
+  grub_test_unregister ("gpt_invalid_partsize_test");
+  grub_test_unregister ("gpt_weird_disk_size_test");
+  grub_test_unregister ("gpt_search_part_label_test");
+  grub_test_unregister ("gpt_search_part_uuid_test");
+  grub_fini_all ();
+}
diff -Naur a/tests/gptprio_test.in b/tests/gptprio_test.in
--- a/tests/gptprio_test.in	1970-01-01 00:00:00.000000000 -0000
+++ b/tests/gptprio_test.in	2024-09-05 16:05:42.313358833 -0000
@@ -0,0 +1,207 @@
+#! /bin/bash
+set -e
+
+# Copyright (C) 2010  Free Software Foundation, Inc.
+# Copyright (C) 2014  CoreOS, Inc.
+#
+# GRUB is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+sgdisk=sgdisk
+grubshell=@builddir@/grub-shell
+
+if ! which "${sgdisk}" >/dev/null 2>&1; then
+   echo "sgdisk not installed; cannot test gptprio."
+   exit 77
+fi
+
+. "@builddir@/grub-core/modinfo.sh"
+
+case "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" in
+    mips-qemu_mips | mipsel-qemu_mips | i386-qemu | i386-multiboot | i386-coreboot | mipsel-loongson)
+	disk=ata0
+	;;
+    powerpc-ieee1275)
+	disk=ieee1275//pci@80000000/mac-io@4/ata-3@20000/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    sparc64-ieee1275)
+	disk=ieee1275//pci@1fe\,0/pci-ata@5/ide0@500/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    i386-ieee1275)
+	disk=ieee1275/d
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    mips-arc)
+	# FIXME: ARC firmware has bugs which prevent it from accessing hard disk w/o dvh disklabel.
+	exit 0 ;;
+    mipsel-arc)
+	disk=arc/scsi0/disk0/rdisk0
+	;;
+    *)
+	disk=hd0
+	;;
+esac
+img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+trap "rm -f '${img1}'" EXIT
+
+prio_type="5dfbf5f4-2848-4bac-aa5e-0d9a20b745a6"
+declare -a prio_uuid
+prio_uuid[2]="9b003904-d006-4ab3-97f1-73f547b7af1a"
+prio_uuid[3]="1aa5a658-5b02-414d-9b71-f7e6c151f0cd"
+prio_uuid[4]="8aa0240d-98af-42b0-b32a-ccbe0572d62b"
+
+create_disk_image () {
+    size=$1
+    rm -f "${img1}"
+    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=$((size - 1)) status=none
+    ${sgdisk} \
+        -n 1:0:+1 -c 1:ESP -t 1:ef00 \
+        -n 2:0:+1 -c 2:A -t 2:"${prio_type}" -u 2:"${prio_uuid[2]}" \
+        -n 3:0:+1 -c 3:B -t 3:"${prio_type}" -u 3:"${prio_uuid[3]}" \
+        -n 4:0:+1 -c 4:C -t 4:"${prio_type}" -u 4:"${prio_uuid[4]}" \
+        "${img1}" >/dev/null
+}
+
+wipe_disk_area () {
+    sector=$1
+    size=$2
+    dd if=/dev/zero of="${img1}" bs=512 count=${size} seek=${sector} conv=notrunc status=none
+}
+
+is_zero () {
+    sector=$1
+    size=$2
+    cmp -s -i $((sector * 512)) -n $((size * 512)) /dev/zero "${img1}"
+}
+
+check_is_zero () {
+    sector=$1
+    size=$2
+    if ! is_zero "$@"; then
+        echo "$size sector(s) starting at $sector should be all zero"
+        exit 1
+    fi
+}
+
+check_not_zero () {
+    sector=$1
+    size=$2
+    if is_zero "$@"; then
+        echo "$size sector(s) starting at $sector should not be all zero"
+        exit 1
+    fi
+}
+
+fmt_prio () {
+    priority=$(( ( $1 & 15 ) << 48 ))
+    tries=$(( ( $2 & 15 ) << 52 ))
+    success=$(( ( $3 & 1 ) << 56 ))
+    printf %016x $(( priority | tries | success ))
+}
+
+set_prio () {
+    part="$1"
+    attr=$(fmt_prio $2 $3 $4)
+    ${sgdisk} -A "${part}:=:${attr}" "${img1}" >/dev/null
+}
+
+check_prio () {
+    part="$1"
+    expect=$(fmt_prio $2 $3 $4)
+    result=$(LANG=C ${sgdisk} -i "${part}" "${img1}" 2>&1 \
+            | awk '/^Attribute flags: / {print $3}')
+    if [[ "${expect}" != "${result}" ]]; then
+        echo "Partition ${part} has attributes ${result:-??}, not ${expect}"
+        exit 1
+    fi
+}
+
+run_next() {
+    "${grubshell}" --disk="${img1}" --modules=gptprio <<EOF
+gptprio.next -d next_dev -u next_uuid "${disk}"
+echo next_dev=\$next_dev
+echo next_uuid=\$next_uuid
+EOF
+}
+
+check_next () {
+    part="$1"
+    output=$(run_next)
+    if grep ^error <<<"${output}"; then
+        exit 1
+    fi
+    if ! grep -q "^next_dev=${disk},gpt${part}$" <<<"${output}"; then
+        echo "Unexpected next_dev: (expected ${disk},gpt${part})"
+        echo "${output}"
+        exit 1
+    fi
+    if ! grep -q "^next_uuid=${prio_uuid[$part]}$" <<<"${output}"; then
+        echo "Unexpected next_uuid: (expected ${prio_uuid[$part]})"
+        echo "${output}"
+        exit 1
+    fi
+    check_prio "$@"
+}
+
+# Basic sanity check
+create_disk_image 100
+set_prio 2 3 2 1
+check_prio 2 3 2 1
+
+# Check gptprio works without modifying the disk when no update is required.
+# Leaves any existing corruption as is, repairing in the OS is better.
+create_disk_image 100
+set_prio 2 1 0 1
+wipe_disk_area 99 1
+check_next 2 1 0 1
+check_is_zero 99 1
+
+create_disk_image 100
+set_prio 2 1 0 1
+wipe_disk_area 1 1
+check_next 2 1 0 1
+check_is_zero 1 1
+
+# When writes do need to be made go ahead and perform the repair.
+create_disk_image 100
+set_prio 2 1 1 0
+wipe_disk_area 99 1
+check_next 2 1 0 0
+check_not_zero 99 1
+
+create_disk_image 100
+set_prio 2 1 1 0
+wipe_disk_area 1 1
+check_next 2 1 0 0
+check_not_zero 1 1
+
+# Try two partitions before falling before falling back to a third
+create_disk_image 100
+set_prio 2 3 3 0
+set_prio 3 2 2 0
+set_prio 4 1 0 1
+check_next 2 3 2 0
+check_next 2 3 1 0
+check_next 2 3 0 0
+check_next 3 2 1 0
+check_next 3 2 0 0
+check_next 4 1 0 1
+check_next 4 1 0 1
+check_next 4 1 0 1
+check_prio 2 3 0 0
+check_prio 3 2 0 0
diff -Naur a/tests/gptrepair_test.in b/tests/gptrepair_test.in
--- a/tests/gptrepair_test.in	1970-01-01 00:00:00.000000000 -0000
+++ b/tests/gptrepair_test.in	2024-09-05 16:05:42.313358833 -0000
@@ -0,0 +1,102 @@
+#! /bin/sh
+set -e
+
+# Copyright (C) 2010  Free Software Foundation, Inc.
+# Copyright (C) 2014  CoreOS, Inc.
+#
+# GRUB is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# GRUB is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+
+parted=parted
+grubshell=@builddir@/grub-shell
+
+. "@builddir@/grub-core/modinfo.sh"
+
+case "${grub_modinfo_target_cpu}-${grub_modinfo_platform}" in
+    mips-qemu_mips | mipsel-qemu_mips | i386-qemu | i386-multiboot | i386-coreboot | mipsel-loongson)
+	disk=ata0
+	;;
+    powerpc-ieee1275)
+	disk=ieee1275//pci@80000000/mac-io@4/ata-3@20000/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    sparc64-ieee1275)
+	disk=ieee1275//pci@1fe\,0/pci-ata@5/ide0@500/disk@0
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    i386-ieee1275)
+	disk=ieee1275/d
+	# FIXME: QEMU firmware has bugs which prevent it from accessing hard disk w/o recognised label.
+	exit 0
+	;;
+    mips-arc)
+	# FIXME: ARC firmware has bugs which prevent it from accessing hard disk w/o dvh disklabel.
+	exit 0 ;;
+    mipsel-arc)
+	disk=arc/scsi0/disk0/rdisk0
+	;;
+    *)
+	disk=hd0
+	;;
+esac
+img1="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+img2="`mktemp "${TMPDIR:-/tmp}/tmp.XXXXXXXXXX"`" || exit 1
+trap "rm -f '${img1}' '${img2}'" EXIT
+
+create_disk_image () {
+    size=$1
+    rm -f "${img1}"
+    dd if=/dev/zero of="${img1}" bs=512 count=1 seek=$((size - 1)) status=none
+    ${parted} -a none -s "${img1}" mklabel gpt
+    cp "${img1}" "${img2}"
+}
+
+wipe_disk_area () {
+    sector=$1
+    size=$2
+    dd if=/dev/zero of="${img2}" bs=512 count=${size} seek=${sector} conv=notrunc status=none
+}
+
+do_repair () {
+    output="`echo "gptrepair ($disk)" | "${grubshell}" --disk="${img2}"`"
+    if echo "${output}" | grep ^error; then
+        return 1
+    fi
+    if echo "${output}" | grep -v GPT; then
+        echo "Unexpected output ${output}"
+        return 1
+    fi
+    echo "${output}"
+}
+
+echo "Nothing to repair:"
+create_disk_image 100
+do_repair
+cmp "${img1}" "${img2}"
+echo
+
+echo "Repair primary (MBR left intact)"
+create_disk_image 100
+wipe_disk_area 1 1
+do_repair
+cmp "${img1}" "${img2}"
+echo
+
+echo "Repair backup"
+create_disk_image 100
+wipe_disk_area 99 1
+do_repair
+cmp "${img1}" "${img2}"
+echo
