From 9b6f1b1d8e1066a513a2939c613b36c9e887512c Mon Sep 17 00:00:00 2001
From: Kai Lueke <kailuke@microsoft.com>
Date: Thu, 20 Nov 2025 23:43:55 +0900
Subject: [PATCH 04/10] discover-image: Follow symlinks in a given root

So far systemd-sysext with --root= specified didn't follow extension
symlinks (such as the "current" symlinks managed by systemd-sysupdate).
The main use case is running systemd-sysext --root=/sysroot for setting
up the overlay mounts already from the initrd.

Resolve symlinks correctly but don't defend against later symlink races
that would access a path outside of the given root. Malicous live
modifications are not a realistic threat model and anyway for that one
would need to rework how the image entry is passed over up to the point
when the loop device is set up. This change here does not introduce this
weakness nor does it expose it more than before. Thus, make it explicit
that setting up the extensions for a given --root= implies a certain
trust into this given root tree that it does not try do race conditions
with symlinks to trick systemd-sysext to mount a file outside --root=.
Without a strict --image-policy= set we would anyway mount filesystems
right away which is another attack vector but, again, the main use case
is to do this for the final system which is trusted at this stage.
---
 src/shared/discover-image.c | 162 +++++++++++++++++++++++++++---------
 1 file changed, 122 insertions(+), 40 deletions(-)

diff --git a/src/shared/discover-image.c b/src/shared/discover-image.c
index 1402303a8e..97c4284eca 100644
--- a/src/shared/discover-image.c
+++ b/src/shared/discover-image.c
@@ -356,6 +356,8 @@ static int image_make(
 
         /* We explicitly *do* follow symlinks here, since we want to allow symlinking trees, raw files and block
          * devices into /var/lib/machines/, and treat them normally.
+         * Note that if the caller does not want to follow symlinks (and does not care about symlink races)
+         * then the caller should pass in a resolved dir_path and filename and an fd.
          *
          * This function returns -ENOENT if we can't find the image after all, and -EMEDIUMTYPE if it's not a file we
          * recognize. */
@@ -700,10 +702,7 @@ int image_find(RuntimeScope scope,
                const char *root,
                Image **ret) {
 
-        /* As mentioned above, we follow symlinks on this fstatat(), because we want to permit people to
-         * symlink block devices into the search path. (For now, we disable that when operating relative to
-         * some root directory.) */
-        int open_flags = root ? O_NOFOLLOW : 0, r;
+        int r;
 
         assert(scope < _RUNTIME_SCOPE_MAX && scope != RUNTIME_SCOPE_GLOBAL);
         assert(class >= 0);
@@ -718,16 +717,24 @@ int image_find(RuntimeScope scope,
         if (!names)
                 return -ENOMEM;
 
+        _cleanup_close_ int root_fd = AT_FDCWD;
+        if (root) {
+                root_fd = open(root, O_CLOEXEC|O_DIRECTORY|O_PATH);
+                if (root_fd < 0) {
+                        log_debug_errno(errno, "Failed to open root directory '%s': %m", root);
+                        return -errno;
+                }
+        }
+
         _cleanup_strv_free_ char **search = NULL;
         r = pick_image_search_path(scope, class, root, &search);
         if (r < 0)
                 return r;
 
         STRV_FOREACH(path, search) {
-                _cleanup_free_ char *resolved = NULL;
                 _cleanup_closedir_ DIR *d = NULL;
 
-                r = chase_and_opendir(*path, root, CHASE_PREFIX_ROOT, &resolved, &d);
+                r = chase_and_opendir(*path, root, CHASE_PREFIX_ROOT, NULL, &d);
                 if (r == -ENOENT)
                         continue;
                 if (r < 0)
@@ -736,11 +743,20 @@ int image_find(RuntimeScope scope,
                 STRV_FOREACH(n, names) {
                         _cleanup_free_ char *fname_buf = NULL;
                         const char *fname = *n;
+                        _cleanup_free_ char *fname_path = NULL;
+                        _cleanup_free_ char *resolved_file = NULL;
+                        _cleanup_close_ int fd = -EBADF;
+                        _cleanup_close_ int subdirfd = -EBADF;
 
-                        _cleanup_close_ int fd = openat(dirfd(d), fname, O_PATH|O_CLOEXEC|open_flags);
+                        fname_path = path_join(*path, fname);
+                        if (!fname_path)
+                                return -ENOMEM;
+
+                        /* Follow symlinks only inside given root */
+                        fd = chase_and_open(fname_path, root, CHASE_PREFIX_ROOT, O_PATH|O_CLOEXEC, &resolved_file);
                         if (fd < 0) {
-                                if (errno != ENOENT)
-                                        return -errno;
+                                if (fd != -ENOENT)
+                                        return fd;
 
                                 continue;
                         }
@@ -769,10 +785,6 @@ int image_find(RuntimeScope scope,
 
                                 *ASSERT_PTR(endswith(suffix, ".v")) = 0;
 
-                                _cleanup_free_ char *vp = path_join(resolved, fname);
-                                if (!vp)
-                                        return -ENOMEM;
-
                                 PickFilter filter = {
                                         .type_mask = endswith(suffix, ".raw") ? (UINT32_C(1) << DT_REG) | (UINT32_C(1) << DT_BLK) : (UINT32_C(1) << DT_DIR),
                                         .basename = name,
@@ -782,23 +794,27 @@ int image_find(RuntimeScope scope,
 
                                 _cleanup_(pick_result_done) PickResult result = PICK_RESULT_NULL;
                                 r = path_pick(root,
-                                              /* toplevel_fd= */ AT_FDCWD,
-                                              vp,
+                                              root_fd,
+                                              fname_path,
                                               &filter,
-                                              PICK_ARCHITECTURE|PICK_TRIES,
+                                              PICK_ARCHITECTURE|PICK_TRIES|PICK_RESOLVE,
                                               &result);
                                 if (r < 0) {
-                                        log_debug_errno(r, "Failed to pick versioned image on '%s', skipping: %m", vp);
+                                        log_debug_errno(r, "Failed to pick versioned image on '%s/%s', skipping: %m", strempty(root), skip_leading_slash(fname_path));
                                         continue;
                                 }
                                 if (!result.path) {
-                                        log_debug("Found versioned directory '%s', without matching entry, skipping: %m", vp);
+                                        log_debug("Found versioned directory '%s/%s', without matching entry, skipping.", strempty(root), skip_leading_slash(fname_path));
                                         continue;
                                 }
 
                                 /* Refresh the stat data for the discovered target */
                                 st = result.st;
-                                fd = safe_close(fd);
+                                /* Set subdirfd to indicate it should be used instead of dirfd(d).
+                                 * We reuse the O_PATH fd because it's only used in openat style in image_make().
+                                 * This subdirfd can be deleted with https://github.com/systemd/systemd/pull/39970 */
+                                subdirfd = TAKE_FD(fd);
+                                close_and_replace(fd, result.fd);
 
                                 _cleanup_free_ char *bn = NULL;
                                 r = path_extract_filename(result.path, &bn);
@@ -812,13 +828,38 @@ int image_find(RuntimeScope scope,
                                         return log_oom();
 
                                 fname = fname_buf;
+                                fname_path = mfree(fname_path);
+                                fname_path = path_join(*path, fname);
+                                if (!fname_path)
+                                        return log_oom();
 
+                                resolved_file = mfree(resolved_file);
+                                resolved_file = path_join(root, result.path);
+                                if (!resolved_file)
+                                        return log_oom();
                         } else if (!S_ISDIR(st.st_mode) && !S_ISBLK(st.st_mode)) {
                                 log_debug("Ignoring non-directory and non-block device file '%s' without suffix.", fname);
                                 continue;
                         }
 
-                        r = image_make(class, name, dirfd(d), resolved, fname, fd, &st, ret);
+                        /* Only put resolved paths into the image entry.
+                         * Defending against symlink races is out of scope
+                         * and we trust a given root in that regard. */
+                        _cleanup_free_ char *resolved_dir = NULL;
+                        _cleanup_free_ char *resolved_fname = NULL;
+
+                        r = path_extract_directory(resolved_file, &resolved_dir);
+                        if (r < 0) {
+                                log_debug_errno(r, "Failed to extract directory name of image path '%s', skipping: %m", resolved_file);
+                                continue;
+                        }
+                        r = path_extract_filename(resolved_file, &resolved_fname);
+                        if (r < 0) {
+                                log_debug_errno(r, "Failed to extract basename of image path '%s', skipping: %m", resolved_file);
+                                continue;
+                        }
+
+                        r = image_make(class, name, subdirfd == -EBADF ? dirfd(d) : subdirfd, resolved_dir, resolved_fname, fd, &st, ret);
                         if (IN_SET(r, -ENOENT, -EMEDIUMTYPE))
                                 continue;
                         if (r < 0)
@@ -899,26 +940,31 @@ int image_discover(
                 const char *root,
                 Hashmap **images) {
 
-        /* As mentioned above, we follow symlinks on this fstatat(), because we want to permit people to
-         * symlink block devices into the search path. (For now, we disable that when operating relative to
-         * some root directory.) */
-        int open_flags = root ? O_NOFOLLOW : 0, r;
+        int r;
 
         assert(scope < _RUNTIME_SCOPE_MAX && scope != RUNTIME_SCOPE_GLOBAL);
         assert(class >= 0);
         assert(class < _IMAGE_CLASS_MAX);
         assert(images);
 
+        _cleanup_close_ int root_fd = AT_FDCWD;
+        if (root) {
+                root_fd = open(root, O_CLOEXEC|O_DIRECTORY|O_PATH);
+                if (root_fd < 0) {
+                        log_debug_errno(errno, "Failed to open root directory '%s': %m", root);
+                        return -errno;
+                }
+        }
+
         _cleanup_strv_free_ char **search = NULL;
         r = pick_image_search_path(scope, class, root, &search);
         if (r < 0)
                 return r;
 
         STRV_FOREACH(path, search) {
-                _cleanup_free_ char *resolved = NULL;
                 _cleanup_closedir_ DIR *d = NULL;
 
-                r = chase_and_opendir(*path, root, CHASE_PREFIX_ROOT, &resolved, &d);
+                r = chase_and_opendir(*path, root, CHASE_PREFIX_ROOT, NULL, &d);
                 if (r == -ENOENT)
                         continue;
                 if (r < 0)
@@ -928,14 +974,23 @@ int image_discover(
                         _cleanup_free_ char *pretty = NULL, *fname_buf = NULL;
                         _cleanup_(image_unrefp) Image *image = NULL;
                         const char *fname = de->d_name;
+                        _cleanup_free_ char *fname_path = NULL;
+                        _cleanup_free_ char *resolved_file = NULL;
+                        _cleanup_close_ int fd = -EBADF;
+                        _cleanup_close_ int subdirfd = -EBADF;
 
                         if (dot_or_dot_dot(fname))
                                 continue;
 
-                        _cleanup_close_ int fd = openat(dirfd(d), fname, O_PATH|O_CLOEXEC|open_flags);
+                        fname_path = path_join(*path, fname);
+                        if (!fname_path)
+                                return -ENOMEM;
+
+                        /* Follow symlinks only inside given root */
+                        fd = chase_and_open(fname_path, root, CHASE_PREFIX_ROOT, O_PATH|O_CLOEXEC, &resolved_file);
                         if (fd < 0) {
-                                if (errno != ENOENT)
-                                        return -errno;
+                                if (fd != -ENOENT)
+                                        return fd;
 
                                 continue; /* Vanished while we were looking at it */
                         }
@@ -977,10 +1032,6 @@ int image_discover(
                                                 continue;
                                         }
 
-                                        _cleanup_free_ char *vp = path_join(resolved, fname);
-                                        if (!vp)
-                                                return -ENOMEM;
-
                                         PickFilter filter = {
                                                 .type_mask = endswith(suffix, ".raw") ? (UINT32_C(1) << DT_REG) | (UINT32_C(1) << DT_BLK) : (UINT32_C(1) << DT_DIR),
                                                 .basename = pretty,
@@ -990,23 +1041,27 @@ int image_discover(
 
                                         _cleanup_(pick_result_done) PickResult result = PICK_RESULT_NULL;
                                         r = path_pick(root,
-                                                      /* toplevel_fd= */ AT_FDCWD,
-                                                      vp,
+                                                      root_fd,
+                                                      fname_path,
                                                       &filter,
-                                                      PICK_ARCHITECTURE|PICK_TRIES,
+                                                      PICK_ARCHITECTURE|PICK_TRIES|PICK_RESOLVE,
                                                       &result);
                                         if (r < 0) {
-                                                log_debug_errno(r, "Failed to pick versioned image on '%s', skipping: %m", vp);
+                                                log_debug_errno(r, "Failed to pick versioned image on '%s/%s', skipping: %m", strempty(root), skip_leading_slash(fname_path));
                                                 continue;
                                         }
                                         if (!result.path) {
-                                                log_debug("Found versioned directory '%s', without matching entry, skipping: %m", vp);
+                                                log_debug("Found versioned directory '%s/%s', without matching entry, skipping.", strempty(root), skip_leading_slash(fname_path));
                                                 continue;
                                         }
 
                                         /* Refresh the stat data for the discovered target */
                                         st = result.st;
-                                        fd = safe_close(fd);
+                                        /* Set subdirfd to indicate it should be used instead of dirfd(d).
+                                         * We reuse the O_PATH fd because it's only used in openat style in image_make().
+                                         * This subdirfd can be deleted with https://github.com/systemd/systemd/pull/39970 */
+                                        subdirfd = TAKE_FD(fd);
+                                        close_and_replace(fd, result.fd);
 
                                         _cleanup_free_ char *bn = NULL;
                                         r = path_extract_filename(result.path, &bn);
@@ -1020,6 +1075,15 @@ int image_discover(
                                                 return log_oom();
 
                                         fname = fname_buf;
+                                        fname_path = mfree(fname_path);
+                                        fname_path = path_join(*path, fname);
+                                        if (!fname_path)
+                                                return log_oom();
+
+                                        resolved_file = mfree(resolved_file);
+                                        resolved_file = path_join(root, result.path);
+                                        if (!resolved_file)
+                                                return log_oom();
                                 } else {
                                         r = extract_image_basename(
                                                         fname,
@@ -1052,7 +1116,25 @@ int image_discover(
                         if (hashmap_contains(*images, pretty))
                                 continue;
 
-                        r = image_make(class, pretty, dirfd(d), resolved, fname, fd, &st, &image);
+                        /* Only put resolved paths into the image entry.
+                         * Defending against symlink races is out of scope
+                         * and we trust a given root in that regard. */
+                        _cleanup_free_ char *resolved_dir = NULL;
+                        _cleanup_free_ char *resolved_fname = NULL;
+
+                        r = path_extract_directory(resolved_file, &resolved_dir);
+                        if (r < 0) {
+                                log_debug_errno(r, "Failed to extract directory name of image path '%s', skipping: %m", resolved_file);
+                                continue;
+                        }
+                        r = path_extract_filename(resolved_file, &resolved_fname);
+                        if (r < 0) {
+                                log_debug_errno(r, "Failed to extract basename of image path '%s', skipping: %m", resolved_file);
+                                continue;
+                        }
+
+                        r = image_make(class, pretty, subdirfd == -EBADF ? dirfd(d) : subdirfd, resolved_dir, resolved_fname, fd, &st, &image);
+
                         if (IN_SET(r, -ENOENT, -EMEDIUMTYPE))
                                 continue;
                         if (r < 0)
-- 
2.52.0

